<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>FelixZhang&#39;s Blog</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://felixzhang00.github.io/"/>
  <updated>2017-03-12T06:51:15.000Z</updated>
  <id>http://felixzhang00.github.io/</id>
  
  <author>
    <name>Felix</name>
    <email>836828946@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Stetho的通信原理</title>
    <link href="http://felixzhang00.github.io/2017/03/12/Stetho%E7%9A%84%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86/"/>
    <id>http://felixzhang00.github.io/2017/03/12/Stetho的通信原理/</id>
    <published>2017-03-12T06:34:48.000Z</published>
    <updated>2017-03-12T06:51:15.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Stetho简介"><a href="#Stetho简介" class="headerlink" title="Stetho简介"></a>Stetho简介</h2><p><a href="http://facebook.github.io/stetho/" target="_blank" rel="external">stetho</a>是Facebook推出的安卓APP网络诊断和数据监控的工具，接入方便，功能强大，是Android开发者必备的友好工具。<br>主要功能包括：</p>
<ul>
<li>实时查看App的布局</li>
<li>网络请求抓包</li>
<li>数据库、SharedPreferences文件内容监控</li>
<li>自定义dumpapp插件</li>
<li>对于JavaScript的支持</li>
</ul>
<p>具体的使用方法可以看这篇<a href="https://www.figotan.org/2016/04/18/using-stetho-to-diagnose-data-on-android/" target="_blank" rel="external">文章</a>。<br>本文主要想讲一下自定义dumpapp插件的通信原理。</p>
<h2 id="dumpapp插件示例"><a href="#dumpapp插件示例" class="headerlink" title="dumpapp插件示例"></a>dumpapp插件示例</h2><p>在主机上给设备发送一个<code>files tree</code>命令，得到如下结果：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ ./dumpapp files tree</div><div class="line">+---lib</div><div class="line">+---cache</div><div class="line">|   +---com.android.opengl.shaders_cache</div><div class="line">+---files</div></pre></td></tr></table></figure></p>
<p>在app中对应这样一段java代码，来处理<code>files tree</code>命令。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doTree</span><span class="params">(PrintStream writer)</span> <span class="keyword">throws</span> DumpUsageException </span>&#123;</div><div class="line">  File baseDir = getBaseDir(mContext);</div><div class="line">  printDirectoryVisual(baseDir, <span class="number">0</span>, writer);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>问题是，为什么在主机上执行一段脚本(<a href="https://github.com/facebook/stetho/blob/master/scripts/dumpapp" target="_blank" rel="external"><code>dumpapp.py</code></a>)后会让设备上的app执行相应的处理程序呢？</p>
<p>一般PushService可以完成类似的功能，后台下发一条指令，客户端完成指定的动作。对于Stetho这样的Android调试工具来说，显然不需要使用后台，用ADB就可以实现。</p>
<hr>
<h2 id="ADB通信的原理"><a href="#ADB通信的原理" class="headerlink" title="ADB通信的原理"></a>ADB通信的原理</h2><p>ADB的结构是一个client-server的结构，包含3个部分：</p>
<ul>
<li>Client ： 发送命令。客户端在PC主机上运行，在shell里使用Adb命令的时候就会开启一个client。</li>
<li>Daemon : 在设备上执行命令。守护进程在设备上后台运行。(aabd运行在Andriod设备的底层)</li>
<li>Server ： 管理客户端（client）和守护进程（daemon）的连接。server在PC主机上后台运行。<br><img src="http://7viip0.com1.z0.glb.clouddn.com/17-3-12/10223878-file_1489286370152_c45a.jpg" alt=""></li>
</ul>
<h3 id="smartsocket"><a href="#smartsocket" class="headerlink" title="smartsocket"></a>smartsocket</h3><p>android提供了smartsocket,详见<a href="https://android.googlesource.com/platform/system/core/+/master/adb/protocol.txt" target="_blank" rel="external">这里</a></p>
<blockquote>
<p>— smartsockets ——————————————————-<br>Port 5037 is used for smart sockets which allow a client on the host<br>side to request access to a service in the host adb daemon or in the<br>remote (device) daemon.  The service is requested by ascii name,<br>preceeded by a 4 digit hex length.  Upon successful connection an<br>“OKAY” response is sent, otherwise a “FAIL” message is returned.  Once<br>connected the client is talking to that (remote or local) service.<br>client: <hex4> <service-name><br>server: “OKAY”<br>client: <hex4> <service-name><br>server: “FAIL” <hex4> <reason></reason></hex4></service-name></hex4></service-name></hex4></p>
</blockquote>
<p>总结来说，就是可以给adb-server发送一条指令<code>&lt;service-name&gt;</code>，然后adb-server会转发给adbd，让adbd来执行<code>&lt;service-name&gt;</code>.<br>举例来说，当我们执行<code>adb shell cat /proc/net/unix</code>,最终就是通过adbd在设备上执行的。</p>
<p>Stetho的通信模型如下：<br><img src="http://7viip0.com1.z0.glb.clouddn.com/17-3-12/75166063-file_1489297004530_117bc.png" alt=""><br>其中stetho-server就是app启的一个Thread用来accept客户端的connect。</p>
<hr>
<h2 id="程序流程"><a href="#程序流程" class="headerlink" title="程序流程"></a>程序流程</h2><p>可以通过在关键位置打上断点的方式来看程序的流程。<br>Python可以用<a href="https://www.jetbrains.com/pycharm/" target="_blank" rel="external">Pycharm</a>来打断点。<br>如图配置一个debug版本,这样就可以以<code>./dumapp -l</code>的方式debug了。<br><img src="http://7viip0.com1.z0.glb.clouddn.com/17-3-12/84731891-file_1489298066962_2a09.jpg" alt=""><br>Android app当然是用Android Studio打断点了。</p>
<h3 id="dumpapp-py流程分析"><a href="#dumpapp-py流程分析" class="headerlink" title="dumpapp.py流程分析"></a>dumpapp.py流程分析</h3><p>详见代码(<a href="https://github.com/facebook/stetho/blob/master/scripts/dumpapp" target="_blank" rel="external"><code>dumpapp.py</code></a>)<br><img src="http://7viip0.com1.z0.glb.clouddn.com/17-3-12/32838177-file_1489290757916_15931.png" alt=""></p>
<p>例子1：<br><code>adb.select_service(&#39;shell:cat /proc/net/unix&#39;)</code><br><img src="http://7viip0.com1.z0.glb.clouddn.com/17-3-12/77046872-file_1489287023930_14c4e.png" alt=""><br>通过这个命令其实是在找到指定的Unix域套接字。<br><img src="http://7viip0.com1.z0.glb.clouddn.com/17-3-12/74443269-file_1489287115563_17cdf.png" alt=""><br>在<code>/proc/net/unix</code>文件下可以看到所有的unix域套接字，Path字段前面有@符号的表示它是一个ABSTRACT类型的socket，如果是绝对路径则表示是FILESYSTEM类型的。<br><img src="http://7viip0.com1.z0.glb.clouddn.com/17-3-12/30789563-file_1489287608725_1bbf.jpg" alt=""><br>例子2：<br>发起一个connect到Unix域套接字的请求<br><code>adb.select_service(&#39;localabstract:%s&#39; % (socket_name))</code><br><img src="http://7viip0.com1.z0.glb.clouddn.com/17-3-12/3363418-file_1489287410599_b640.png" alt=""></p>
<p>这里的python用到的几个service协议应该是android提供的smartsocket本身就支持的，在与adb的端口号连接后就能使用socket来发送service的名字给android设备了。<br>详见<a href="https://developer.chrome.com/devtools/docs/remote-debugging-legacy" target="_blank" rel="external">这里</a>.<br>如下的命令就可以直接跟stetho-server连接。<br><img src="http://7viip0.com1.z0.glb.clouddn.com/17-3-12/10703667-file_1489287758769_63f.png" alt=""></p>
<h3 id="stetho-server流程分析"><a href="#stetho-server流程分析" class="headerlink" title="stetho-server流程分析"></a>stetho-server流程分析</h3><p>详见代码<a href="https://github.com/facebook/stetho/blob/36aa5bd356d9cf5893b9424b06a83dda9ec5e44f/stetho/src/main/java/com/facebook/stetho/server/LocalSocketServer.java" target="_blank" rel="external">LocalSocketServer.java</a><br><img src="http://7viip0.com1.z0.glb.clouddn.com/17-3-12/85652381-file_1489291638319_11cf3.png" alt=""><br>这里创建ServerSocket时的address格式是<code>stetho_+进程名+_ devtools_remote</code></p>
<hr>
<h2 id="Unix域套接字"><a href="#Unix域套接字" class="headerlink" title="Unix域套接字"></a>Unix域套接字</h2><p>socket API原本是为网络通讯设计的，但后来在socket的框架上发展出一种IPC机制，就是UNIX Domain Socket（Unix域协议）。虽然网络socket也可用于同一台主机的进程间通讯（通过loopback地址127.0.0.1），但是UNIX Domain Socket用于IPC更有效率：不需要经过网络协议栈，不需要打包拆包、计算校验和、维护序号和应答等，只是将应用层数据从一个进程拷贝到另一个进程。这是因为，IPC机制本质上是可靠的通讯，而网络协议是为不可靠的通讯设计的。UNIX Domain Socket也提供面向流和面向数据包两种API接口，类似于TCP和UDP，但是面向消息的UNIX Domain Socket也是可靠的，消息既不会丢失也不会顺序错乱。</p>
<p>Unix域协议所用的API就是在不同主机上执行客户/服务通信所用的套接字API。</p>
<h3 id="Android中的Unix域套接字"><a href="#Android中的Unix域套接字" class="headerlink" title="Android中的Unix域套接字"></a>Android中的Unix域套接字</h3><p>在Android API中，有几个类对Unix域套接字（也叫localsocket）进行了封装，不仅可以用来应用程序之间进行IPC通信，还可以跨应用程序层和Linux层运行的程序进行通信。<br><code>LocalSocket</code>在Unix域名空间创建一个套接字（非服务端）。<br><code>LocalSocketImpl</code>是Framework层Socket的实现，通过JNI调用系统socket API。<br><code>LocalServerSocket</code>创建服务器端Unix域套接字，与LocalSocket对应。<br><img src="http://7viip0.com1.z0.glb.clouddn.com/17-3-12/89412003-file_1489294912573_1445f.png" alt=""></p>
<p>创建socket时指定的domain类型是AF_UNIX。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Creates a socket in the underlying OS.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">create</span> <span class="params">(<span class="keyword">int</span> sockType)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    <span class="comment">//...</span></div><div class="line">    fd = Os.socket(OsConstants.AF_UNIX, osType, <span class="number">0</span>);    </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>通过搜索发现LocalSocketImpl的native实现是在libandroid_runtime.so中。<br><img src="http://7viip0.com1.z0.glb.clouddn.com/17-3-12/62841029-file_1489288277901_16a7e.png" alt=""><br>比如listen的native实现就是调用了socket的listen函数。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* private native void listen_native(int fd, int backlog) throws IOException; */</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></div><div class="line"><span class="title">socket_listen</span> <span class="params">(JNIEnv *env, jobject object, jobject fileDescriptor, jint backlog)</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> ret,fd;</div><div class="line">    fd = jniGetFDFromFileDescriptor(env, fileDescriptor);</div><div class="line">    ret = listen(fd, backlog);</div><div class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</div><div class="line">        jniThrowIOException(env, errno);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.jianshu.com/p/f82b733bd6ac" target="_blank" rel="external">ADB原理，Wi-Fi连接，常用命令及拓展</a><br>《UNIX网络编程卷1》<br><a href="http://blog.csdn.net/shuzui1985/article/details/50178929" target="_blank" rel="external">Android LocalSocket与Socket 区别</a><br><a href="https://www.figotan.org/2016/04/18/using-stetho-to-diagnose-data-on-android/" target="_blank" rel="external">如何给安卓APP安装听诊器,检查数据问题</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Stetho简介&quot;&gt;&lt;a href=&quot;#Stetho简介&quot; class=&quot;headerlink&quot; title=&quot;Stetho简介&quot;&gt;&lt;/a&gt;Stetho简介&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://facebook.github.io/stetho/&quot; ta
    
    </summary>
    
    
      <category term="android" scheme="http://felixzhang00.github.io/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>理解mmap</title>
    <link href="http://felixzhang00.github.io/2017/02/25/%E7%90%86%E8%A7%A3mmap/"/>
    <id>http://felixzhang00.github.io/2017/02/25/理解mmap/</id>
    <published>2017-02-25T11:35:26.000Z</published>
    <updated>2017-02-25T12:06:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>在接入日志组件xlog的工作中，对mmap内存映射加深了了解，分享一下学习心得。</p>
<h2 id="1-一个Linux进程的虚拟内存"><a href="#1-一个Linux进程的虚拟内存" class="headerlink" title="1.一个Linux进程的虚拟内存"></a>1.一个Linux进程的虚拟内存</h2><p><img src="http://7viip0.com1.z0.glb.clouddn.com/17-2-25/50851685-file_1488011866599_1378c.jpg" alt=""><br>如图展示了一个Linux进程的虚拟内存。<br>虚拟的意思是进程以为自己有这么一大块内存，实际上物理内存可能还没有分配给它，等到缺页异常是系统才会分配，通过这种以时间换空间的方式提高了内存利用效率。从虚拟内存到物理内存的映射过程需要一个专门的硬件单元MMU来完成。<br>系统调用的代码和数据就在内核虚拟内存中，<br>因为在保护模式下，用户态进程无法访问到这里，必须要通过系统调用的方式陷入到内核态才行。</p>
<h2 id="2-Linux是如何组织虚拟内存的"><a href="#2-Linux是如何组织虚拟内存的" class="headerlink" title="2.Linux是如何组织虚拟内存的"></a>2.Linux是如何组织虚拟内存的</h2><p><img src="http://7viip0.com1.z0.glb.clouddn.com/17-2-25/44198324-file_1488012277201_ee2a.png" alt=""><br>内核为系统中的每个进程维护一个单独的任务结构<code>task_struct</code>，其中元素包含了内核运行该进程所需要的所有信息（PID、指向用户栈的指针、可执行目标文件的名字、虚拟内存状态、pc指针等）<br><code>task_struct</code>中的<code>mm_struct</code>描述了虚拟内存的当前状态，其中mmap字段指向一个<code>vm_area_struct</code>（区域结构）的链表。顺序搜索区域结构的链表花销会很大，实际上Linux在链表中构建了一个树，并在这棵树中进行查找。<br>进程对某一虚拟内存区域的任何操作需要用要的信息，都可以从<code>vm_area_struct</code>中获得。mmap函数就是要创建一个新的<code>vm_area_struct</code>结构，并将其与文件的物理磁盘地址相连。</p>
<h2 id="3-缺页处理"><a href="#3-缺页处理" class="headerlink" title="3.缺页处理"></a>3.缺页处理</h2><p><img src="http://7viip0.com1.z0.glb.clouddn.com/17-2-25/30649400-file_1488012949934_13c4.jpg" alt=""><br>当MMU在试图翻译某个虚拟地址A时，触发了一个缺页。缺页异常处理程序会做如下检查：</p>
<ul>
<li>1）虚拟地址A是否合法？即是否在链表<code>mm_struct</code>所描述的区域内。</li>
<li>2）试图进行的内存访问是否合法？即检查指令的权限是否与vm_prot字段所描述的页读写许可权限相匹配。</li>
<li>3）正常缺页。系统会负责把该虚拟内存区域对应的文件加载到内存中。</li>
</ul>
<h2 id="4-内存映射"><a href="#4-内存映射" class="headerlink" title="4.内存映射"></a>4.内存映射</h2><p>Linux通过将一个虚拟内存区域与一个磁盘上的对象关联起来，以初始化这个虚拟内存区域的内容，这个过程称为内存映射。<br>Linux进程可以使用mmap函数来创建新的虚拟内存区域，并将对象映射到这些区域中。<br>mmap函数定义在libc中：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> *</span></div><div class="line">    <span class="title">mmap</span><span class="params">(<span class="keyword">void</span> *start, <span class="keyword">size_t</span> length, <span class="keyword">int</span> prot, <span class="keyword">int</span> flags, <span class="keyword">int</span> fd, <span class="keyword">off_t</span> offset)</span>;</div></pre></td></tr></table></figure></p>
<p>具体内容可以通过命令<code>man 2 mmap</code>查看。<br>mmap参数的可视化解释：<br><img src="http://7viip0.com1.z0.glb.clouddn.com/17-2-25/21318677-file_1488018309700_943f.png" alt=""></p>
<h3 id="mmap原理"><a href="#mmap原理" class="headerlink" title="mmap原理"></a>mmap原理</h3><p>在调用mmap实现这样的映射关系后，它只是在进程的虚拟空间中分配了一段空间，真实的物理地址还不会分配的，当进程第一次访问这段空间（当作内存一样），CPU陷入OS内核执行异常处理，然后异常处理会在这个时间分配物理内存，并用文件的内容填充这片内存，然后才返回进程的上下文，这时进程才会感知到这片内存里有数据。<br>之后进程即可对这片主存进行读或者写的操作，如果写操作改变了其内容，一定时间后系统会自动回写脏页面到对应磁盘地址，也即完成了写入到文件的过程。</p>
<p>mmap 的回写时机：</p>
<ul>
<li>内存不足</li>
<li>进程退出</li>
<li>调用 msync 或者 munmap</li>
<li>不设置 MAP_NOSYNC 情况下 30s-60s(仅限FreeBSD)</li>
</ul>
<h3 id="程序的加载"><a href="#程序的加载" class="headerlink" title="程序的加载"></a>程序的加载</h3><p>Linux执行一个ELF格式的程序，这个程序在磁盘上，为了执行这个程序，需要把程序加载到内存中，这时采用的就是mmap，mmap让虚拟空间和文件的内容组成的空间（文件空间）对应。因为ELF格式是区分代码、数据段的，这里的就不是简单的整个文件的映射了，需要将文件的分段区域映射到内存的不同位置。OS加载ELF文件的过程非常复杂这里就不展开了，具体内容可以看《程序员的自我修养》。<br>当CPU真的在这个地址上发起读写执行等操作时，因为文件的内容在磁盘上是不能被CPU访问的，所以OS会进入异常，系统的缺页处理程序会调用文件系统把一页或者多页的文件内容加载到物理内存中。</p>
<p>可以通过 <code>cat /proc/&lt;pid&gt;/maps</code>看到某个进程的mmap状态，其实就是通过遍历<code>vm_area_struct</code>链表得到的，有关maps的解释可以看<a href="http://askubuntu.com/questions/93509/how-to-interpret-proc-pid-maps-for-pidgin-application" target="_blank" rel="external">这里</a>。<br>下面是使用xlog的Android程序进程的内存状态（截取一小部分）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">shell@shamu:<span class="comment"># cat /proc/9032/maps</span></div><div class="line">address           perms offset  dev   inode   pathname</div><div class="line">//...</div><div class="line"><span class="number">0804</span>d000<span class="number">-0806e000</span> rwxp <span class="number">0804</span>d000 <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span>          [heap]</div><div class="line">b7e88000-b7e89000 rwxp b7e88000 <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span> </div><div class="line">x-x r--p <span class="number">00000000</span> fe:<span class="number">00</span> <span class="number">791721</span>     /data/dalvik-cache/arm/data@app@com.x<span class="number">-1</span>@base.apk@classes.dex</div><div class="line">x-x r-xp <span class="number">00</span>a6f000 fe:<span class="number">00</span> <span class="number">791721</span>     /data/dalvik-cache/arm/data@app@com.x<span class="number">-1</span>@base.apk@classes.dex</div><div class="line">x-x rw-p <span class="number">0155</span>d000 fe:<span class="number">00</span> <span class="number">791721</span>     /data/dalvik-cache/arm/data@app@com.x<span class="number">-1</span>@base.apk@classes.dex</div><div class="line">x-x r--p <span class="number">00000000</span> <span class="number">103</span>:<span class="number">09</span> <span class="number">630</span>       /system/fonts/CarroisGothicSC-Regular.ttf</div><div class="line">b35b7000-b35dd000 rw-s <span class="number">00000000</span> <span class="number">00</span>:<span class="number">14</span> <span class="number">3082</span>       /storage/emulated/<span class="number">0</span>/log.mmap2</div><div class="line">b6fb6000-b6fc3000 r-xp <span class="number">00000000</span> <span class="number">103</span>:<span class="number">09</span> <span class="number">206</span>       /system/bin/linker</div><div class="line">b6fc3000-b6fc4000 r-xp <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span>          [sigpage]</div><div class="line">b6fc4000-b6fc5000 r--p <span class="number">0000</span>d000 <span class="number">103</span>:<span class="number">09</span> <span class="number">206</span>       /system/bin/linker</div><div class="line">b6fc5000-b6fc6000 rw-p <span class="number">0000e000</span> <span class="number">103</span>:<span class="number">09</span> <span class="number">206</span>       /system/bin/linker</div><div class="line">b6fc6000-b6fc7000 rw-p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span> </div><div class="line">b6fc7000-b6fca000 r-xp <span class="number">00000000</span> <span class="number">103</span>:<span class="number">09</span> <span class="number">136</span>       /system/bin/app_process32</div><div class="line">b6fca000-b6fcb000 r--p <span class="number">00002000</span> <span class="number">103</span>:<span class="number">09</span> <span class="number">136</span>       /system/bin/app_process32</div><div class="line">be246000-bea45000 rw-p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span>          [stack]</div><div class="line">ffff0000-ffff1000 r-xp <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span>          [vectors]</div></pre></td></tr></table></figure>
<p>这些分段空间后面的那些，就是每个虚拟空间分段对应的文件。这些文件，称为这片虚拟空间的backlog文件，它的作用是当这些内存需要被使用的时候，从磁盘中把对应的文件内容加载到物理内存中。<br>这里同一个文件<code>/system/bin/linker</code>在虚拟内存中有不同的内存映射区域，就是因为其文件中有不同的分段，从<code>offset</code>可以看出来。<br><code>/storage/emulated/0/log.mmap2</code>就是xlog用作mmap的backlog文件了，它被映射到<code>b35b7000-b35dd000</code>这段内存区域。</p>
<h2 id="5-为什么mmap-可以节约IO读写时间"><a href="#5-为什么mmap-可以节约IO读写时间" class="headerlink" title="5.为什么mmap()可以节约IO读写时间"></a>5.为什么mmap()可以节约IO读写时间</h2><p>常规文件操作为了提高读写效率和保护磁盘，使用了页缓存机制，这是由OS控制的。这样造成读文件时需要先将文件页从磁盘拷贝到页缓存中，由于页缓存处在内核空间，不能被用户进程直接寻址，所以还需要将页缓存中数据页再次拷贝到内存对应的用户空间中。这样，通过了两次数据拷贝过程，才能完成进程对文件内容的获取任务。写操作也是一样，待写入的buffer在内核空间不能直接访问，必须要先拷贝至内核空间对应的主存，再写回磁盘中（延迟写回），也是需要两次数据拷贝。</p>
<p>而使用mmap操作文件中，由于不需要经过内核空间的数据缓存，只使用一次数据拷贝，就从磁盘中将数据传入内存的用户空间中，供进程使用。<br>mmap的关键点是实现了用户空间和内核空间的数据直接交互而省去了空间不同数据不通的繁琐过程。因此mmap效率更高。</p>
<h3 id="xlog对mmap的效率做了验证"><a href="#xlog对mmap的效率做了验证" class="headerlink" title="xlog对mmap的效率做了验证"></a>xlog对mmap的效率做了验证</h3><p>为了验证 mmap 是否真的有直接写内存的效率，通过一个简单的测试用例进行验证：把512 Byte的数据分别写入150 kb大小的内存和 mmap，以及磁盘文件100w次并统计耗时<br><img src="http://7viip0.com1.z0.glb.clouddn.com/17-2-25/57475458-file_1488014455835_4ad2.jpg" alt=""><br>从上图看出mmap几乎和直接写内存一样的性能，而且 mmap 既不会丢日志，回写时机又基本可控。 </p>
<hr>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li>《深入理解计算机操作系统》</li>
<li>《程序员的自我修养》</li>
<li><a href="http://www.cnblogs.com/huxiao-tee/p/4660352.html" target="_blank" rel="external">认真分析mmap：是什么 为什么 怎么用 </a></li>
<li><a href="http://dev.qq.com/topic/581c2c46bef1702a2db3ae53" target="_blank" rel="external">微信mars 的高性能日志模块 xlog</a></li>
<li><a href="https://www.zhihu.com/question/48161206/answer/110418693" target="_blank" rel="external">Linux 中 mmap() 函数的内存映射问题理解</a></li>
<li><a href="https://linux.die.net/man/5/proc" target="_blank" rel="external">proc(5) - Linux man page</a></li>
<li><a href="http://askubuntu.com/questions/93509/how-to-interpret-proc-pid-maps-for-pidgin-application" target="_blank" rel="external">How to interpret /proc/pid/maps</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在接入日志组件xlog的工作中，对mmap内存映射加深了了解，分享一下学习心得。&lt;/p&gt;
&lt;h2 id=&quot;1-一个Linux进程的虚拟内存&quot;&gt;&lt;a href=&quot;#1-一个Linux进程的虚拟内存&quot; class=&quot;headerlink&quot; title=&quot;1.一个Linux进程的
    
    </summary>
    
    
      <category term="Linux" scheme="http://felixzhang00.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>用Android Studio调试Framework层代码</title>
    <link href="http://felixzhang00.github.io/2017/01/23/%E7%94%A8Android%20Studio%E8%B0%83%E8%AF%95Framework%E5%B1%82%E4%BB%A3%E7%A0%81/"/>
    <id>http://felixzhang00.github.io/2017/01/23/用Android Studio调试Framework层代码/</id>
    <published>2017-01-23T01:20:06.000Z</published>
    <updated>2017-01-23T01:29:41.000Z</updated>
    
    <content type="html"><![CDATA[<p>Android程序员不得不知的调试技巧。<br>本文以webview loadUrl和域名解析为例,介绍配合使用LLDB和Android Studio调试Framework代码的技巧。</p>
<h2 id="java-层调试"><a href="#java-层调试" class="headerlink" title="java 层调试"></a>java 层调试</h2><p>首先需要把AOSP源码导入到Android Studio中，如果是macOS系统可以参考<a href="http://blog.csdn.net/u012455213/article/details/54647010" target="_blank" rel="external">这篇文章</a>。<br>导入后如下图所示：<br><img src="http://7viip0.com1.z0.glb.clouddn.com/17-1-23/37996598-file_1485133690721_e86b.png" alt=""></p>
<h3 id="调试原理"><a href="#调试原理" class="headerlink" title="调试原理"></a>调试原理</h3><p>Java平台的调试是有一个规范化的标准的，那就是JPDA（Java Platform Debugger Architecture）；通过 JPDA 提供的 API，开发人员可以方便灵活的搭建 Java 调试应用程序。 JPDA 主要由三个部分组成：Java 虚拟机工具接口（JVMTI），Java 调试线协议（JDWP），以及 Java 调试接口（JDI）。<br>调试需要堆栈、符号等信息都保存在JVM中，调试器（debugger）需要通过一种渠道获取这些信息，并通过这个渠道发送调试指令给JVM，JDWP就是调试器与JVM通信的渠道。在JVM内部有一个专门的jdwp线程，Android系统的adbd守护进程通过socket与各个虚拟机的jdwp线程进行通信，外部调试器通过主机的adb与adbd通信进而完成与jdwp的通信。具体过程如下图：<br><img src="http://7viip0.com1.z0.glb.clouddn.com/17-1-23/20297449-file_1485133715439_160b3.png" alt="调试架构图"></p>
<h3 id="配置Debug选项"><a href="#配置Debug选项" class="headerlink" title="配置Debug选项"></a>配置Debug选项</h3><p>在菜单栏上依次点击Run -&gt; Edit Configurations -&gt; Remote，打开并配置成如下的页面<br><img src="http://7viip0.com1.z0.glb.clouddn.com/17-1-23/32613201-file_1485133728789_eace.png" alt="aosp_java_debug"></p>
<h3 id="Exclued-不必要的文件夹"><a href="#Exclued-不必要的文件夹" class="headerlink" title="Exclued 不必要的文件夹"></a>Exclued 不必要的文件夹</h3><p>在断点调试时，JVM会告诉AS自己在xx.java的第xx行被断住了，AS就会定位到这个位置，但是如果有重复的文件的名的，往往会出现定位不准的情况，所以需要把不必要的文件夹排除在整个源码结构之外。打开Project Structure,做如下修改<br><img src="http://7viip0.com1.z0.glb.clouddn.com/17-1-23/98071738-file_1485133747899_256c.png" alt="Exclued"><br>如果遇上断点文件对不上的情况时，就手动在这里Exclued好了。<br>也可以直接修改<code>aosp-root/development/tools/idegen/excluded-paths</code>文件中的内容，添加exclude，再运行<code>idegen.sh</code> 重新生成IDE代码树。</p>
<h3 id="在源码处打断点"><a href="#在源码处打断点" class="headerlink" title="在源码处打断点"></a>在源码处打断点</h3><p>我们在WebView.java的loadUrl处打断点<br><img src="http://7viip0.com1.z0.glb.clouddn.com/17-1-23/38678927-file_1485133770804_2652.png" alt=""><br>点击调试按钮，你会看到Console中的提示<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Connected to the target VM, address: <span class="string">'localhost:8700'</span> , transport: <span class="string">'socket'</span></div></pre></td></tr></table></figure></p>
<h3 id="打开DDMS"><a href="#打开DDMS" class="headerlink" title="打开DDMS"></a>打开DDMS</h3><p>在菜单栏上依次点击Tools -&gt;Android -&gt; Android Device Monitor，打开DDMS后,点击<br><img src="http://7viip0.com1.z0.glb.clouddn.com/17-1-23/59482474-file_1485133844742_d58b.png" alt="ddms"></p>
<p>在monitor中我们可以看到有3列，分别是</p>
<ul>
<li>进程名(以包名显示)</li>
<li>PID(Process ID)</li>
<li>端口号(映射端口号/实际端口号)<br>点击我们要调试的browser程序的那一行，会出现一只绿色的bug，表示我们的Debugger已经跟设备上的程序联系上，可以调试了。</li>
</ul>
<h3 id="开始调试"><a href="#开始调试" class="headerlink" title="开始调试"></a>开始调试</h3><p>当在浏览器中加载一个网页时，就能触发之前设置的loadUrl的断点了，如此就可以使用各种调试手段了。<br><img src="http://7viip0.com1.z0.glb.clouddn.com/17-1-23/60962148-file_1485133869972_a8b8.png" alt="loadUrl堆栈"></p>
<hr>
<h2 id="C-层调试"><a href="#C-层调试" class="headerlink" title="C++层调试"></a>C++层调试</h2><p>Android Framework中native代码的调试方法采用的是 2.2以上版本的Android Studio配合LLDB调试器。<br>这里以调试webview的dns查找过程为例，说明native调试的方法。</p>
<h3 id="调试原理-1"><a href="#调试原理-1" class="headerlink" title="调试原理"></a>调试原理</h3><p>LLDB作为Android Native层的调试工具，其原理跟gdb一样，也是采用C/S架构，通过push一个lldb-server到设备上，pc机的debugger作为lldb-client与其通信，以达到调试的效果。<br>C++在编译时有一个选项<code>-g</code>表示编译出来的可执行文件是带有调试信息的，比如源文件、行号信息，都会存放在ELF文件中的<br><code>.debug_*</code>段之中， 知道了这些调试信息后，调试器配合IDE就可以定位代码了。<br>这里还需要保证你的符号文件和设备上真正运行的动态链接库或者可执行文件是对应的，就是同一份，不然调试信息就对不上了。<br>最简单的办法就是使用模拟器。我们编译完源码之后，一个主要的编译产物就是 system.img，这个 system.img会在启动之后挂载到设备的 /system 分区，而system分区包含了Android系统运行时的绝大部分可执行文件和动态链接库，而这些文件就是我们的编译输出，正好可以与编译得到的调试符号进行配合调试。模拟器有一个 -system选项用来指定模拟器使用的 system.img文件。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ emulator -avd Nexus5-API22 -verbose -no-boot-anim -system (the path of system.img)</div></pre></td></tr></table></figure></p>
<p>我这里的做法是使用烧录了自己编译源码的Nexus手机。</p>
<h3 id="配置Debugger"><a href="#配置Debugger" class="headerlink" title="配置Debugger"></a>配置Debugger</h3><p>这里需要新建一个Android Demo工程了，直接用AOSP源码那个工程，没有是Native Debug那个选项的。<br>按如下方式配置符号表，需要与设备上用的so是同一份。并且改Debug type 为Native。<br><img src="http://7viip0.com1.z0.glb.clouddn.com/17-1-23/98365902-file_1485133891159_d5e1.png" alt="配置Debugger"><br>符号表的添加也可以通过lldb命令行的方式添加<br><img src="http://7viip0.com1.z0.glb.clouddn.com/17-1-23/11135935-file_1485133911409_87f8.png" alt="lldb-pause"><br><img src="http://7viip0.com1.z0.glb.clouddn.com/17-1-23/81500034-file_1485133908937_c39f.png" alt="lldb-add-dsym"><br>LLDB需要这些符号信息才能帮你定位到调试断点的代码。</p>
<h3 id="配置源码到AS"><a href="#配置源码到AS" class="headerlink" title="配置源码到AS"></a>配置源码到AS</h3><p>当LLDB告诉AS源文件行号信息时，AS需要定位到对应的代码处，所以必须先把源文件导入到AS中，最简单的做法是建立软链接。在Android Demo工程下建立一个source文件夹，然后执行如下命令。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ ln <span class="_">-s</span> xx/external/chromium_org  xx/<span class="built_in">source</span>/chromium_org</div><div class="line">$ ln <span class="_">-s</span> xx/bionic/libc  xx/<span class="built_in">source</span>/libc</div></pre></td></tr></table></figure></p>
<p>这里只是把需要用到的源文件导入进来，当然也可以把整个AOSP源码导入AS中，但是这样会比较耗时。</p>
<h3 id="打断点"><a href="#打断点" class="headerlink" title="打断点"></a>打断点</h3><p>我在getaddrinfo.c的getaddrinfo方法处打一个断点，看看webview在加载网页时的域名解析会不会走到这里。<br><img src="http://7viip0.com1.z0.glb.clouddn.com/17-1-23/25829366-file_1485133943240_17e29.png" alt="getaddrinfo"><br>点击Debug按钮，当Demo程序开始LoadUrl之后，就会被Debug断住，如下是chromium域名解析线程的堆栈（这里的方法名真够长的。。。），这样我们就可以进一步了解webview加载网页时域名解析的过程了。<br><img src="http://7viip0.com1.z0.glb.clouddn.com/17-1-23/58831938-file_1485134083110_4efc.png" alt="getaddrinfo-stack"><br>让我们看看其他线程在干啥，整个世界都停止了。<br><img src="http://7viip0.com1.z0.glb.clouddn.com/17-1-23/98647443-file_1485134070646_62ea.png" alt="chromium-threads"><br><img src="http://7viip0.com1.z0.glb.clouddn.com/17-1-23/78278941-file_1485133978101_8702.png" alt="renderthread"><br><img src="http://7viip0.com1.z0.glb.clouddn.com/17-1-23/9092603-file_1485134218822_d5f1.png" alt="jdwp"></p>
<hr>
<h2 id="不足之处"><a href="#不足之处" class="headerlink" title="不足之处"></a>不足之处</h2><p>目前的调试framework方案只能把java层和c++ native层的分开来做，还不能做到java层和c++ native层互相跳转的效果。虽然目前我们开发Android App用AS调试时能做大这一点，要是framework的调试也能做到这一点就好了。获取真有这样的方法，如果有知道的大神，还请赐教。</p>
<hr>
<h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><p><a href="http://ronubo.blogspot.com/2016/01/debugging-aosp-platform-code-with.html" target="_blank" rel="external">Debugging AOSP Platform code with Android Studio - Part I - Java Debugger</a><br><a href="http://ronubo.blogspot.com/2016/01/android-debugging-old-school-bringup.html" target="_blank" rel="external">Android Debugging: Old School bringup routines - Command line Java debugging with JDWP</a><br><a href="http://weishu.me/2016/05/30/how-to-debug-android-framework/index.html" target="_blank" rel="external">如何调试Android Framework</a><br><a href="http://weishu.me/2017/01/14/how-to-debug-android-native-framework-source/index.html" target="_blank" rel="external">如何调试Android Native Framework</a><br><a href="http://blog.csdn.net/u012455213/article/details/54647010" target="_blank" rel="external">在macOS 10.12 上编译 Android 5.1</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Android程序员不得不知的调试技巧。&lt;br&gt;本文以webview loadUrl和域名解析为例,介绍配合使用LLDB和Android Studio调试Framework代码的技巧。&lt;/p&gt;
&lt;h2 id=&quot;java-层调试&quot;&gt;&lt;a href=&quot;#java-层调试&quot; cl
    
    </summary>
    
    
      <category term="Android DEBUG" scheme="http://felixzhang00.github.io/tags/Android-DEBUG/"/>
    
  </entry>
  
  <entry>
    <title>在macOS 10.12 上编译 Android 5.1</title>
    <link href="http://felixzhang00.github.io/2017/01/21/%E5%9C%A8macOS%2010.12%20%E4%B8%8A%E7%BC%96%E8%AF%91%20Android%205.1/"/>
    <id>http://felixzhang00.github.io/2017/01/21/在macOS 10.12 上编译 Android 5.1/</id>
    <published>2017-01-21T10:55:45.000Z</published>
    <updated>2017-01-21T11:03:56.000Z</updated>
    
    <content type="html"><![CDATA[<hr>
<p>官方文档虽然也有介绍，但是macOS平台上的编译环境问题还存在很多坑。本文介绍下如何在在macOS 10.12 上编译 Android 5.1源码，导入源码到Android Studio中，把系统烧录到Nexus6手机中。</p>
<hr>
<h2 id="搭建编译环境"><a href="#搭建编译环境" class="headerlink" title="搭建编译环境"></a>搭建编译环境</h2><h3 id="创建分区"><a href="#创建分区" class="headerlink" title="创建分区"></a>创建分区</h3><p>AOSP源码需要一个支持大小写敏感的文件系统，100G是至少要的。<a href="https://source.android.com/source/initializing.html#setting-up-a-mac-os-x-build-environment" target="_blank" rel="external">官网</a>有详细的介绍，这里简单列一下。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hdiutil create -type SPARSE -fs <span class="string">'Case-sensitive Journaled HFS+'</span> -size 40g ~/android.dmg</div></pre></td></tr></table></figure></p>
<p>然后挂载这个分区：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hdiutil attach ~/android.dmg -mountpoint /Volumes/android;</div></pre></td></tr></table></figure></p>
<h3 id="切换shell"><a href="#切换shell" class="headerlink" title="切换shell"></a>切换shell</h3><p>Android的相关编译只能是使用bash.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ chsh -s /bin/bash</div></pre></td></tr></table></figure></p>
<p>重启终端。</p>
<h3 id="安装Xcode"><a href="#安装Xcode" class="headerlink" title="安装Xcode"></a>安装Xcode</h3><p>1、这里需要两个Xcode，可以用命令切换需要使用的Xcode，会有不同的用处。</p>
<ul>
<li>去AppStore下载最新的Xcode</li>
<li>到<a href="https://developer.apple.com/download/more/" target="_blank" rel="external">这里</a>下载5.1.1的Xcode</li>
</ul>
<p>2、创建一个<code>/Developer/SDK</code>文件夹，从Xcode5.1.1中把<code>MacOSX10.8.sdk</code>从<code>Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/</code>复制到 <code>/Developer/SDK</code>中。<br>3、从<code>Xcode5.1.1.dmg</code>复制Xcode.app 到  <code>/Developer</code>目录中。<br>4、从AppStore下载的最新版Xcode会默认放在<code>/Applications</code>目录中<br>5、给两个版本的Xcode都安装command line tools<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ sudo xcode-select -switch /Developer/Xcode.app</div><div class="line">$ xcode-select --install</div><div class="line">$ sudo xcode-select -switch /Applications/Xcode.app</div><div class="line">$ xcode-select --install</div></pre></td></tr></table></figure></p>
<h3 id="安装JDK"><a href="#安装JDK" class="headerlink" title="安装JDK"></a>安装JDK</h3><p>编译Android5.1需要jdk1.7，去<a href="http://www.oracle.com/technetwork/java/javase/downloads/jre7-downloads-1880261.html" target="_blank" rel="external">官网</a>下载.<br>如果有切换多个版本的jdk需求的话，可以使用<code>jenv</code>这个工具，参考<a href="http://boxingp.github.io/blog/2015/01/25/manage-multiple-versions-of-java-on-os-x/" target="_blank" rel="external">在OS X中使用jEnv管理多个Java版本</a></p>
<h3 id="安装其他软件"><a href="#安装其他软件" class="headerlink" title="安装其他软件"></a>安装其他软件</h3><p>1、安装MacPorts，需要去<a href="https://www.macports.org/install.php" target="_blank" rel="external">官网</a>下载对应版本的MacPorts<br>2、配置port命令环境变量<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">export</span> PATH=/opt/<span class="built_in">local</span>/bin:<span class="variable">$PATH</span></div></pre></td></tr></table></figure></p>
<p>3、下载依赖包<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ POSIXLY_CORRECT=1 sudo port install gmake libsdl git gnupg</div></pre></td></tr></table></figure></p>
<hr>
<h2 id="下载源码"><a href="#下载源码" class="headerlink" title="下载源码"></a>下载源码</h2><p>直接去google官方下载会很慢，这里推荐用<a href="https://lug.ustc.edu.cn/wiki/mirrors/help/aosp" target="_blank" rel="external">中科大镜像</a><br>1、首先下载 repo 工具。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ mkdir ~/bin</div><div class="line">$ PATH=~/bin:<span class="variable">$PATH</span></div><div class="line">$ curl https://storage.googleapis.com/git-repo-downloads/repo &gt; ~/bin/repo</div><div class="line"><span class="comment">## 如果上述 URL 不可访问，可以用下面的：</span></div><div class="line"><span class="comment">## curl https://storage-googleapis.proxy.ustclug.org/git-repo-downloads/repo &gt; ~/bin/repo</span></div><div class="line">$ chmod a+x ~/bin/repo</div></pre></td></tr></table></figure></p>
<p>2、在之前创建的大小写分区上建立一个工作目录，之后源码下载和编译都在这里进行。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ mkdir WORKING_DIRECTORY</div><div class="line">$ <span class="built_in">cd</span> WORKING_DIRECTORY</div></pre></td></tr></table></figure></p>
<p>3、初始化仓库<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ repo init -u git://mirrors.ustc.edu.cn/aosp/platform/manifest</div><div class="line"><span class="comment">## 如果提示无法连接到 gerrit.googlesource.com，可以编辑 ~/bin/repo，把 REPO_URL 一行替换成下面的：</span></div><div class="line"><span class="comment">## REPO_URL = 'https://gerrit-googlesource.proxy.ustclug.org/git-repo'</span></div></pre></td></tr></table></figure></p>
<p>4、选择某个特定的 Android 版本，具体查看<a href="https://source.android.com/source/build-numbers.html#source-code-tags-and-builds" target="_blank" rel="external">这里</a>,我选择的是android-5.1.1_r14，build号是LMY48M，等会用这个build号下载对应的驱动包，烧录到nexus真机时会用到。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ repo init -u git://mirrors.ustc.edu.cn/aosp/platform/manifest -b android-5.1.1_r14</div></pre></td></tr></table></figure></p>
<p>5、同步源码树<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ repo sync</div></pre></td></tr></table></figure></p>
<p>源码下载完后，如果没有同步的需求的话，就可以把<code>.repo</code>目录删掉了，防止编译时磁盘空间不够用。</p>
<h2 id="下载驱动"><a href="#下载驱动" class="headerlink" title="下载驱动"></a>下载驱动</h2><p>烧录到真机时需要用到，默认只是用模拟器的话，可以跳过这步。<br>在<a href="https://developers.google.com/android/nexus/drivers#hikey中找到对应设备与源码分支的硬件驱动。刚才选择的源码分支所对应的build码是LMY48M，因此，就下载此代号的驱动程序即可。" target="_blank" rel="external">https://developers.google.com/android/nexus/drivers#hikey中找到对应设备与源码分支的硬件驱动。刚才选择的源码分支所对应的build码是LMY48M，因此，就下载此代号的驱动程序即可。</a><br>下载得到的是三个tgz文件，我们只需依次解压三个文件，得到的是三个shell脚本文件，我们先将其置于源码根目录中。<br>依次执行这3个脚本将在源码根目录中生成一个vendor文件夹。</p>
<hr>
<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><h3 id="设置文件描述符限制"><a href="#设置文件描述符限制" class="headerlink" title="设置文件描述符限制"></a>设置文件描述符限制</h3><p>在macOS中，默认限制的同时打开的文件数量很少，不能满足编译过程中的高并发需要，因此需要在shell中运行命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">ulimit</span> -S -n 1024</div></pre></td></tr></table></figure></p>
<h3 id="环境设置"><a href="#环境设置" class="headerlink" title="环境设置"></a>环境设置</h3><p>在源码根目录下调用下面的命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">source</span> build/envsetup.sh</div></pre></td></tr></table></figure></p>
<h3 id="选择设备"><a href="#选择设备" class="headerlink" title="选择设备"></a>选择设备</h3><p>因为我编译后需要烧录到Nexus6上，所以选择<code>aosp_shamu-userdebug</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ lunch aosp_shamu-userdebug</div></pre></td></tr></table></figure></p>
<p>如果不需要烧录到真机上的话，用默认的<code>aosp_arm-eng</code>类型就可以了。</p>
<h3 id="开始编译"><a href="#开始编译" class="headerlink" title="开始编译"></a>开始编译</h3><p>因为本机CPU的内核是8核的，所以开16个线程加快编译。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ make -j16</div></pre></td></tr></table></figure></p>
<p>编译成功后，会有类似下面的日志：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#### make completed successfully (30:28:08 (hh:mm:ss)) ####</span></div></pre></td></tr></table></figure></p>
<p>编译成功的结果都在<code>out</code>目录中。<br>如果lunch的是<code>aosp_arm-eng</code>类型，就可以用<code>$ emulator</code>命令刷到模拟器了。</p>
<hr>
<h2 id="源码导入到Android-Studio中"><a href="#源码导入到Android-Studio中" class="headerlink" title="源码导入到Android Studio中"></a>源码导入到Android Studio中</h2><p>为了方便查看源码，可以把代码导入到AS中。目前看来，只能支持Java的跳转，对c++的支持不太好。<br>为了让AS理解代码的符号和源码树的结构，需要用如下命令生成一个<code>android.ipr</code>工程配置文件。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ mmm development/tools/idegen/</div><div class="line">$ development/tools/idegen/idegen.sh</div></pre></td></tr></table></figure></p>
<p>大约需要十几秒的时间，就能在源码根目录下生成android.ipr和android.iml了。<br>用AS打开android.ipr就能导入整个源码了。<br>如果要支持跳转的话，还需要做些配置，可以看这篇教程：<a href="http://blog.justain.net/index.php/import-aosp-into-android-studio/" target="_blank" rel="external">Import AOSP into Android Studio</a></p>
<hr>
<h2 id="刷机"><a href="#刷机" class="headerlink" title="刷机"></a>刷机</h2><p>Nexus6手机在打开USB调试，连接电脑后允许调试这台手机，并且在设置中打开“允许 OEM 解锁”。然后令手机进入recovery模式，在关机下，输入如下命令即可：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ adb reboot bootloader</div></pre></td></tr></table></figure></p>
<p>执行如下命令刷机：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ fastboot -w flashall</div></pre></td></tr></table></figure></p>
<p>刷机成功后，手机会自动重启，新鲜出炉的系统终于跑起来了。<br>刷机过程中也出现过变砖的情况，可以试一下<a href="http://www.shuame.com/faq/restore-tutorial/14679-google-nexus6.html" target="_blank" rel="external">这个教程</a>，亲测有效。</p>
<hr>
<h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><p><a href="https://medium.com/@raminmahmoodi/build-android-5-0-lollipop-on-osx-10-10-yosemite-441bd00ee77a" target="_blank" rel="external">Build Android 5.0 Lollipop on OSX 10.10 Yosemite</a><br><a href="http://blog.bihe0832.com/macOS-AOSP.html" target="_blank" rel="external">http://blog.bihe0832.com/macOS-AOSP.html</a><br><a href="http://boxingp.github.io/blog/2015/01/25/manage-multiple-versions-of-java-on-os-x/" target="_blank" rel="external">在OS X中使用jEnv管理多个Java版本</a><br><a href="http://blog.justain.net/index.php/import-aosp-into-android-studio/" target="_blank" rel="external">Import AOSP into Android Studio</a><br><a href="http://www.shuame.com/faq/restore-tutorial/14679-google-nexus6.html" target="_blank" rel="external">Nexus 6 恢复官方兼救砖</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;官方文档虽然也有介绍，但是macOS平台上的编译环境问题还存在很多坑。本文介绍下如何在在macOS 10.12 上编译 Android 5.1源码，导入源码到Android Studio中，把系统烧录到Nexus6手机中。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;搭建编
    
    </summary>
    
    
      <category term="Android" scheme="http://felixzhang00.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Docker简单使用</title>
    <link href="http://felixzhang00.github.io/2017/01/21/Docker%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
    <id>http://felixzhang00.github.io/2017/01/21/Docker简单使用/</id>
    <published>2017-01-21T07:06:30.000Z</published>
    <updated>2017-01-21T07:07:09.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/24633328" target="_blank" rel="external">史上最简单Android源码编译环境搭建方法</a>这篇分享介绍了借助Docker来编译Android源码，Docker可以直接把编译工具链和Ubuntu系统整体打包，保证了编译环境和官方的一致。<br>我用的macOS，之前尝试过编译AOSP，出现各种问题，采用虚拟机的方式也常常编译不过，看到可以用docker的新方式，打算尝试用一下。但是从我实际操作来看，docker在mac上是很慢的，并不比虚拟机快多少，在编译AOSP时也会造成卡死，因为在mac平台上docker是要运行在一个虚拟机上的。在尝试docker编译AOSP失败后，我最终还是用macOS编译了，最终成功烧录到nexus手机上。<br>虽然docker不适合我编译AOSP，但是作为一个操作系统级虚拟化实现方案，还是非常优秀滴。写一个编译器做成一个镜像，放在docker容器里运行还是绰绰有余的，比如《自制编译器》里的<code>cbc编译器</code>, 有人就做了一个镜像上传到<a href="https://hub.docker.com/r/leungwensen/cbc-ubuntu-64bit/" target="_blank" rel="external">DockerHub</a>上了，这样就避免了需要配置一堆环境依赖的麻烦了。<br>也算是对Docker研究了半天，简单记录下docker的用法吧。</p>
<hr>
<h2 id="Docker简介"><a href="#Docker简介" class="headerlink" title="Docker简介"></a>Docker简介</h2><h3 id="为什么说Docker比虚拟机快呢？"><a href="#为什么说Docker比虚拟机快呢？" class="headerlink" title="为什么说Docker比虚拟机快呢？"></a>为什么说Docker比虚拟机快呢？</h3><p>因为Docker容器需要的开销有限。和传统的虚拟化相比，容器运行不需要模拟层和管理层，而是使用操作系统的系统调用接口。这降低了运行单个容器所需的开销，也使得宿主机中可以运行更多容器。<br>但这个是对Host机为Linux而言的，macOS上运行docker容器本质上还是跑在linux虚拟机上的。</p>
<h3 id="什么是docker"><a href="#什么是docker" class="headerlink" title="什么是docker"></a>什么是docker</h3><p>镜像是Docker生命周期中的构建或打包阶段，而容器则是启动或执行阶段。<br>简单来说，Docker就是：</p>
<ul>
<li>一个镜像格式</li>
<li>一系列标准的操作</li>
<li>一个执行环境</li>
</ul>
<p>镜像是基于联合文件系统的一种层式的结构，由一系列指令一步一步构建出来，例如：添加一个文件；执行一个名人；打开一个端口。<br>当从一个镜像启动容器时，Docker会在该镜像的最底层加载一个读写文件系统，我们想在Docker中运行的程序就是在这个读写层中执行的。<br>下图是Docker的文件系统层。<br><img src="http://p1.bqimg.com/567571/d31fea71fb692f4d.png" alt="Docker文件系统层"></p>
<p>构建镜像最方便的做法是写一个Dockerfile文件，让docker自带的工具读它，然后生出一个镜像文件来。<br>Dockerfile使用基本的基于DSL语法的指令来构建一个Docker镜像，之后使用docker build命令基于该Dockerfile中的指令构建一个新的镜像。<br>每条指令都会创建一个新的镜像层并对镜像进行提交。Docker大体上按照如下的流程执行Dockerfile中的指令。</p>
<ul>
<li>Docker从基础镜像运行一个容器。</li>
<li>执行一条指令，对容器做出修改。</li>
<li>执行类似docker commit的操作，提交一个新的镜像层。</li>
<li>Docker再基于刚提交的镜像运行一个新容器。</li>
<li>执行Dockerfile中的下一条指令，直到所有指令都执行完毕。</li>
</ul>
<p>这里给两个简单的例子，可以自己研究下：</p>
<ul>
<li><a href="https://hub.docker.com/r/leungwensen/cbc-ubuntu-64bit/" target="_blank" rel="external">cbc-ubuntu-64bit</a></li>
<li><a href="https://hub.docker.com/r/kylemanna/aosp/" target="_blank" rel="external">aosp</a></li>
</ul>
<hr>
<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p>去<a href="https://www.docker.com/" target="_blank" rel="external">Docker官网</a>下载对应操作系统的安装包后，就可以使用了。<br>打开 Kitematic, 可以在这里下载镜像，dockerhub的形式跟github很像，可以commit、pull等。<br><img src="http://p1.bqimg.com/567571/9d49704a11c5ecad.jpg" alt=""></p>
<p>Docker是基于C/S架构的，它有一个docker程序，既能作为客户端，也可以作为服务端。作为客户端时，docker程序向Docker守护进程发送请求（如请求返回守护进程自身的信息），然后再对返回的请求结果进行处理。</p>
<h3 id="通过docker-info-可以得到的一些信息"><a href="#通过docker-info-可以得到的一些信息" class="headerlink" title="通过docker info 可以得到的一些信息"></a>通过docker info 可以得到的一些信息</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">$ docker info      </div><div class="line">Containers: 10</div><div class="line"> Running: 1</div><div class="line"> Paused: 0</div><div class="line"> Stopped: 9</div><div class="line">Images: 7</div><div class="line">Server Version: 1.12.6</div><div class="line">//...</div><div class="line">Registry: https://index.docker.io/v1/</div><div class="line">WARNING: No kernel memory <span class="built_in">limit</span> support</div><div class="line">Insecure Registries:</div><div class="line"> 127.0.0.0/8</div></pre></td></tr></table></figure>
<h3 id="创建交互式容器"><a href="#创建交互式容器" class="headerlink" title="创建交互式容器"></a>创建交互式容器</h3><p>我们告诉Docker执行<code>docker run</code>命令，我们告诉Docker基于<code>ubuntu</code>镜像来创建容器，如果本地没有该镜像的话，Docker会连接官方维护的Docker Hub Registry查找该镜像，下载并保存到本地宿主机中。 <code>-i</code>保证容器中STDIN是开启的，<code>-t</code>告诉Docker为要创建的容器分配一个伪tty终端。这样，新创建的容器才能提供一个交互式shell。最后的<code>/bin/bash</code>告诉Docker在新容器中要运行什么命令。其中<code>--name</code>参数告诉Docker创建一个名为<code>test_container</code>的容器。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ sudo docker --name test_container run -i -t ubuntu /bin/bash</div><div class="line">//...</div><div class="line">root@12345:/<span class="comment">#</span></div></pre></td></tr></table></figure></p>
<p>这样，我们就能看到容器内的shell了。容器的id是12345。容器的主机名就是该容器的ID。具体可以通过<code>cat /etc/hosts</code>查看。<br>输入<code>exit</code>,就可以返回宿主机的命令行了。一旦退出容器，<code>/bin/bash</code>命令也就结束了，容器也随之停止运行。但容器是仍然存在的。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">root@12345:/<span class="comment"># exit</span></div></pre></td></tr></table></figure></p>
<p>用<code>docker ps -a</code>命令查看当前系统中容器的列表</p>
<p>Docker容器重新启动的时候，会沿用docker run命令时指定的参数来运行。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo docker restart (container name or id)</div></pre></td></tr></table></figure></p>
<hr>
<h3 id="创建守护式容器"><a href="#创建守护式容器" class="headerlink" title="创建守护式容器"></a>创建守护式容器</h3><p><code>-d</code>参数告诉Docker把容器放到后台运行。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo docker run --name daemon_dave <span class="_">-d</span> ubuntu /bin/sh -c <span class="string">"while true; do echo hello world; sleep 1; done"</span></div></pre></td></tr></table></figure></p>
<h3 id="容器内部都在干些什么"><a href="#容器内部都在干些什么" class="headerlink" title="容器内部都在干些什么"></a>容器内部都在干些什么</h3><p>用<code>docker logs</code>命令来获取容器的日志。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo docker logs (container name or id)</div></pre></td></tr></table></figure></p>
<h3 id="查看容器内的进程"><a href="#查看容器内的进程" class="headerlink" title="查看容器内的进程"></a>查看容器内的进程</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo docker top (container name or id)</div></pre></td></tr></table></figure>
<h3 id="在容器内部运行进程"><a href="#在容器内部运行进程" class="headerlink" title="在容器内部运行进程"></a>在容器内部运行进程</h3><p>通过<code>docker exec</code>命令在容器内部额外启动新进程，<br>如下启动了新的后台任务和交互式任务。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo docker <span class="built_in">exec</span> <span class="_">-d</span> (container name or id) touch /etc/new_config_file</div></pre></td></tr></table></figure></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo docker <span class="built_in">exec</span> -t -i (container name or id) /bin/bash</div></pre></td></tr></table></figure>
<h3 id="停止守护式容器"><a href="#停止守护式容器" class="headerlink" title="停止守护式容器"></a>停止守护式容器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo docker stop (container name or id)</div></pre></td></tr></table></figure>
<h3 id="自动重启容器"><a href="#自动重启容器" class="headerlink" title="自动重启容器"></a>自动重启容器</h3><p><code>--restart</code>标志会检查容器的退出代码，并据此来决定是否重启容器。<br>比如<code>--restart=onfailure:5</code>表示Docker会尝试自动重启该容器，最多重启5次。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo docker run --restart=always --name daemon_dave <span class="_">-d</span> ubuntu /bin/sh -c <span class="string">"while true; do echo hello world; sleep 1; done"</span></div></pre></td></tr></table></figure></p>
<h3 id="深入容器"><a href="#深入容器" class="headerlink" title="深入容器"></a>深入容器</h3><p><code>docker inspect</code>命令会对容器进行详细的检查，然后返回其配置信息，包括名称、命令、网络配置等。这是一大串json数据，可以用<code>--format</code>标志来选定查看结果。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ sudo docker inspect --format=<span class="string">'&#123;&#123;.Args&#125;&#125;'</span> (container name or id)</div><div class="line">[run.sh docker]</div></pre></td></tr></table></figure></p>
<h3 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo docker rm (container name or id)</div></pre></td></tr></table></figure>
<p>一次删除所有容器<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo docker rm `docker ps <span class="_">-a</span> -q`</div></pre></td></tr></table></figure></p>
<h3 id="列出镜像"><a href="#列出镜像" class="headerlink" title="列出镜像"></a>列出镜像</h3><p>用<code>docker images</code>得到本地的镜像列表。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ sudo docker images</div><div class="line">REPOSITORY  TAG     IMAGE ID       CREATED    	SIZE</div><div class="line">ubuntu      latest  104bec311bcd   4 weeks ago  129 MB</div><div class="line">ubuntu      14.04   xxx   		   x weeks ago  xxx MB</div></pre></td></tr></table></figure></p>
<p>镜像保存在仓库中，而仓库在于Registry中，默认的Registry是Docker Hub。<br>每个镜像仓库都可以存放很多镜像（比如ubuntu仓库包含了ubuntu各个版本的镜像）。<br>执行<code>sudo docker pull ubuntu</code>命令来拉取ubuntu仓库中所有内容。<br>每个镜像在列出来时都带有一个标签，用于对组成特定镜像的一些镜像层镜像标记。<br>用如下的方式来指定该仓库的某一镜像<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo docker run -ti ubuntu:12.04 /bin/bash</div></pre></td></tr></table></figure></p>
<p>Docker Hub中有两种类型的仓库：用户仓库和顶层仓库。<br><code>用户名/仓库名</code>这种形式表示用户仓库，是由Docker用户创建的；<br>顶层仓库只包含仓库名部分，由Docker内部人来管理的。</p>
<hr>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>因为我只是想用docker来配一个编译aosp的环境，对于Docker的很多高级功能还没有接触，比如利用连接和卷之类的Docker特性来组合并管理运行与Docker中的应用、创建多容器的应用栈等。</p>
<hr>
<p> 相关链接<br><a href="https://zhuanlan.zhihu.com/p/24633328" target="_blank" rel="external">史上最简单Android源码编译环境搭建方法</a><br><a href="https://hub.docker.com/r/leungwensen/cbc-ubuntu-64bit/" target="_blank" rel="external">cbc-ubuntu-64bit</a><br><a href="http://numbbbbb.com/2016/09/26/20160926_%E7%94%A8%20Docker%20%E5%BF%AB%E9%80%9F%E9%85%8D%E7%BD%AE%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/" target="_blank" rel="external">用 Docker 快速配置前端开发环境</a><br><a href="https://book.douban.com/subject/26285268/" target="_blank" rel="external">《第一本Docker书》</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/24633328&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;史上最简单Android源码编译环境搭建方法&lt;/a&gt;这篇分享介绍了借助Docker来编译Android源码，Dock
    
    </summary>
    
    
      <category term="工具 docker" scheme="http://felixzhang00.github.io/tags/%E5%B7%A5%E5%85%B7-docker/"/>
    
  </entry>
  
  <entry>
    <title>xlog接入方案</title>
    <link href="http://felixzhang00.github.io/2017/01/12/xlog%E6%8E%A5%E5%85%A5%E6%96%B9%E6%A1%88/"/>
    <id>http://felixzhang00.github.io/2017/01/12/xlog接入方案/</id>
    <published>2017-01-12T15:15:34.000Z</published>
    <updated>2017-01-12T15:16:32.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/Tencent/mars" target="_blank" rel="external">mars</a> 是微信最近开源的终端基础组件，是一个使用 C++ 编写的基础组件。<br>xlog是其中一个可单独使用的高性能日志模块。<br>本文将简单介绍下xlog的特点，并给出一个自定义的输出到文件的策略。</p>
<hr>
<h2 id="xlog的特点"><a href="#xlog的特点" class="headerlink" title="xlog的特点"></a>xlog的特点</h2><p>使用流式压缩方式对单行日志进行压缩，压缩加密后写进作为 log 中间 buffer的 mmap 中，当 mmap 中的数据到达一定大小后再写进磁盘文件中。<br><img src="http://ww4.sinaimg.cn/large/8b331ee1gw1fbmxsvozhbj20jg08iglr.jpg" alt=""><br><img src="http://ww3.sinaimg.cn/large/8b331ee1gw1fbmxtm3kajj20kp04caa7.jpg" alt=""></p>
<p>输出到文件的主要实现是在 Appender 模块也是可插拔的，如果对默认的策略不满意可以自己实现一套。<br><img src="http://ww3.sinaimg.cn/large/8b331ee1gw1fblriu5wrqj20ci0630sv.jpg" alt=""></p>
<p>xlog还存在一些其他策略：</p>
<ul>
<li>每次启动的时候会清理日志，防止占用太多用户磁盘空间</li>
<li>为了防止 sdcard 被拔掉导致写不了日志，支持设置缓存目录，当 sdcard 插上时会把缓存目录里的日志写入到 sdcard 上</li>
</ul>
<p>从下面的log2file流程图中可以看出xlog是如何利用cahce目录解决插拔sdcard的问题的。<br><code>log2file流程图</code><br><img src="http://ww4.sinaimg.cn/large/8b331ee1gw1fbmlojbj7dj210i19648b.jpg" alt=""></p>
<h3 id="上一次没写完的日志，如何重新写到日志中"><a href="#上一次没写完的日志，如何重新写到日志中" class="headerlink" title="上一次没写完的日志，如何重新写到日志中"></a>上一次没写完的日志，如何重新写到日志中</h3><p>在日志模块初始化会执行如下的代码，sg_log_buff为与mmap文件映射的逻辑内存，这里会主动调用Flush，把mmap文件中的数据（即上一次没写到日志文件中的日志）fluse到buffer中，并调用__log2file写到日志文件中。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">char</span> mmap_file_path[<span class="number">512</span>] = &#123;<span class="number">0</span>&#125;;</div><div class="line"><span class="built_in">snprintf</span>(mmap_file_path, <span class="keyword">sizeof</span>(mmap_file_path), <span class="string">"%s/%s.mmap2"</span>, sg_cache_logdir.empty()?_dir:sg_cache_logdir.c_str(), _nameprefix);</div><div class="line"></div><div class="line">    <span class="keyword">bool</span> use_mmap = <span class="literal">false</span>;</div><div class="line">    <span class="keyword">if</span> (OpenMmapFile(mmap_file_path, kBufferBlockLength, sg_mmmap_file))  &#123;</div><div class="line">        sg_log_buff = <span class="keyword">new</span> LogBuffer(sg_mmmap_file.data(), kBufferBlockLength, <span class="literal">true</span>);</div><div class="line">        use_mmap = <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line">    AutoBuffer buffer;</div><div class="line">    sg_log_buff-&gt;Flush(buffer); <span class="comment">// 把mmap文件中日志信息flush到内存中，下面调用__log2file写到文件中。</span></div><div class="line">    <span class="keyword">if</span> (buffer.Ptr()) &#123;</div><div class="line">        __writetips2file(<span class="string">"~~~~~ begin of mmap ~~~~~\n"</span>);</div><div class="line">        __log2file(buffer.Ptr(), buffer.Length());</div><div class="line">        __writetips2file(<span class="string">"~~~~~ end of mmap ~~~~~%s\n"</span>, mark_info);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<hr>
<h2 id="修改xlog默认的输出到文件的策略"><a href="#修改xlog默认的输出到文件的策略" class="headerlink" title="修改xlog默认的输出到文件的策略"></a>修改xlog默认的输出到文件的策略</h2><h3 id="xlog默认的策略"><a href="#xlog默认的策略" class="headerlink" title="xlog默认的策略"></a>xlog默认的策略</h3><p>每次启动时会删除过期文件，只保留十天内的日志文件(该值定义在appender.cc中的 kMaxLogAliveTime )，所以给 Xlog 的目录请使用单独目录，防止误删其他文件。目前不会根据文件大小进行清理。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> __del_timeout_file(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; _log_path) &#123;</div><div class="line">    <span class="keyword">time_t</span> now_time = time(<span class="literal">NULL</span>);</div><div class="line">    </div><div class="line">    boost::filesystem::<span class="function">path <span class="title">path</span><span class="params">(_log_path)</span></span>;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (boost::filesystem::exists(path) &amp;&amp; boost::filesystem::is_directory(path))&#123;</div><div class="line">        boost::filesystem::directory_iterator end_iter;</div><div class="line">        <span class="keyword">for</span> (boost::filesystem::directory_iterator iter(path); iter != end_iter; ++iter) &#123;</div><div class="line">            <span class="keyword">time_t</span> fileModifyTime = boost::filesystem::last_write_time(iter-&gt;path());</div><div class="line">            </div><div class="line">            <span class="keyword">if</span> (now_time &gt; fileModifyTime &amp;&amp; now_time - fileModifyTime &gt; kMaxLogAliveTime) &#123;</div><div class="line">                <span class="keyword">if</span> (boost::filesystem::is_regular_file(iter-&gt;status())) &#123;</div><div class="line">                    boost::filesystem::remove(iter-&gt;path());</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (boost::filesystem::is_directory(iter-&gt;status())) &#123;</div><div class="line">                    __del_files(iter-&gt;path().<span class="built_in">string</span>());</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>日志文件是按天命名的，每天产生一个日志文件。<br>在<code>__openlogfile</code>、<code>__log2file</code>中会调用。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> __make_logfilename(<span class="keyword">const</span> timeval&amp; _tv, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; _logdir, <span class="keyword">const</span> <span class="keyword">char</span>* _prefix, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; _fileext, <span class="keyword">char</span>* _filepath, <span class="keyword">unsigned</span> <span class="keyword">int</span> _len) &#123;</div><div class="line">    <span class="keyword">time_t</span> sec = _tv.tv_sec;</div><div class="line">    tm tcur = *localtime((<span class="keyword">const</span> <span class="keyword">time_t</span>*)&amp;sec);</div><div class="line"></div><div class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> logfilepath = _logdir;</div><div class="line">    logfilepath += <span class="string">"/"</span>;</div><div class="line">    logfilepath += _prefix;</div><div class="line">    <span class="keyword">char</span> temp [<span class="number">64</span>] = &#123;<span class="number">0</span>&#125;;</div><div class="line">    <span class="built_in">snprintf</span>(temp, <span class="number">64</span>, <span class="string">"_%d%02d%02d"</span>, <span class="number">1900</span> + tcur.tm_year, <span class="number">1</span> + tcur.tm_mon, tcur.tm_mday);</div><div class="line">    logfilepath += temp;</div><div class="line">    logfilepath += <span class="string">"."</span>;</div><div class="line">    logfilepath += _fileext;</div><div class="line">    <span class="built_in">strncpy</span>(_filepath, logfilepath.c_str(), _len - <span class="number">1</span>);</div><div class="line">    _filepath[_len - <span class="number">1</span>] = <span class="string">'\0'</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>比如在2017年01月10号的日志会写到LOG_20170110.log文件中，到2017年01月11号时，日志写到LOG_20170111.log，依次类推。过期的日志文件会在日志模块初始化时被清理掉。</p>
<h3 id="改写输出到文件的策略"><a href="#改写输出到文件的策略" class="headerlink" title="改写输出到文件的策略"></a>改写输出到文件的策略</h3><p>xlog输出的文件的逻辑都在<code>appender.cc</code>中实现，可以修改这里的代码实现一套自己的策略。<br>比如想要控制日志文件的大小，即Rotating file based on size的策略。<br>这里的实现方案并不支持cachedir。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">bool</span> __writefile(<span class="keyword">const</span> <span class="keyword">void</span>* _data, <span class="keyword">size_t</span> _len) &#123;</div><div class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == sg_logfile) &#123;</div><div class="line">        assert(<span class="literal">false</span>);</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">long</span> before_len = ftell(sg_logfile);</div><div class="line">    <span class="keyword">if</span> (before_len &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 如果发生了__roate，需要reopen sg_logfile</span></div><div class="line">    <span class="keyword">if</span>(before_len+_len &gt; sg_max_size)&#123;</div><div class="line">        <span class="keyword">if</span>(!__roate())&#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (<span class="number">1</span> != fwrite(_data, _len, <span class="number">1</span>, sg_logfile)) &#123;</div><div class="line">        <span class="keyword">int</span> err = ferror(sg_logfile);</div><div class="line"></div><div class="line">        __writetips2console(<span class="string">"write file error:%d"</span>, err);</div><div class="line"></div><div class="line"></div><div class="line">        ftruncate(fileno(sg_logfile), before_len);</div><div class="line">        fseek(sg_logfile, <span class="number">0</span>, SEEK_END);</div><div class="line"></div><div class="line">        <span class="keyword">char</span> err_log[<span class="number">256</span>] = &#123;<span class="number">0</span>&#125;;</div><div class="line">        <span class="built_in">snprintf</span>(err_log, <span class="keyword">sizeof</span>(err_log), <span class="string">"\nwrite file error:%d\n"</span>, err);</div><div class="line"></div><div class="line">        <span class="keyword">char</span> tmp[<span class="number">256</span>] = &#123;<span class="number">0</span>&#125;;</div><div class="line">        <span class="keyword">size_t</span> len = <span class="keyword">sizeof</span>(tmp);</div><div class="line">        LogBuffer::Write(err_log, strnlen(err_log, <span class="keyword">sizeof</span>(err_log)), tmp, len);</div><div class="line"></div><div class="line">        fwrite(tmp, len, <span class="number">1</span>, sg_logfile);</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">NumberToString</span> <span class="params">( T Number )</span></span></div><div class="line">&#123;</div><div class="line">     <span class="built_in">std</span>::<span class="built_in">ostringstream</span> ss;</div><div class="line">     ss &lt;&lt; Number;</div><div class="line">     <span class="keyword">return</span> ss.str();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">string</span> __calc_filename(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; _logdir, <span class="keyword">const</span> <span class="keyword">char</span>* _prefix, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; _fileext,<span class="keyword">unsigned</span> <span class="keyword">int</span> index)&#123;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> logfilepath = _logdir;</div><div class="line">    logfilepath += <span class="string">"/"</span>;</div><div class="line">    logfilepath += _prefix;</div><div class="line">    <span class="keyword">if</span>(index)&#123;</div><div class="line">        logfilepath += <span class="string">"."</span>;</div><div class="line">        logfilepath += NumberToString(index);</div><div class="line">    &#125;</div><div class="line">    logfilepath += <span class="string">"."</span>;</div><div class="line">    logfilepath += _fileext;</div><div class="line">    <span class="keyword">return</span> logfilepath;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">// Rotate files:</span></div><div class="line">    <span class="comment">// log.txt -&gt; log.1.txt</span></div><div class="line">    <span class="comment">// log.1.txt -&gt; log2.txt</span></div><div class="line">    <span class="comment">// log.2.txt -&gt; log3.txt</span></div><div class="line">    <span class="comment">// log.3.txt -&gt; delete</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">bool</span> __roate()&#123;</div><div class="line">    <span class="keyword">if</span>(sg_logfilename.empty() || sg_logdir.empty() || sg_logfileprefix.empty())&#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    fclose(sg_logfile);</div><div class="line">    sg_logfile = <span class="literal">NULL</span>;</div><div class="line"></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i = sg_max_files; i &gt; <span class="number">0</span>; --i)&#123;</div><div class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> src = __calc_filename(sg_logdir,sg_logfileprefix.c_str(),LOG_EXT,i<span class="number">-1</span>);</div><div class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> target = __calc_filename(sg_logdir,sg_logfileprefix.c_str(),LOG_EXT,i);</div><div class="line">        boost::filesystem::<span class="function">path <span class="title">src_path</span><span class="params">(src)</span></span>;</div><div class="line">        boost::filesystem::<span class="function">path <span class="title">target_path</span><span class="params">(target)</span></span>;</div><div class="line"></div><div class="line">        <span class="keyword">if</span>(boost::filesystem::exists(target_path))&#123;</div><div class="line">            boost::filesystem::remove(target_path);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(boost::filesystem::exists(src_path))&#123;</div><div class="line">            boost::filesystem::rename(src_path,target_path);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//reopen</span></div><div class="line">    sg_logfile = fopen(sg_logfilename.c_str(), <span class="string">"wb"</span>);</div><div class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == sg_logfile) &#123;</div><div class="line">        __writetips2console(<span class="string">"open file error:%d %s, path:%s"</span>, errno, strerror(errno), sg_logfilename.c_str());</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">bool</span> __openlogfile(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; _log_dir)&#123;</div><div class="line">    <span class="keyword">if</span> (sg_logdir.empty()) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 如果sg_logfile已经打开了，则直接返回。</span></div><div class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> != sg_logfile) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    sg_current_dir = _log_dir;</div><div class="line">    sg_logfilename = __calc_filename(_log_dir, sg_logfileprefix.c_str(), LOG_EXT,<span class="number">0</span>);</div><div class="line"></div><div class="line">    sg_logfile = fopen(sg_logfilename.c_str(), <span class="string">"ab"</span>);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == sg_logfile) &#123;</div><div class="line">        __writetips2console(<span class="string">"open file error:%d %s, path:%s"</span>, errno, strerror(errno), sg_logfilename.c_str());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="literal">NULL</span> != sg_logfile;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> __log2file(<span class="keyword">const</span> <span class="keyword">void</span>* _data, <span class="keyword">size_t</span> _len) &#123;</div><div class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == _data || <span class="number">0</span> == _len || sg_logdir.empty()) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">	    <span class="function">ScopedLock <span class="title">lock_file</span><span class="params">(sg_mutex_log_file)</span></span>;</div><div class="line">        <span class="keyword">if</span> (__openlogfile(sg_logdir)) &#123;</div><div class="line">            __writefile(_data, _len);</div><div class="line">            <span class="keyword">if</span> (kAppednerAsync == sg_mode) &#123;</div><div class="line">                __closelogfile();</div><div class="line">            &#125;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>代码详见：<a href="https://github.com/FelixZhang00/xlog-rotating-base-size" target="_blank" rel="external">github</a></p>
<hr>
<h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><p><a href="http://dev.qq.com/topic/581c2c46bef1702a2db3ae53" target="_blank" rel="external">http://dev.qq.com/topic/581c2c46bef1702a2db3ae53</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/Tencent/mars&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;mars&lt;/a&gt; 是微信最近开源的终端基础组件，是一个使用 C++ 编写的基础组件。&lt;br&gt;xlog是其中一个可单独使用的高性能
    
    </summary>
    
    
      <category term="c++ 开源代码" scheme="http://felixzhang00.github.io/tags/c-%E5%BC%80%E6%BA%90%E4%BB%A3%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>spdlog源码学习</title>
    <link href="http://felixzhang00.github.io/2017/01/12/spdlog%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    <id>http://felixzhang00.github.io/2017/01/12/spdlog源码学习/</id>
    <published>2017-01-12T09:35:42.000Z</published>
    <updated>2017-01-12T09:40:41.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/gabime/spdlog" target="_blank" rel="external">spdlog</a>是一个用c++11实现的高性能日志库。<br>接入方便，功能丰富，代码可读性较高。</p>
<hr>
<h2 id="Features"><a href="#Features" class="headerlink" title="Features"></a>Features</h2><ul>
<li>Very fast - performance is the primary goal </li>
<li>Headers only, just copy and use.</li>
<li>Feature rich  using the excellent <a href="https://github.com/fmtlib/fmt" target="_blank" rel="external">fmt</a> library.</li>
<li>Extremely fast asynchronous mode (optional) - using lockfree queues and other tricks to reach millions of calls/sec.</li>
<li><a href="https://github.com/gabime/spdlog/wiki/3.-Custom-formatting" target="_blank" rel="external">Custom</a> formatting.</li>
<li>Multi/Single threaded loggers.</li>
<li>Various log targets:<ul>
<li>Rotating log files.</li>
<li>Daily log files.</li>
<li>Console logging (colors supported).</li>
<li>syslog.</li>
<li>Windows debugger </li>
<li>Easily extendable with custom log targets  (just implement a single function in the sink interface).</li>
</ul>
</li>
<li>Severity based filtering - threshold levels can be modified in runtime as well as in compile time.</li>
</ul>
<hr>
<h2 id="核心设计"><a href="#核心设计" class="headerlink" title="核心设计"></a>核心设计</h2><p>spdlog中定义了一系列Sink类，作为实际上把log输出到指定目标的对象，每一个Sink唯一对应一个log的输出目标（如console、文件、db）.<br>每一个logger包含一个sink列表，每当上层调用logger的log方法写日志时，logger就会调用sink列表中的每一个sink的 <code>sink(log_msg)</code> 函数，真正往目标中写日志。</p>
<h3 id="实现Rotating-file写日志"><a href="#实现Rotating-file写日志" class="headerlink" title="实现Rotating file写日志"></a>实现Rotating file写日志</h3><p>当前正在写日志的文件名一直都是log.txt。<br>当log.txt写不下时，把它重命名为log1.txt,再重新打开一个log.txt文件。<br>多个文件循环也依次类推。</p>
<pre><code>// Rotate files:
// log.txt -&gt; log.1.txt
// log.1.txt -&gt; log2.txt
// log.2.txt -&gt; log3.txt
// log.3.txt -&gt; delete
</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * Rotating file sink based on size</div><div class="line"> */</div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Mutex&gt;</div><div class="line"><span class="keyword">class</span> rotating_file_sink : <span class="keyword">public</span> base_sink &lt; Mutex &gt;</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    rotating_file_sink(<span class="keyword">const</span> <span class="keyword">filename_t</span> &amp;base_filename, <span class="keyword">const</span> <span class="keyword">filename_t</span> &amp;extension,</div><div class="line">                       <span class="built_in">std</span>::<span class="keyword">size_t</span> max_size, <span class="built_in">std</span>::<span class="keyword">size_t</span> max_files                       ) :</div><div class="line">    &#123;</div><div class="line">        _file_helper.open(calc_filename(_base_filename, <span class="number">0</span>, _extension));</div><div class="line">        _current_size = _file_helper.size(); <span class="comment">//expensive. called only once</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="keyword">protected</span>:</div><div class="line">    <span class="keyword">void</span> _sink_it(<span class="keyword">const</span> details::log_msg&amp; msg) override</div><div class="line">    &#123;</div><div class="line">        _current_size += msg.formatted.size();</div><div class="line">        <span class="keyword">if</span> (_current_size &gt; _max_size)</div><div class="line">        &#123;</div><div class="line">            _rotate();</div><div class="line">            _current_size = msg.formatted.size();</div><div class="line">        &#125;</div><div class="line">        _file_helper.write(msg);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="function"><span class="keyword">static</span> filename_t <span class="title">calc_filename</span><span class="params">(<span class="keyword">const</span> <span class="keyword">filename_t</span>&amp; filename, <span class="built_in">std</span>::<span class="keyword">size_t</span> index, <span class="keyword">const</span> <span class="keyword">filename_t</span>&amp; extension)</span></span></div><div class="line">    &#123;</div><div class="line">    <span class="comment">//...</span></div><div class="line">        <span class="keyword">return</span> w.str();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">void</span> _rotate()</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">using</span> details::os::filename_to_str;</div><div class="line">        _file_helper.close();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = _max_files; i &gt; <span class="number">0</span>; --i)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">filename_t</span> src = calc_filename(_base_filename, i - <span class="number">1</span>, _extension);</div><div class="line">            <span class="keyword">filename_t</span> target = calc_filename(_base_filename, i, _extension);</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (details::file_helper::file_exists(target))</div><div class="line">            &#123;</div><div class="line">                details::os::remove(target);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (details::file_helper::file_exists(src) &amp;&amp; details::os::rename(src, target))</div><div class="line">            &#123;</div><div class="line">				<span class="comment">//...</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        _file_helper.reopen(<span class="literal">true</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">filename_t</span> _base_filename;</div><div class="line">    <span class="keyword">filename_t</span> _extension;</div><div class="line">    <span class="built_in">std</span>::<span class="keyword">size_t</span> _max_size;</div><div class="line">    <span class="built_in">std</span>::<span class="keyword">size_t</span> _max_files;</div><div class="line">    <span class="built_in">std</span>::<span class="keyword">size_t</span> _current_size;</div><div class="line">    details::file_helper _file_helper;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<hr>
<h3 id="实现异步写日志"><a href="#实现异步写日志" class="headerlink" title="实现异步写日志"></a>实现异步写日志</h3><p>所有异步写日志的请求都会被push到一个固定大小的队列中。<br>有一个工作线程会不停的从队列中pop一条日志消息，并最终写到日志中。</p>
<p>调用方：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">async_example</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">size_t</span> q_size = <span class="number">4096</span>; <span class="comment">//queue size must be power of 2</span></div><div class="line">    spdlog::set_async_mode(q_size);</div><div class="line">    <span class="keyword">auto</span> async_file = spd::daily_logger_st(<span class="string">"async_file_logger"</span>, <span class="string">"logs/async_log.txt"</span>);</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i)</div><div class="line">        async_file-&gt;info(<span class="string">"Async message #&#123;&#125;"</span>, i);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>具体实现：<br>开启一个工作线程，在async_log初始时就开始工作了。并且在析构是被关闭<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Async Logger implementation</span></div><div class="line"><span class="comment">// Use an async_sink (queue per logger) to perform the logging in a worker thread</span></div><div class="line"></div><div class="line"><span class="comment">//一个工作线程，在async_log初始时就开始工作了。并且在析构是被关闭</span></div><div class="line"><span class="comment">// worker thread</span></div><div class="line"><span class="built_in">std</span>::thread _worker_thread;</div><div class="line">_worker_thread(&amp;async_log_helper::worker_loop, <span class="keyword">this</span>)</div><div class="line"><span class="keyword">inline</span> <span class="keyword">void</span> spdlog::details::async_log_helper::worker_loop()</div><div class="line">&#123;</div><div class="line">    <span class="keyword">try</span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> (_worker_warmup_cb) _worker_warmup_cb();</div><div class="line">        <span class="keyword">auto</span> last_pop = details::os::now();</div><div class="line">        <span class="keyword">auto</span> last_flush = last_pop;</div><div class="line">        <span class="keyword">while</span>(process_next_msg(last_pop, last_flush));</div><div class="line">        <span class="keyword">if</span> (_worker_teardown_cb) _worker_teardown_cb();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">catch</span> (<span class="keyword">const</span> <span class="built_in">std</span>::exception &amp;ex)</div><div class="line">    &#123;</div><div class="line">        _err_handler(ex.what());</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">catch</span> (...)</div><div class="line">    &#123;</div><div class="line">        _err_handler(<span class="string">"Unknown exception"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// Send to the worker thread termination message(level=off)</span></div><div class="line"><span class="comment">// and wait for it to finish gracefully</span></div><div class="line"><span class="keyword">inline</span> spdlog::details::async_log_helper::~async_log_helper()</div><div class="line">&#123;</div><div class="line">    <span class="keyword">try</span></div><div class="line">    &#123;</div><div class="line">        push_msg(async_msg(async_msg_type::terminate));</div><div class="line">        _worker_thread.join();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">catch</span> (...) <span class="comment">// don't crash in destructor</span></div><div class="line">    &#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>从队列中取消息，如果是写日志的消息，则调用sink写日志。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//从队列中取消息，如果是写日志的消息，则调用sink写日志。</span></div><div class="line"><span class="comment">// process next message in the queue</span></div><div class="line"><span class="comment">// return true if this thread should still be active (while no terminate msg was received)</span></div><div class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> spdlog::details::async_log_helper::process_next_msg(log_clock::time_point&amp; last_pop, log_clock::time_point&amp; last_flush)</div><div class="line">&#123;</div><div class="line">    async_msg incoming_async_msg;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (_q.dequeue(incoming_async_msg))</div><div class="line">    &#123;</div><div class="line">        last_pop = details::os::now();</div><div class="line">        <span class="keyword">switch</span> (incoming_async_msg.msg_type)</div><div class="line">        &#123;</div><div class="line">        <span class="keyword">case</span> async_msg_type::flush:</div><div class="line">            _flush_requested = <span class="literal">true</span>;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line"></div><div class="line">        <span class="keyword">case</span> async_msg_type::terminate:</div><div class="line">            _flush_requested = <span class="literal">true</span>;</div><div class="line">            _terminate_requested = <span class="literal">true</span>;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line"></div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            log_msg incoming_log_msg;</div><div class="line">            incoming_async_msg.fill_log_msg(incoming_log_msg);</div><div class="line">            _formatter-&gt;format(incoming_log_msg);</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;s : _sinks)</div><div class="line">            &#123;</div><div class="line">                <span class="keyword">if</span>(s-&gt;should_log( incoming_log_msg.level))</div><div class="line">                &#123;</div><div class="line">                    s-&gt;<span class="built_in">log</span>(incoming_log_msg);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Handle empty queue..</span></div><div class="line">    <span class="comment">// This is the only place where the queue can terminate or flush to avoid losing messages already in the queue</span></div><div class="line">    <span class="keyword">else</span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">auto</span> now = details::os::now();</div><div class="line">        handle_flush_interval(now, last_flush);</div><div class="line">        sleep_or_yield(now, last_pop);</div><div class="line">        <span class="keyword">return</span> !_terminate_requested;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>调用写日志，往队列里塞一条写日志消息。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">inline</span> <span class="keyword">void</span> spdlog::logger::<span class="built_in">log</span>(level::level_enum lvl, <span class="keyword">const</span> T&amp; msg)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (!should_log(lvl)) <span class="keyword">return</span>;</div><div class="line">    <span class="keyword">try</span></div><div class="line">    &#123;</div><div class="line">        details::<span class="function">log_msg <span class="title">log_msg</span><span class="params">(&amp;_name, lvl)</span></span>;</div><div class="line">        log_msg.raw &lt;&lt; msg;</div><div class="line">        _sink_it(log_msg);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">catch</span> (<span class="keyword">const</span> <span class="built_in">std</span>::exception &amp;ex)</div><div class="line">    &#123;</div><div class="line">        _err_handler(ex.what());</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">catch</span> (...)</div><div class="line">    &#123;</div><div class="line">        _err_handler(<span class="string">"Unknown exception"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">inline</span> <span class="keyword">void</span> spdlog::async_logger::_sink_it(details::log_msg&amp; msg)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">try</span></div><div class="line">    &#123;</div><div class="line">        _async_log_helper-&gt;<span class="built_in">log</span>(msg);</div><div class="line">        <span class="keyword">if</span> (_should_flush_on(msg))</div><div class="line">            _async_log_helper-&gt;flush(<span class="literal">false</span>); <span class="comment">// do async flush</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">catch</span> (<span class="keyword">const</span> <span class="built_in">std</span>::exception &amp;ex)</div><div class="line">    &#123;</div><div class="line">        _err_handler(ex.what());</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">catch</span> (...)</div><div class="line">    &#123;</div><div class="line">        _err_handler(<span class="string">"Unknown exception"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 往队列里塞一条日志进去，准备被写</span></div><div class="line"><span class="comment">//Try to push and block until succeeded (if the policy is not to discard when the queue is full)</span></div><div class="line"><span class="keyword">inline</span> <span class="keyword">void</span> spdlog::details::async_log_helper::<span class="built_in">log</span>(<span class="keyword">const</span> details::log_msg&amp; msg)</div><div class="line">&#123;</div><div class="line">    push_msg(async_msg(msg));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">inline</span> <span class="keyword">void</span> spdlog::details::async_log_helper::push_msg(details::async_log_helper::async_msg&amp;&amp; new_msg)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (!_q.enqueue(<span class="built_in">std</span>::move(new_msg)) &amp;&amp; _overflow_policy != async_overflow_policy::discard_log_msg)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">auto</span> last_op_time = details::os::now();</div><div class="line">        <span class="keyword">auto</span> now = last_op_time;</div><div class="line">        <span class="keyword">do</span></div><div class="line">        &#123;</div><div class="line">            now = details::os::now();</div><div class="line">            sleep_or_yield(now, last_op_time);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">while</span> (!_q.enqueue(<span class="built_in">std</span>::move(new_msg)));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>根据时间间隔让线程等待<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// spin, yield or sleep. use the time passed since last message as a hint</span></div><div class="line"><span class="keyword">inline</span> <span class="keyword">void</span> spdlog::details::async_log_helper::sleep_or_yield(<span class="keyword">const</span> spdlog::log_clock::time_point&amp; now, <span class="keyword">const</span> spdlog::log_clock::time_point&amp; last_op_time)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>::this_thread;</div><div class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::chrono::milliseconds;</div><div class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::chrono::microseconds;</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> time_since_op = now - last_op_time;</div><div class="line"></div><div class="line">    <span class="comment">// spin upto 50 micros</span></div><div class="line">    <span class="keyword">if</span> (time_since_op &lt;= microseconds(<span class="number">50</span>))</div><div class="line">        <span class="keyword">return</span>;</div><div class="line"></div><div class="line">    <span class="comment">// yield upto 150 micros</span></div><div class="line">    <span class="keyword">if</span> (time_since_op &lt;= microseconds(<span class="number">100</span>))</div><div class="line">        <span class="keyword">return</span> <span class="built_in">std</span>::this_thread::yield();</div><div class="line"></div><div class="line">    <span class="comment">// sleep for 20 ms upto 200 ms</span></div><div class="line">    <span class="keyword">if</span> (time_since_op &lt;= milliseconds(<span class="number">200</span>))</div><div class="line">        <span class="keyword">return</span> sleep_for(milliseconds(<span class="number">20</span>));</div><div class="line"></div><div class="line">    <span class="comment">// sleep for 200 ms</span></div><div class="line">    <span class="keyword">return</span> sleep_for(milliseconds(<span class="number">200</span>));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/gabime/spdlog&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;spdlog&lt;/a&gt;是一个用c++11实现的高性能日志库。&lt;br&gt;接入方便，功能丰富，代码可读性较高。&lt;/p&gt;
&lt;hr&gt;
&lt;h
    
    </summary>
    
    
      <category term="c++ 开源代码" scheme="http://felixzhang00.github.io/tags/c-%E5%BC%80%E6%BA%90%E4%BB%A3%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Python断点调试</title>
    <link href="http://felixzhang00.github.io/2017/01/07/Python%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95/"/>
    <id>http://felixzhang00.github.io/2017/01/07/Python断点调试/</id>
    <published>2017-01-07T14:31:10.000Z</published>
    <updated>2017-01-07T14:34:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>很多项目是用python写构建脚本的，比如微信最近开源的终端跨平台组件 <a href="https://github.com/Tencent/mars" target="_blank" rel="external">Mars</a><br>本文将以mars为例简单介绍下如何用<a href="https://www.jetbrains.com/pycharm/" target="_blank" rel="external">PyCharm</a>对python进行断点调试。</p>
<hr>
<h3 id="导入代码"><a href="#导入代码" class="headerlink" title="导入代码"></a>导入代码</h3><p>open整个mars项目，切换合适的python版本，mars需要python2.7版本。<br><img src="http://ww1.sinaimg.cn/large/8b331ee1gw1fbifkuh496j20h81f0q9j.jpg" alt=""><br><img src="http://ww2.sinaimg.cn/large/8b331ee1gw1fbifke5anpj20xm0du0xi.jpg" alt=""></p>
<h3 id="打断点"><a href="#打断点" class="headerlink" title="打断点"></a>打断点</h3><p><img src="http://ww3.sinaimg.cn/large/8b331ee1gw1fbifnm18q9j20gk04gt94.jpg" alt=""></p>
<h3 id="Debug-it"><a href="#Debug-it" class="headerlink" title="Debug it"></a>Debug it</h3><p><img src="http://ww1.sinaimg.cn/large/8b331ee1gw1fbifo65ncyj20po0v6wm7.jpg" alt=""></p>
<p>当代码中需要input时，切换到Console窗口输入<br><img src="http://ww3.sinaimg.cn/large/8b331ee1gw1fbifq7bsxlj20nm0e4jvb.jpg" alt=""></p>
<p><img src="http://ww3.sinaimg.cn/large/8b331ee1gw1fbifqp5rcaj211q0lutf5.jpg" alt=""></p>
<p>用PyCharm调试跟Android Studio一样，毕竟都是一家公司的产品。</p>
<hr>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;很多项目是用python写构建脚本的，比如微信最近开源的终端跨平台组件 &lt;a href=&quot;https://github.com/Tencent/mars&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Mars&lt;/a&gt;&lt;br&gt;本文将以mars为例简单介绍下如
    
    </summary>
    
    
      <category term="工具 python" scheme="http://felixzhang00.github.io/tags/%E5%B7%A5%E5%85%B7-python/"/>
    
  </entry>
  
  <entry>
    <title>Stetho工具介绍</title>
    <link href="http://felixzhang00.github.io/2017/01/05/Stetho%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D/"/>
    <id>http://felixzhang00.github.io/2017/01/05/Stetho工具介绍/</id>
    <published>2017-01-05T14:45:58.000Z</published>
    <updated>2017-01-05T14:52:47.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://facebook.github.io/stetho/" target="_blank" rel="external">stetho</a>是Facebook推出的安卓APP网络诊断和数据监控的工具，接入方便，功能强大，是开发者必备的好工具。</p>
<p>主要功能包括：</p>
<ul>
<li>查看App的布局</li>
<li>网络请求抓包</li>
<li>数据库、sp文件查看</li>
<li>自定义dumpapp插件</li>
<li>对于JavaScript的支持</li>
</ul>
<p>无需root，只要能通过adb连接设备，操作方便。</p>
<h2 id="接入方法"><a href="#接入方法" class="headerlink" title="接入方法"></a>接入方法</h2><h3 id="gradle配置"><a href="#gradle配置" class="headerlink" title="gradle配置"></a>gradle配置</h3><p>因为目前我们的项目中已经集成了okhttp，只需要在build.gradle添加如下两行配置</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">dependencies &#123;</div><div class="line">   <span class="comment">//...</span></div><div class="line"></div><div class="line">   compile <span class="string">'com.facebook.stetho:stetho-js-rhino:1.3.1'</span></div><div class="line">   compile <span class="string">'com.facebook.stetho:stetho-okhttp3:1.4.2'</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>在Application类中完成初始化<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">MyApplicationCreate</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="comment">// ...</span></div><div class="line">     Stetho.initializeWithDefaults(mContext);</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<h2 id="使用功能"><a href="#使用功能" class="headerlink" title="使用功能"></a>使用功能</h2><ol>
<li>adb方式连接到设备</li>
<li>运行debug模式的app</li>
<li>在Chrome浏览器地址栏中输入chrome://inspect</li>
<li>选择需要inspect的应用进程<br><img src="http://ww1.sinaimg.cn/large/8b331ee1gw1fbg4wwn5ftj21aw0qo7az.jpg" alt=""></li>
</ol>
<h3 id="查看App的布局"><a href="#查看App的布局" class="headerlink" title="查看App的布局"></a>查看App的布局</h3><p><img src="http://ww1.sinaimg.cn/large/8b331ee1gw1fbfhku1ltsj21kw0s5tt8.jpg" alt=""></p>
<h3 id="网络诊断"><a href="#网络诊断" class="headerlink" title="网络诊断"></a>网络诊断</h3><p>给OkHttpClient添加拦截器。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> OkHttpClient.Builder()</div><div class="line">    .addNetworkInterceptor(<span class="keyword">new</span> StethoInterceptor())</div><div class="line">    .build();</div></pre></td></tr></table></figure></p>
<p>主要功能有包括下载图片的预览，JSON数据查看，网络请求内容和返回内容<br><img src="http://ww3.sinaimg.cn/large/8b331ee1gw1fbfhpn53jjj21kw0rjk3j.jpg" alt=""></p>
<h3 id="数据库、sp文件查看"><a href="#数据库、sp文件查看" class="headerlink" title="数据库、sp文件查看"></a>数据库、sp文件查看</h3><p><img src="http://ww4.sinaimg.cn/large/8b331ee1gw1fbfhrmo7blj21kw0rvgx0.jpg" alt=""></p>
<p><img src="http://ww3.sinaimg.cn/large/8b331ee1gw1fbfhsqtl35j21kw0rq7fi.jpg" alt=""></p>
<h3 id="自定义dumpapp插件"><a href="#自定义dumpapp插件" class="headerlink" title="自定义dumpapp插件"></a>自定义dumpapp插件</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">Stetho.initialize(Stetho.newInitializerBuilder(context)</div><div class="line">        .enableDumpapp(<span class="keyword">new</span> DumperPluginsProvider() &#123;</div><div class="line">          <span class="meta">@Override</span></div><div class="line">          <span class="function"><span class="keyword">public</span> Iterable&lt;DumperPlugin&gt; <span class="title">get</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Stetho.DefaultDumperPluginsBuilder(context)</div><div class="line">                .provide(<span class="keyword">new</span> HelloWorldDumperPlugin())</div><div class="line">                .provide(<span class="keyword">new</span> APODDumperPlugin(context.getContentResolver()))</div><div class="line">                .finish();</div><div class="line">          &#125;</div><div class="line">        &#125;)</div><div class="line">        .enableWebKitInspector(<span class="keyword">new</span> ExtInspectorModulesProvider(context))</div><div class="line">        .build());</div></pre></td></tr></table></figure>
<p>其中HelloWorldDumperPlugin和APODDumperPlugin是自定义的插件，具体内容可以参考<a href="https://github.com/facebook/stetho/tree/master/stetho-sample" target="_blank" rel="external">Stetho提供的sample程序</a><br>运行dumpapp脚本后以达到与app交互通信的效果。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ ./dumpapp <span class="_">-l</span></div><div class="line">apod</div><div class="line">crash</div><div class="line">files</div><div class="line">hello</div><div class="line">hprof</div><div class="line">prefs</div></pre></td></tr></table></figure></p>
<h4 id="原理简介"><a href="#原理简介" class="headerlink" title="原理简介"></a>原理简介</h4><p>其中dumpapp是一个python脚本，通信的方式使用的是android提供的<a href="https://android.googlesource.com/platform/system/core/+/master/adb/protocol.txt" target="_blank" rel="external">smartsocket接口</a><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">--- smartsockets -------------------------------------------------------</div><div class="line">Port <span class="number">5037</span> is used <span class="keyword">for</span> smart sockets which allow a client on the host</div><div class="line">side to request access to a service <span class="keyword">in</span> the host adb daemon or <span class="keyword">in</span> the</div><div class="line">remote (device) daemon.  The service is requested by ascii name,</div><div class="line">preceeded by a <span class="number">4</span> digit hex length.  Upon successful connection an</div><div class="line"><span class="string">"OKAY"</span> response is sent, otherwise a <span class="string">"FAIL"</span> message is returned.  Once</div><div class="line">connected the client is talking to that (remote or local) service.</div><div class="line">client: &lt;hex4&gt; &lt;service-name&gt;</div><div class="line">server: "OKAY"</div><div class="line">client: &lt;hex4&gt; &lt;service-name&gt;</div><div class="line">server: "FAIL" &lt;hex4&gt; &lt;reason&gt;</div></pre></td></tr></table></figure></p>
<p>使用PyCharm<a href="http://stackoverflow.com/questions/27952331/debugging-with-pycharm-terminal-arguments" target="_blank" rel="external">对Python进行断点调试</a>：<br><img src="http://ww3.sinaimg.cn/large/8b331ee1gw1fbfian208yj21kw0arwia.jpg" alt=""><br>这段脚本的功能就是通过读取<code>/proc/net/unix</code>文件去找app设置的socket<br><img src="http://ww2.sinaimg.cn/large/8b331ee1gw1fbfid70oipj21gs044t9m.jpg" alt=""></p>
<ol>
<li>扫描android所有提供socket功能的设备，找到steho的devtools_remote</li>
<li>建立与第一步找到的进程socket，然后通过smartsocket进行通信。</li>
<li>设备上的app相当于一个服务器，脚本是客户端对它进行访问</li>
</ol>
<p>后缀为_devtools_remote的socket是android留给chrome的后门。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Note that _devtools_remote is a magic suffix understood by Chrome which //causes the discovery process to begin.</span></div></pre></td></tr></table></figure></p>
<p>详细内容可以看这篇<a href="https://developer.chrome.com/devtools/docs/remote-debugging-legacy" target="_blank" rel="external">官方文档</a><br>这篇文档提供的例子是在命令行中输入下面的命令，就能在电脑上看到手机chrome中的内容了：<br><code>adb forward tcp:9222 localabstract:chrome_devtools_remote</code></p>
<p><img src="http://ww2.sinaimg.cn/large/8b331ee1gw1fbfijp8jqfj21320lo0tp.jpg" alt=""></p>
<p>打开的chrome-devtool其实是一个websocket连接。<br><img src="http://ww4.sinaimg.cn/large/8b331ee1gw1fbfipebrd2j21kw069766.jpg" alt=""><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handlePageList</span><span class="params">(LightHttpResponse response)</span></span></div><div class="line">    <span class="keyword">throws</span> JSONException &#123;</div><div class="line">  <span class="keyword">if</span> (mPageListResponse == <span class="keyword">null</span>) &#123;</div><div class="line">    JSONArray reply = <span class="keyword">new</span> JSONArray();</div><div class="line">    JSONObject page = <span class="keyword">new</span> JSONObject();</div><div class="line">    page.put(<span class="string">"type"</span>, <span class="string">"app"</span>);</div><div class="line">    page.put(<span class="string">"title"</span>, makeTitle());</div><div class="line">    page.put(<span class="string">"id"</span>, PAGE_ID);</div><div class="line">    page.put(<span class="string">"description"</span>, <span class="string">""</span>);</div><div class="line"></div><div class="line">    page.put(<span class="string">"webSocketDebuggerUrl"</span>, <span class="string">"ws://"</span> + mInspectorPath);</div><div class="line">    Uri chromeFrontendUrl = <span class="keyword">new</span> Uri.Builder()</div><div class="line">        .scheme(<span class="string">"http"</span>)</div><div class="line">        .authority(<span class="string">"chrome-devtools-frontend.appspot.com"</span>)</div><div class="line">        .appendEncodedPath(<span class="string">"serve_rev"</span>)</div><div class="line">        .appendEncodedPath(WEBKIT_REV)</div><div class="line">        .appendEncodedPath(<span class="string">"devtools.html"</span>)</div><div class="line">        .appendQueryParameter(<span class="string">"ws"</span>, mInspectorPath)</div><div class="line">        .build();</div><div class="line">    page.put(<span class="string">"devtoolsFrontendUrl"</span>, chromeFrontendUrl.toString());</div><div class="line"></div><div class="line">    reply.put(page);</div><div class="line">    mPageListResponse = LightHttpBody.create(reply.toString(), <span class="string">"application/json"</span>);</div><div class="line">  &#125;</div><div class="line">  setSuccessfulResponse(response, mPageListResponse);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在android上的服务端socket写法,<br>详见LocalSocketServer类的listenOnAddress方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">listenOnAddress</span><span class="params">(String address)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">  mServerSocket = bindToSocket(address);</div><div class="line">  LogUtil.i(<span class="string">"Listening on @"</span> + address);</div><div class="line"></div><div class="line">  <span class="keyword">while</span> (!Thread.interrupted()) &#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      <span class="comment">// Use previously accepted socket the first time around, otherwise wait to accept another.</span></div><div class="line">      LocalSocket socket = mServerSocket.accept();</div><div class="line"></div><div class="line">      <span class="comment">// Start worker thread</span></div><div class="line">      Thread t = <span class="keyword">new</span> WorkerThread(socket, mSocketHandler);</div><div class="line">      t.setName(</div><div class="line">          WORKER_THREAD_NAME_PREFIX +</div><div class="line">          <span class="string">"-"</span> + mFriendlyName +</div><div class="line">          <span class="string">"-"</span> + mThreadId.incrementAndGet());</div><div class="line">      t.setDaemon(<span class="keyword">true</span>);</div><div class="line">      t.start();</div><div class="line">    &#125; <span class="keyword">catch</span> (SocketException se) &#123;</div><div class="line">      <span class="comment">// ignore exception if interrupting the thread</span></div><div class="line">      <span class="keyword">if</span> (Thread.interrupted()) &#123;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">      &#125;</div><div class="line">      LogUtil.w(se, <span class="string">"I/O error"</span>);</div><div class="line">    &#125; <span class="keyword">catch</span> (InterruptedIOException ex) &#123;</div><div class="line">      <span class="keyword">break</span>;</div><div class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">      LogUtil.w(e, <span class="string">"I/O error initialising connection thread"</span>);</div><div class="line">      <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  LogUtil.i(<span class="string">"Server shutdown on @"</span> + address);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="对于JavaScript的支持"><a href="#对于JavaScript的支持" class="headerlink" title="对于JavaScript的支持"></a>对于JavaScript的支持</h3><p>Chrome开发者工具原生支持JavaScript，所以Stetho也提供了JavaScript的支持。<br>通过在console中输入如下代码可以让设备app弹出一个toast<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">importPackage(android.widget);</div><div class="line">importPackage(android.os);</div><div class="line"><span class="keyword">var</span> handler = <span class="keyword">new</span> Handler(Looper.getMainLooper());</div><div class="line">handler.post(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; Toast.makeText(context, <span class="string">"Hello from JavaScript"</span>, Toast.LENGTH_LONG).show() &#125;);</div></pre></td></tr></table></figure></p>
<p><img src="http://ww3.sinaimg.cn/large/8b331ee1gw1fbfixpdt6hj21kw0rmgv8.jpg" alt=""><br>更多玩法见<a href="https://github.com/facebook/stetho/tree/master/stetho-js-rhino" target="_blank" rel="external">Rhino on Stetho
</a></p>
<hr>
<h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><p><a href="http://facebook.github.io/stetho/" target="_blank" rel="external">http://facebook.github.io/stetho/</a><br><a href="https://github.com/facebook/stetho/tree/master/stetho-js-rhino" target="_blank" rel="external">https://github.com/facebook/stetho/tree/master/stetho-js-rhino</a><br><a href="https://www.figotan.org/2016/04/18/using-stetho-to-diagnose-data-on-android/" target="_blank" rel="external">https://www.figotan.org/2016/04/18/using-stetho-to-diagnose-data-on-android/</a><br><a href="https://developer.chrome.com/devtools/docs/remote-debugging-legacy" target="_blank" rel="external">https://developer.chrome.com/devtools/docs/remote-debugging-legacy</a><br><a href="https://android.googlesource.com/platform/system/core/+/master/adb/protocol.txt" target="_blank" rel="external">https://android.googlesource.com/platform/system/core/+/master/adb/protocol.txt</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://facebook.github.io/stetho/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;stetho&lt;/a&gt;是Facebook推出的安卓APP网络诊断和数据监控的工具，接入方便，功能强大，是开发者必备的好工具。&lt;
    
    </summary>
    
    
      <category term="工具" scheme="http://felixzhang00.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>simple-mock-api</title>
    <link href="http://felixzhang00.github.io/2017/01/01/simple-mock-api/"/>
    <id>http://felixzhang00.github.io/2017/01/01/simple-mock-api/</id>
    <published>2017-01-01T01:58:49.000Z</published>
    <updated>2017-01-01T02:26:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>项目中有一个Activiy需要轮询多个接口，实时刷新数据。这里很多业务逻辑都需要依赖当前的状态，所以简单写了一个服务端，用于生成一些mock data，并且支持数据实时刷新。</p>
<p>项目地址：<a href="https://github.com/FelixZhang00/simple-mock-api" target="_blank" rel="external">simple-mock-api</a></p>
<p>挂到<a href="https://www.qcloud.com/" target="_blank" rel="external">腾讯云</a>上就可以公网访问了。</p>
<hr>
<h1 id="simple-mock-api"><a href="#simple-mock-api" class="headerlink" title="simple-mock-api"></a>simple-mock-api</h1><p>Use <a href="https://github.com/typicode/json-server" target="_blank" rel="external">json-server</a> make this simple mock api server.</p>
<h2 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h2><ol>
<li>checkout this project,and cd</li>
<li>type <code>npm install</code> in terminal to install dependences</li>
<li>run <code>node app.js</code></li>
<li>get result via your configed cgi，like <a href="http://localhost:3000/get_match_players" target="_blank" rel="external">http://localhost:3000/get_match_players</a></li>
</ol>
<h2 id="Config"><a href="#Config" class="headerlink" title="Config"></a>Config</h2><p>You can config </p>
<pre><code>cgi，
default json file,
custom handle the request, modify json response
</code></pre><h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><p>Create a <code>get_match_detail.json</code> file in <code>data</code> folder.</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">"state"</span>: <span class="number">1</span>,</div><div class="line">  <span class="attr">"title"</span>:<span class="string">"NBA"</span>,</div><div class="line">  <span class="attr">"time"</span>:<span class="string">"2017-01-01"</span>,</div><div class="line">  <span class="attr">"homescore"</span>: <span class="string">"101"</span>,</div><div class="line">  <span class="attr">"guestscore"</span>: <span class="string">"115"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>In <code>config.js</code> config you mock api</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">var config = [</div><div class="line">&#123;</div><div class="line">	"cgi":"/get_match_detail",</div><div class="line">	"filepath":"data/get_match_detail.json",</div><div class="line">	"need_cache":true,</div><div class="line">	"hookfunc":func_get_match_detail</div><div class="line">&#125;,</div><div class="line">&#123;</div><div class="line">	"cgi":"/get_match_players",</div><div class="line">	"filepath":"data/get_match_players.json",</div><div class="line">	"need_cache":false,</div><div class="line">	"hookfunc":func_get_match_players</div><div class="line">&#125;,</div><div class="line"></div><div class="line">];</div></pre></td></tr></table></figure>
<p>You can custom handle the request by define your custom “hookfunc”, like this:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> func_get_match_detail = <span class="function"><span class="keyword">function</span>(<span class="params">defaultObj,req</span>) </span>&#123;</div><div class="line">	<span class="comment">//increase homescore every time</span></div><div class="line">	<span class="keyword">var</span> homescore = <span class="built_in">parseInt</span>(defaultObj.homescore)+<span class="number">1</span>+<span class="string">""</span>;</div><div class="line">	defaultObj.homescore = homescore;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>The param <code>defaultObj</code> means the parsed json object you defined in the key “filepath”. </p>
<p>If the key “need_cache” seted true, than your hookfunc can change the defaultObj in the cache forever.</p>
<h3 id="Start-JSON-Server"><a href="#Start-JSON-Server" class="headerlink" title="Start JSON Server"></a>Start JSON Server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ node app.js</div></pre></td></tr></table></figure>
<p>Now if you go to <a href="http://localhost:3000/get_match_detail" target="_blank" rel="external">http://localhost:3000/get_match_detail</a>, you’ll get</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">"state"</span>: <span class="number">1</span>,</div><div class="line">  <span class="attr">"title"</span>:<span class="string">"NBA"</span>,</div><div class="line">  <span class="attr">"time"</span>:<span class="string">"2017-01-01"</span>,</div><div class="line">  <span class="attr">"homescore"</span>: <span class="string">"102"</span>,</div><div class="line">  <span class="attr">"guestscore"</span>: <span class="string">"115"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>and the homescore’s value changed every time when you go to the same link.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;项目中有一个Activiy需要轮询多个接口，实时刷新数据。这里很多业务逻辑都需要依赖当前的状态，所以简单写了一个服务端，用于生成一些mock data，并且支持数据实时刷新。&lt;/p&gt;
&lt;p&gt;项目地址：&lt;a href=&quot;https://github.com/FelixZhan
    
    </summary>
    
      <category term="工具 nodejs" scheme="http://felixzhang00.github.io/categories/%E5%B7%A5%E5%85%B7-nodejs/"/>
    
    
      <category term="工具 nodejs" scheme="http://felixzhang00.github.io/tags/%E5%B7%A5%E5%85%B7-nodejs/"/>
    
  </entry>
  
  <entry>
    <title>使用TraceView工具定位耗时操作</title>
    <link href="http://felixzhang00.github.io/2016/12/27/2016-12-27-%E9%80%9A%E8%BF%87trace%E6%96%87%E4%BB%B6%E5%AE%9A%E4%BD%8D%E8%80%97%E6%97%B6%E6%93%8D%E4%BD%9C/"/>
    <id>http://felixzhang00.github.io/2016/12/27/2016-12-27-通过trace文件定位耗时操作/</id>
    <published>2016-12-27T12:29:25.000Z</published>
    <updated>2016-12-30T09:51:06.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://developer.android.com/studio/profile/traceview.html" target="_blank" rel="external">TraceView</a>是DDMS中的工具，可以用来定位Android app中java方法的耗时操作。</p>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><h3 id="1-生成trace文件"><a href="#1-生成trace文件" class="headerlink" title="1.生成trace文件"></a>1.生成trace文件</h3><p>Eclipse中生成trace文件的方法：<br><img src="http://ww4.sinaimg.cn/mw690/8b331ee1gw1fb5lfcb484j20zg0pmtf7.jpg" alt=""></p>
<p><br><br>Android Studio生成trace文件的方法:</p>
<p><img src="http://ww2.sinaimg.cn/large/8b331ee1gw1fb5lgu5dsmj21kw0fmgpk.jpg" alt=""></p>
<p>生成的trace文件将显示在Captures窗口</p>
<p><img src="http://ww2.sinaimg.cn/large/8b331ee1gw1fb5lx8hffej20a707jmxe.jpg" alt=""><br>直接把trace文件拖到安装了ADT插件的Eclipse就能打开。</p>
<h3 id="2-Timeline-Panel"><a href="#2-Timeline-Panel" class="headerlink" title="2.Timeline Panel"></a>2.Timeline Panel</h3><p>Timeline展示各个线程占用CPU的情况。<br>横轴为从开始到结束trace的CPU时间，右边纵轴表示各个线程，每一横排表示线程占用CPU的情况。这里主要看主线程main</p>
<p><img src="http://ww1.sinaimg.cn/large/8b331ee1gw1fb5lrgshrqj21kw07jtbu.jpg" alt=""></p>
<p>放大后的效果如图，每个method用不同的颜色表示，展示CPU调用该方法到结束调用的时间。</p>
<p><img src="http://ww1.sinaimg.cn/large/8b331ee1gw1fb5m32u3j6j21am0bcn0k.jpg" alt=""></p>
<h3 id="3-Profile-Panel"><a href="#3-Profile-Panel" class="headerlink" title="3.Profile Panel"></a>3.Profile Panel</h3><p>Profile Panel展示了方法全名，方法耗时，调用次数，及方法的调用链关系。<br>在这里调用方法称为”parent”,被调方法称为”children”.</p>
<p><img src="http://ww3.sinaimg.cn/large/8b331ee1gw1fb5mewco9uj21kw0ngtsb.jpg" alt=""></p>
<hr>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《High Performance Android Apps》</p>
<p><a href="https://developer.android.com/studio/profile/traceview.html" target="_blank" rel="external">https://developer.android.com/studio/profile/traceview.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://developer.android.com/studio/profile/traceview.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;TraceView&lt;/a&gt;是DDMS中的工具，可以用来定位Android
    
    </summary>
    
      <category term="工具 Android" scheme="http://felixzhang00.github.io/categories/%E5%B7%A5%E5%85%B7-Android/"/>
    
    
      <category term="工具 Android" scheme="http://felixzhang00.github.io/tags/%E5%B7%A5%E5%85%B7-Android/"/>
    
  </entry>
  
  <entry>
    <title>代码浏览工具OpenGrok</title>
    <link href="http://felixzhang00.github.io/2016/12/25/2016-12-25-%E4%BB%A3%E7%A0%81%E6%B5%8F%E8%A7%88%E5%B7%A5%E5%85%B7OpenGrok/"/>
    <id>http://felixzhang00.github.io/2016/12/25/2016-12-25-代码浏览工具OpenGrok/</id>
    <published>2016-12-25T03:38:22.000Z</published>
    <updated>2016-12-30T09:52:06.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://opengrok.github.io/OpenGrok/" target="_blank" rel="external">OpenGrok</a>是一款强大的跨平台代码阅读工具，许多在线源码查看网站都是使用它来搭建的，比如著名的Android在线源码查看网站<a href="http://androidxref.com/" target="_blank" rel="external">androidxref</a>.</p>
<p><br><br><br><br><br></p>
<h2 id="OpenGrok特性"><a href="#OpenGrok特性" class="headerlink" title="OpenGrok特性"></a>OpenGrok特性</h2><p>OpenGrok 提供如下特性：</p>
<ul>
<li><p>1.快速搜索代码的引擎</p>
<p>  搜索全文、定义、符号、文件路径和修改历史</p>
<p>  搜索任意指定子目录（分层搜索）</p>
<p>  增量更新索引文件</p>
</li>
<li><p>2.支持类似 Google 的查询语法，比如 path:Makefile defs:target</p>
<p>  搜索日期范围内修改的文件</p>
<p>  支持使用通配符搜索，如 * 表示多个字符，? 表示单个字符</p>
<p>  在搜索结果中展示匹配行</p>
</li>
<li><p>3.一个 Web 只读版的版本历史查看界面</p>
<p>  文件的修改日志</p>
<p>  文件在两个版本间的 diff</p>
<p>  文件夹的历史记录</p>
</li>
<li><p>4.带语法高亮的交叉引用显示，可以使用 CSS 自定义样式</p>
<p>  可以开发插件支持新的语言和版本控制系统</p>
<p>  已经支持的语言： <a href="https://link.zhihu.com/?target=https%3A//github.com/OpenGrok/OpenGrok/wiki/Supported-Languages-and-Formats" target="_blank" rel="external">Supported Languages and Formats</a></p>
<p>  已经支持的版本控制系统：<a href="https://link.zhihu.com/?target=https%3A//github.com/OpenGrok/OpenGrok/wiki/Supported-Revision-Control-Systems" target="_blank" rel="external">Supported Revision Control Systems</a></p>
</li>
</ul>
<p><br><br><br><br><br></p>
<h2 id="在macOS平台搭建OpenGrok"><a href="#在macOS平台搭建OpenGrok" class="headerlink" title="在macOS平台搭建OpenGrok"></a>在macOS平台搭建OpenGrok</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>1.安装tomcat</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ brew install tomcat</div></pre></td></tr></table></figure>
<p>2.安装ctags</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ brew install ctags</div></pre></td></tr></table></figure>
<p>3.安装OpenGrok</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ wget -O - http://java.net/projects/opengrok/downloads/download/opengrok-0.12.1.tar.gz | tar xvz</div></pre></td></tr></table></figure>
<h3 id="开启tomcat"><a href="#开启tomcat" class="headerlink" title="开启tomcat"></a>开启tomcat</h3><p>方法1：cd到tomcat所在目录，然后执行命令，<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ catalina start </div><div class="line">$ open http://localhost:8080/<span class="built_in">source</span></div></pre></td></tr></table></figure></p>
<p>方法2：下载macOS下的GUI程序<a href="https://www.macupdate.com/app/mac/18706/tomcat-controller" target="_blank" rel="external">TomcatController</a><br>配置tomcat所在目录。<br><img src="http://ww3.sinaimg.cn/large/8b331ee1gw1fb2vmdecmpj217c0i6gpb.jpg" alt=""></p>
<h3 id="开启openGrok项目"><a href="#开启openGrok项目" class="headerlink" title="开启openGrok项目"></a>开启openGrok项目</h3><p>openGrok其实就是一个webapp<br><img src="http://ww3.sinaimg.cn/large/8b331ee1gw1fb2vobc954j21kw09saf1.jpg" alt=""></p>
<h3 id="导入项目"><a href="#导入项目" class="headerlink" title="导入项目"></a>导入项目</h3><p>比如导入ffmpeg，在opengrok目录下创建一个local_src文件夹，把ffmpeg文件夹通过软引用的方式链到local_src下的src目录，这样就能让opengrok找到ffmpeg的代码了。<br><img src="http://ww2.sinaimg.cn/large/8b331ee1gw1fb2vt7txidj21kw0cx42c.jpg" alt=""></p>
<h3 id="建立索引"><a href="#建立索引" class="headerlink" title="建立索引"></a>建立索引</h3><p><img src="http://ww2.sinaimg.cn/large/8b331ee1gw1fb2vtrtcuwj216g03476a.jpg" alt=""></p>
<h3 id="打开浏览器"><a href="#打开浏览器" class="headerlink" title="打开浏览器"></a>打开浏览器</h3><p>访问 <a href="http://localhost:8080/source" target="_blank" rel="external">http://localhost:8080/source</a> 就能看到代码了。<br><img src="http://ww1.sinaimg.cn/large/8b331ee1gw1fb2vuwcxfej21gc0aw3zw.jpg" alt=""></p>
<p><img src="http://ww2.sinaimg.cn/large/8b331ee1gw1fb2vv6s7voj21kw1d3aoa.jpg" alt=""></p>
<hr>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://blog.simplypatrick.com/2015/01/16/opengrok-on-mac-osx/" target="_blank" rel="external">http://blog.simplypatrick.com/2015/01/16/opengrok-on-mac-osx/</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/24369747" target="_blank" rel="external">https://zhuanlan.zhihu.com/p/24369747</a></p>
<p><a href="https://github.com/OpenGrok/OpenGrok/wiki/Features" target="_blank" rel="external">https://github.com/OpenGrok/OpenGrok/wiki/Features</a></p>
<p><a href="http://bytesthink.com/blog/?p=184" target="_blank" rel="external">http://bytesthink.com/blog/?p=184</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://opengrok.github.io/OpenGrok/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;OpenGrok&lt;/a&gt;是一款强大的跨平台代码阅读工具，许多在线源码查看网站都是使用它来搭建的，比如著名的Androi
    
    </summary>
    
      <category term="工具" scheme="http://felixzhang00.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="http://felixzhang00.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>ELF文件装载链接过程及hook原理</title>
    <link href="http://felixzhang00.github.io/2016/12/24/2016-12-24-ELF%E6%96%87%E4%BB%B6%E8%A3%85%E8%BD%BD%E9%93%BE%E6%8E%A5%E8%BF%87%E7%A8%8B%E5%8F%8Ahook%E5%8E%9F%E7%90%86/"/>
    <id>http://felixzhang00.github.io/2016/12/24/2016-12-24-ELF文件装载链接过程及hook原理/</id>
    <published>2016-12-24T14:35:04.000Z</published>
    <updated>2016-12-30T09:52:26.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ELF文件格式解析"><a href="#ELF文件格式解析" class="headerlink" title="ELF文件格式解析"></a>ELF文件格式解析</h2><p>可执行和可链接格式(Executable and Linkable Format，缩写为ELF)，常被称为ELF格式，在计算机科学中，是一种用于执行档、目的档、共享库和核心转储的标准文件格式。</p>
<p>ELF文件主要有四种类型：</p>
<ul>
<li>可重定位文件（Relocatable File） 包含适合于与其他目标文件链接来创建可执行文件或者共享目标文件的代码和数据。</li>
<li>可执行文件（Executable File） 包含适合于执行的一个程序，此文件规定了 exec() 如何创建一个程序的进程映像。</li>
<li>共享目标文件（Shared Object File） 包含可在两种上下文中链接的代码和数据。首先链接编辑器可以将它和其它可重定位文件和共享目标文件一起处理，生成另外一个目标文件。其次，动态链接器（Dynamic Linker）可能将它与某个可执行文件以及其它共享目标一起组合，创建进程映像。</li>
</ul>
<p>以一个简单的目标文件为例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">int global_init_var = 84;</div><div class="line">int global_uninit_var;</div><div class="line">void func1(int i)</div><div class="line">&#123;</div><div class="line">    printf(&quot;%d\n&quot;,i);</div><div class="line">&#125;</div><div class="line">int main(void)</div><div class="line">&#123;</div><div class="line">    char *str = &quot;hello&quot;;</div><div class="line">    static int static_var = 85;</div><div class="line">    static int static_var2;</div><div class="line">    int a = 1;</div><div class="line">    int b;</div><div class="line">    func1(static_var + static_var2 + a + b);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gcc -c SimpleSection.c</div></pre></td></tr></table></figure>
<h3 id="ELF文件结构"><a href="#ELF文件结构" class="headerlink" title="ELF文件结构"></a>ELF文件结构</h3><p><img src="http://ww2.sinaimg.cn/mw690/8b331ee1gw1f92kqr2mfoj20ty14k76x.jpg" alt="ELF文件结构"></p>
<h3 id="链接视图和执行视图"><a href="#链接视图和执行视图" class="headerlink" title="链接视图和执行视图"></a>链接视图和执行视图</h3><p>ELF文件在磁盘中和被加载到内存中并不是完全一样的，ELF文件提供了两种视图来反映这两种情况:链接视图和执行视图。顾名思义，链接视图就是在链接时用到的视图，而执行视图则是在执行时用到的视图。<br><img src="http://ww4.sinaimg.cn/mw690/8b331ee1gw1f92kvnpkstj20bz06fwf8.jpg" alt="链接视图和执行视图"></p>
<p>程序头部表(Program Header Table)，如果存在的话，告诉系统如何创建进程映像。<br>节区头部表(Section Header Table)包含了描述文件节区的信息，比如大小，偏移等。</p>
<h3 id="ELF文件头（ELF-Header）"><a href="#ELF文件头（ELF-Header）" class="headerlink" title="ELF文件头（ELF Header）"></a>ELF文件头（ELF Header）</h3><p>定义了ELF魔数、硬件平台等、<br>入口地址、程序头入口和长度、<br>段表的位置和长度及段的数量、<br>段表字符串表（.shstrtab）所在的段在段表中的下标。</p>
<p>可以在”/usr/include/elf.h”中找到它的定义（Elf32_Ehdr）。<br>ELF各个字段的说明:</p>
<p><img src="http://ww2.sinaimg.cn/mw690/8b331ee1gw1f92kwlnz2ej20ht0snqbv.jpg" alt=""></p>
<h3 id="段表-Section-Header-Table"><a href="#段表-Section-Header-Table" class="headerlink" title="段表(Section Header Table)"></a>段表(Section Header Table)</h3><p>描述了各个段的信息，比如每个段的段名、段的长度、在文件中的偏移、读写权限及段的其它属性。<br>段表的结构是一个以Elf32_Shdr结构体（段描述符）为元素的数组。<br>每个Elf32_Shdr结构体对应一个段。<br>使用readelf工具查看ELF文件的段:<br><img src="http://ww4.sinaimg.cn/mw690/8b331ee1gw1f92kx9tdv3j21kw0sfak2.jpg" alt=""></p>
<p><strong>段描述符（Elf32_Shdr）</strong>的各个成员及含义：<br><img src="http://ww4.sinaimg.cn/large/8b331ee1gw1f92kyt2f0gj21kw1oq4j0.jpg" alt=""></p>
<p><strong>段的类型(sh_type)</strong><br>对于编译器和链接器，主要决定段的属性的是段的类型(sh_type)和段的标志位(shflags)。段的类型相关常量以SHT开头，列举如下表。<br><img src="http://ww3.sinaimg.cn/large/8b331ee1gw1f92l0g93grj20k80bg0vq.jpg" alt=""></p>
<p><strong>段的标志位(sh<em>flag)</em></strong>表示该节在进程虚拟地址空间中的属性，比如是否可写，是否可执行等。相关常量以SHF开头，如下表：<br><img src="http://ww1.sinaimg.cn/large/8b331ee1gw1f92l38ufjqj20k504sjsn.jpg" alt=""></p>
<p><strong>段的链接信息(sh_link、sh_info)</strong> 如果节的类型是和链接相关的，比如重定位表、符号表等，那么sh_link和sh_info两个成员包含的意义如下。对于其他段，这两个成员没有意义。<br><img src="http://ww4.sinaimg.cn/large/8b331ee1gw1f92l3seot7j20kd06babi.jpg" alt=""></p>
<h3 id="代码段-text"><a href="#代码段-text" class="headerlink" title="代码段(.text)"></a>代码段(.text)</h3><p>使用objdump工具查看代码段的内容，”-d”参数将所有包含指令的段反汇编。<br><img src="http://ww1.sinaimg.cn/mw690/8b331ee1gw1f92l64fa4ej21b41q2114.jpg" alt=""></p>
<h3 id="数据段-data-和只读数据段-rodata"><a href="#数据段-data-和只读数据段-rodata" class="headerlink" title="数据段(.data)和只读数据段(.rodata)"></a>数据段(.data)和只读数据段(.rodata)</h3><p>.data段保存的是那些已经初始化了的全局静态变量和局部静态变量。前面SimpleSection.c代码里面一共有两个这样的变量，都是int类型的，一共刚好8字节。<br>在SimpleSection.c里在调用”printf”的时候，用到了一个字符串常量”%d\n”,它是一种只读数据，所以被放到了”.rodata”段。<br><img src="http://ww2.sinaimg.cn/mw690/8b331ee1gw1f92l6sfdb3j21ei0kmmzk.jpg" alt=""></p>
<h3 id="BSS段-bss"><a href="#BSS段-bss" class="headerlink" title="BSS段(.bss)"></a>BSS段(.bss)</h3><p>.bss段存放的未初始化的全局变量和局部静态变量。.bss段不占磁盘空间。<br><img src="http://ww4.sinaimg.cn/mw690/8b331ee1gw1f92l7ea9guj21eo0ao0ti.jpg" alt=""></p>
<h3 id="字符串表（-strtab）"><a href="#字符串表（-strtab）" class="headerlink" title="字符串表（.strtab）"></a>字符串表（.strtab）</h3><p>在ELF文件中，会用到很多字符串，比如节名，变量名等。所以ELF将所有的字符串集中放到一个表里，每一个字符串以’\0’分隔，然后使用字符串在表中的偏移来引用字符串。<br>比如下面这样：<br><img src="http://ww2.sinaimg.cn/mw690/8b331ee1gw1f92l7t2tyrj20k903fgm5.jpg" alt=""><br>那么偏移与他们对用的字符串如下表:<br><img src="http://ww2.sinaimg.cn/mw690/8b331ee1gw1f92l81n2y1j20k7043jrs.jpg" alt=""><br>这样在ELF中引用字符串只需要给出一个数组下标即可。字符串表在ELF也以段的形式保存，常见的段名为”.strtab”或”.shstrtab”。这两个字符串表分别为字符串表(String Table)和段表字符串表(Header String Table)，字符串表保存的是普通的字符串，而段表字符串表用来保存段表中用到的字符串，比如段名。</p>
<h3 id="符号表（-symtab）"><a href="#符号表（-symtab）" class="headerlink" title="符号表（.symtab）"></a>符号表（.symtab）</h3><p>在链接的过程中需要把多个不同的目标文件合并在一起，不同的目标文件相互之间会引用变量和函数。在链接过程中，我们将函数和变量统称为符号，函数名和变量名就是符号名。<br>每一个目标文件中都有一个相应的符号表(System Table)，这个表里纪录了目标文件所用到的所有符号。每个定义的符号都有一个相应的值，叫做符号值(Symbol Value)，对于变量和函数，符号值就是它们的地址。<br>符号表是一个Elf32_Sym(32位)的数组，每个Elf32_Sym对应一个符号。这个数组的第一个元素，也就是下标为0的元素为无效的”未定义”符号。<br>他们的定义如下：<br><img src="http://ww1.sinaimg.cn/mw690/8b331ee1gw1f92l8p5639j20ku06t768.jpg" alt=""></p>
<p><strong>符号类型和绑定信息(st_info)</strong><br>该成员的低4位标识符号的类型(Symbol Type)，高28位标识符号绑定信息(Symbol Binding)，如下表所示。<br><img src="http://ww2.sinaimg.cn/mw690/8b331ee1gw1f92l9hsyp1j20kf04rwf9.jpg" alt=""><br><img src="http://ww2.sinaimg.cn/mw690/8b331ee1gw1f92l9o0v6dj20k907575x.jpg" alt=""><br><strong>符号所在段(st_shndx)</strong><br>如果符号定义在本目标文件中，那么这个成员表示符号所在段在段表中的下表，但是如果符号不是定义在本目标文件中，或者对于有些特殊符号，sh_shndx的值有些特殊。如下：<br><img src="http://ww3.sinaimg.cn/mw690/8b331ee1gw1f92la2n675j20kk07dq4r.jpg" alt=""></p>
<p><strong>符号值(st_value)</strong><br>每个符号都有一个对应的值。主要分下面几种情况：</p>
<ul>
<li>如果符号不是”COMMON”类型的(即st_shndx不为SHN_COMMON)，则st_value表示该符号在段中的偏移，即符号所对应的函数或变量位于由st_shndx指定的段，偏移st_value的位置。比如SimpleSection中的”func1”，”main”和”global_init_var”。</li>
<li>在目标文件中，如果符号是”COMMON”类型(即st_shndx为SHN_COMMON)，则st_value表示该符号的对齐属性。比如SimleSection中的”global_uninit_var”。</li>
<li>在可执行文件中，st_value表示符号的虚拟地址。</li>
</ul>
<p>下图为使用readelf工具来查看ELF文件的符号:<br><img src="http://ww3.sinaimg.cn/mw690/8b331ee1gw1f92lb4pncvj21jm0rgtea.jpg" alt=""><br>比如，Num13行指的是符号表中的第13个元素，符号名为main，它是函数类型，定义在第一个段（即.text段）的第001b偏移处，大小为64字节。</p>
<h3 id="重定位表-rel-text"><a href="#重定位表-rel-text" class="headerlink" title="重定位表(.rel.text)"></a>重定位表(.rel.text)</h3><p>SimpleSection.o中有一个叫”.rel.text”的段，它的类型(sh_type)为”SHT_REL”，也就是说它是一个重定位表。链接器在处理目标文件时，需要对目标文件中的某些部位进行重定位，即代码段和数据中中那些绝对地址引用的位置。对于每个需要重定位的代码段或数据段，都会有一个相应的重定位表。比如”.rel.text”就是针对”.text”的重定位表，”.rel.data”就是针对”.data”的重定位表。</p>
<hr>
<h2 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h2><p>这节以下面两个文件为例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">/* a.c */</div><div class="line">extern int shared;</div><div class="line">int main()&#123;</div><div class="line">    int a = 100;</div><div class="line">    swap(&amp;a,&amp;shared);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">/* b.c */</div><div class="line">int shared = 1;</div><div class="line">void swap(int* a, int* b)&#123;</div><div class="line">    *a ^= *b ^= *a ^= *b;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当我们有两个目标文件时，如何将他们链接起来形成一个可执行文件？<br>对于多个输入目标文件，链接器如何将它们的各个段合并到输出文件？输出文件中的空间如何更配给输入文件？<br>下图为现在链接器采用的空间分配策略。<br><img src="http://ww1.sinaimg.cn/mw690/8b331ee1gw1f92lhyc2ugj2124138dkb.jpg" alt=""></p>
<p>整个链接过程分两步：</p>
<ul>
<li>第一步 空间与地址分配 扫描所有的输入目标文件，并且获得它们的各个段的长度、属性和位置，并且将输入目标文件中的符号表中所有的符号定义和符号引用收集起来，统一放到一个全局符号表中。</li>
<li>第二步 符号解析与重定位 使用第一步中收集到的信息，读取输入文件中段的数据、重定位信息，并且进行符号解析与重定位、调整代码中的地址等</li>
</ul>
<p>使用ld链接器将”a.o”和”b.o”链接起来：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ld a.o b.o -e main -o ab</div></pre></td></tr></table></figure></p>
<p>查看链接前后各个段的属性<br><img src="http://ww4.sinaimg.cn/mw690/8b331ee1gw1f92ljdpqkgj21b418244f.jpg" alt=""><br>VMA表示虚拟地址，LMA表示加载地址，正常情况下这两个值应该一样。</p>
<p>整个链接过程前后，目标文件各段的分配、程序虚拟地址:<br><img src="http://ww1.sinaimg.cn/mw690/8b331ee1gw1f92ljxvmqmj21hq10ygo3.jpg" alt=""><br>在Linux下，ELF可执行未见默认从地址0x08048000开始分配。</p>
<h3 id="符号解析与重定位"><a href="#符号解析与重定位" class="headerlink" title="符号解析与重定位"></a>符号解析与重定位</h3><p>编译器在将”a.c”编译成指令时，它如何访问”shared”变量？如何调用”swap”函数？<br><strong>重定位表(Relocation Tabel)</strong>专门用来保存与重定位相关的信息，链接器根据它知道哪些指令时要被调整的，以及如何调整。<br>对于32位的Intel x86系列处理器来说，重定位表的结构是一个Elf_32Rel结构的数组，每个数组元素对应一个重定位入口。定义如下：<br><img src="http://ww4.sinaimg.cn/mw690/8b331ee1gw1f92lm64qwqj21j00kwtec.jpg" alt=""></p>
<p>可以使用objdump来查看目标文件的重定位表：<br><img src="http://ww4.sinaimg.cn/mw690/8b331ee1gw1f92lmerm9rj20oa0bu3za.jpg" alt=""></p>
<p>将”a.o”的代码段反汇编可以看到，此时编译器并不知道“shared”的地址，暂时把地址0看做”shared”的地址。<br>0xE8是一条近址相对位移调用指令，后面4个字节就是被调用函数的相对于调用指令的下一条指令的偏移量。<br>此处”swap”函数的地址是0x2b-4=0x27,可以看出0xfffffffc也是一个临时地址。<br><img src="http://ww2.sinaimg.cn/mw690/8b331ee1gw1f92lmrq7o2j21900yagpl.jpg" alt=""></p>
<p><strong>指令修正方式</strong><br><img src="http://ww3.sinaimg.cn/mw690/8b331ee1gw1f92lngo4gzj21iu0fsjuq.jpg" alt=""></p>
<p>指令修复的结果<br><img src="http://ww2.sinaimg.cn/mw690/8b331ee1gw1f92lnnaqsej21d411ydlb.jpg" alt=""></p>
<hr>
<h2 id="可执行文件的装载与进程"><a href="#可执行文件的装载与进程" class="headerlink" title="可执行文件的装载与进程"></a>可执行文件的装载与进程</h2><p>程序执行时所需要的指令和数据必需在内存中才能够正常运行。<br>页映射将内存和所有磁盘中的数据和指令按照“页（Page）”为单位划分成若干个页，以后所有的装载和操作的单位就是页。</p>
<p>进程的建立需要做下面三件事情：</p>
<ul>
<li>创建一个独立的虚拟地址空间</li>
<li>读取可执行文件头，并且建立虚拟空间与可执行文件的映射关系。</li>
<li>将CPU的指令寄存器设置成可执行文件的入口地址，启动运行。</li>
</ul>
<p>对于第2步，当操作系统捕获到缺页错误时，它应该知道程序当前所需的页在可执行文件中的哪一个位置。<br>这种映射关系是保存在操作系统内部的一个数据结构<strong>VMA</strong>。<br>例如下图中，操作系统创建进程后，会在进程相应的数据结构中设置有一个.text段的VMA：它在虚拟空间中的地址为0x08048000~0x08049000，它对应ELF文件中偏移为0的.text，它的属性为只读，还有一些其他的属性。<br><img src="http://ww4.sinaimg.cn/mw690/8b331ee1gw1f92lokbzk3j20wi0lo0u7.jpg" alt=""></p>
<p><strong>页错误</strong><br>在上面的例子中，程序的入口地址为0x08048000，当CPU开始打算执行这个地址的指令时，发现页面0x08048000~0x08049000（虚拟地址）是个空页面，于是它就认为这是一个页错误。CPU将控制权交给操作系统，操作系统将查询虚拟空间与可执行文件的映射关系表，找到空页面所在的VMA，计算相应的页面在可执行文件中的偏移，然后在物理内存中分配一个物理页面，将进程中该虚拟页与分配的物理页之间建立映射关系，然后把控制权再还给进程，进程从刚才页错误的位置重新开始执行。</p>
<h3 id="链接视图和执行视图-1"><a href="#链接视图和执行视图-1" class="headerlink" title="链接视图和执行视图"></a>链接视图和执行视图</h3><p>以下面的程序为例。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">使用静态链接的方式将其编译成可执行文件：</div><div class="line">$gcc -static SectionMapping.c -o SectionMapping.elf</div><div class="line">**/</div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</div><div class="line">    &#123;</div><div class="line">        sleep(<span class="number">1000</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>下面的elf文件被重新划分成了三个部分，有一些段被归入可读可执行的，他们被统一映射到一个CODE VMA；另一部分段是可读可写的，它们被映射到了DATA VMA；还有一些段在程序执行时没有用，所以不需要映射。<br>ELF与Linux进程虚拟空间映射关系（一个常见进程的虚拟空间）如下图。<br><img src="http://ww2.sinaimg.cn/mw690/8b331ee1gw1f92lpqlsm9j212y1fkaem.jpg" alt=""></p>
<h4 id="程序头表-Program-Header-Table"><a href="#程序头表-Program-Header-Table" class="headerlink" title="程序头表(Program Header Table)"></a>程序头表(Program Header Table)</h4><p>用来保存“Segment”的信息,描述了ELF文件该如何被操作系统映射到虚拟空间。因为ELF目标文件不需要被装载，所以它没有程序头表，而ELF的可执行文件和共享库文件都有。<br>使用readelf查看程序头表。<br><img src="http://ww1.sinaimg.cn/mw690/8b331ee1gw1f92lreiga6j21380me0x3.jpg" alt=""></p>
<p>跟段表结构一样，程序头表也是一个结构体数组，其结构体用Elf32_Phdr表示。<br>下表是Elf32_Phdr结构的各个成员的基本含义。<br><img src="http://ww2.sinaimg.cn/mw690/8b331ee1gw1f92lrncz74j21jw0vwgtx.jpg" alt=""></p>
<h3 id="堆和栈"><a href="#堆和栈" class="headerlink" title="堆和栈"></a>堆和栈</h3><p>VMA除了被用来映射可执行文件中的各个”segment”以外，操作系统通过使用VMA来对进程的地址空间进行管理，包括堆和栈。<br>在Linux下，可以通过查看”/proc”来查看进程的虚拟空间分布：<br><img src="http://ww4.sinaimg.cn/mw690/8b331ee1gw1f92ltj5czaj21120hkwi3.jpg" alt=""><br>我们可以看到进程中有5个VMA,只有前两个是映射到可执行文件中的两个Segment。另外三个段的文件所在设备主设备号及文件节点号都是0，则表示他们没有映射到文件中，这种VMA叫做匿名虚拟内存区域。另外有一个很特殊的VMA叫“vdso”，它的地址已经位于内核空间了（即大于0xC0000000的地址），事实上它是一个内核的模块，进程可以通过访问这个VMA来跟内核进行一些通信。<br>操作系统通过给进程空间划分出一个个VMA来管理进程的虚拟空间；基本原则是将相同权限属性的、有相同映像文件的映射成一个VMA。</p>
<hr>
<h2 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h2><p>以下面的代码为例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">/* Lib.h */</div><div class="line">#ifndef LIB_H</div><div class="line">#define LIB_H</div><div class="line">void foobar(int i);</div><div class="line">#endif</div><div class="line"></div><div class="line">/* Lib.c */</div><div class="line">#include &lt;stdio.h&gt;</div><div class="line">void foobar(int i)&#123;</div><div class="line">    printf(&quot;Printing from Lib.so %d\n&quot;,i);</div><div class="line">    sleep(-1);</div><div class="line">&#125;</div><div class="line"></div><div class="line">/* Program1.c */</div><div class="line">#include &quot;Lib.h&quot;</div><div class="line">int main()&#123;</div><div class="line">    foobar(1);</div><div class="line">    return;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/* Program2.c */</div><div class="line">#include &quot;Lib.h&quot;</div><div class="line">int main()&#123;</div><div class="line">    foobar(2);</div><div class="line">    return;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>将Lib.c编译成一个共享对象文件：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$gcc</span> <span class="_">-f</span>PIC -shared -o Lib.so Lib.c</div></pre></td></tr></table></figure>
<p>分别编译链接Program1.c和Program2.c：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$gcc</span> -o Program1 Program1.c ./Lib.so</div></pre></td></tr></table></figure></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$gcc</span> -o Program2 Program2.c ./Lib.so</div></pre></td></tr></table></figure>
<p>查看进程的虚拟地址空间分布：<br><img src="http://ww4.sinaimg.cn/mw690/8b331ee1gw1f92lywp140j20zm0n0grl.jpg" alt=""><br>上图中的ld-2.6.so实际上是Linux下的动态链接器，它与普通共享对象一样被映射到了进程的地址空间，在系统开始运行program1之前，首先会把控制权交给动态链接器，由它完成所有的动态链接工作以后再把控制权交给program1,然后开始执行。</p>
<p>通过readelf查看Lib.so的装载属性：<br><img src="http://ww1.sinaimg.cn/mw690/8b331ee1gw1f9320c9v7lj214q0q8776.jpg" alt=""><br>与普通程序不同的是，动态链接模块的装载地址是从地址0x00000000开始的，这个地址是无效的，共享对象的最终装载地址在编译时时不确定的，而是在装载时，装载器根据当前地址空间的空前情况，动态分配一块足够大小的虚拟地址空间给相应的共享对象。</p>
<h3 id="地址无关代码-PIC"><a href="#地址无关代码-PIC" class="headerlink" title="地址无关代码(PIC)"></a>地址无关代码(PIC)</h3><p>装载时重定位是解决动态模块中有绝对地址引用的方法之一，但是它有一个很大的缺点是指令部分无法在多个进程之间共享，这样就失去了动态链接节省内存的一大优势。我们还需要有一种更好的方法解决共享对象指令中对绝对地址的重定位问题。其实我们的目的很简单，希望程序模块中共享的指令部分在装载时不需要因为装载地址的改变而改变，所以实现的基本思想就是把指令中那些需要被修改的部分分离出来，跟数据部分放在一起，这样指令部分就可以保持不变，而数据部分可以在每个进程中拥有一个副本。</p>
<p>模块中各种类型的地址引用方式如下图：<br><img src="http://ww3.sinaimg.cn/mw690/8b331ee1gw1f9321f0xmjj20hg0go76x.jpg" alt=""></p>
<h4 id="全局偏移表-GOT"><a href="#全局偏移表-GOT" class="headerlink" title="全局偏移表(GOT)"></a>全局偏移表(GOT)</h4><p>用于模块间数据访问，在数据段里建立一个指向外部模块变量的指针数组。当代码需要引用该全局变量时，可以通过GOT中相对用的项间接引用，它的基本机制如下图。<br><img src="http://ww2.sinaimg.cn/mw690/8b331ee1gw1f9321to16sj214w10qwgd.jpg" alt=""><br>当指令中需要访问变量b时，程序会先找到GOT，然后根据GOT中变量所对应的项找到变量的目标地址。每个变量都对应一个4字节的地址，链接器在装载模块的时候会查找每个变量所在的地址，然后填充GOT中的各个项，以确保每个指针所指向的地址正确。由于GOT本身是放在数据段的，所以它可以在模块装载时被修改，并且每个进程都可以有独立的副本，相互不受影响。</p>
<h4 id="延迟绑定-PLT"><a href="#延迟绑定-PLT" class="headerlink" title="延迟绑定(PLT)"></a>延迟绑定(PLT)</h4><p>动态链接下对于全局和静态的数据访问都要进行复杂的GOT定位，然后间接寻址；对于模块间的调用也要先定位GOT，然后再进行间接跳转。程序开始执行时，动态链接器都要进行一次链接工作，会寻找并装载所需的共享对象，然后进行符号查找地址重定位等工作，如此一来，程序的运行速度必定会减慢。</p>
<p>延迟绑定的实现<br>函数第一次被用到时才进行绑定（符号查找、重定位等），如果没有用到则不进行绑定。</p>
<p>GOT 位于 .got.plt section 中，而 PLT 位于 .plt section中。<br>GOT 保存了程序中所要调用的函数的地址，运行一开时其表项为空，会在运行时实时的更新表项。一个符号调用在第一次时会解析出绝对地址更新到 GOT 中，第二次调用时就直接找到 GOT 表项所存储的函数地址直接调用了。<br>printf（）函数的调用过程如下图<br><img src="http://ww3.sinaimg.cn/mw690/8b331ee1gw1f9322tt0r1j20le0dhjss.jpg" alt=""></p>
<h3 id="动态链接的相关结构"><a href="#动态链接的相关结构" class="headerlink" title="动态链接的相关结构"></a>动态链接的相关结构</h3><h4 id="interp段"><a href="#interp段" class="headerlink" title=".interp段"></a>.interp段</h4><p>在动态链接的ELF可执行文件中，有一个专门的段叫做”.interp”段。里面保存的是一个字符串，记录所需动态链接器的路径。<br>从下图可以看出，Android用的动态链接器是linker<br><img src="http://ww1.sinaimg.cn/mw690/8b331ee1gw1f9323mnszoj21j805itco.jpg" alt=""></p>
<h4 id="dynamic段"><a href="#dynamic段" class="headerlink" title=".dynamic段"></a>.dynamic段</h4><p>这个段里保存了动态链接器所需要的基本信息，比如依赖哪些共享对象、动态链接符号表的位置、动态链接重定位表的位置、共享对象初始化代码的地址等。<br>.dynamic段里保存的信息有点像ELF文件头。<br>.dynamic段的结构是由Elf32_Dyn组成的数组。<br>Elf32_Dyn结构由一个类型值加上一个附加的数值或指针，对于不同的类型，后面附加的数值或者指针有着不同的含义。<br><img src="http://ww3.sinaimg.cn/mw690/8b331ee1gw1f932414wnzj21ii0syq9p.jpg" alt=""></p>
<h4 id="动态符号表-dynsym"><a href="#动态符号表-dynsym" class="headerlink" title="动态符号表(.dynsym)"></a>动态符号表(.dynsym)</h4><p>为了表示动态链接模块之间的符号导入导出关系，ELF专门有一个叫做动态符号表的段用来保存这些信息。<br>与”.symtab”不同的是，”.dynsym”只保存了与动态链接相关的符号，对于那些模块内部的符号，比如模块私有变量则不保存。很多时候动态链接模块同时拥有”.dynsym”和”.symtab”两个表，”.symtab”中往往保存了所有符号，包括”.dynsym”中的符号。</p>
<h4 id="动态符号字符串表-dynstr"><a href="#动态符号字符串表-dynstr" class="headerlink" title="动态符号字符串表(.dynstr)"></a>动态符号字符串表(.dynstr)</h4><p>在动态链接时用于保存符号名的字符串表。</p>
<h4 id="符号哈希表-hash"><a href="#符号哈希表-hash" class="headerlink" title="符号哈希表(.hash)"></a>符号哈希表(.hash)</h4><p>由于动态链接下，需要在程序运行时查找符号，为了加快符号的查找过程，往往还有辅助的符号好戏表。<br>用readelf查看elf文件的动态符号表及它的哈希表。<br><img src="http://ww3.sinaimg.cn/mw690/8b331ee1gw1f9324ovvklj211g0n6af4.jpg" alt=""></p>
<h3 id="动态链接重定位表"><a href="#动态链接重定位表" class="headerlink" title="动态链接重定位表"></a>动态链接重定位表</h3><p>在动态链接中，导入符号的地址在运行时才确定，所以需要在运行时将这些导入符号的引用修正，即需要重定位。</p>
<p>“.rel.dyn”段对数据引用的修正，它所修正的位置位于”.got”以及数据段；<br>“.rel.plt”段对函数引用修正，它所修正的位置位于”.got.plt”。<br>用readelf来查看一个动态链接的文件的重定位表：<br><img src="http://ww3.sinaimg.cn/mw690/8b331ee1gw1f93258e2hrj21i00ue7a1.jpg" alt=""><br>R_386_JUMP_SLOT和R_386_GLOB_DAT这两个类型的重定位入口表示，被修正的位置只需要直接填入符号地址即可。<br>比如，printf这个重定位入口，它的类型为R_386_JUMP_SLOT，它的偏移为0x000015d8，它位于”.got.plt”中，下图为其结构。<br><img src="http://ww2.sinaimg.cn/mw690/8b331ee1gw1f9325hfyr7j213q0zitfq.jpg" alt=""><br>当链接器需要进行重定位时，它先查找”printf”的地址，“printf”位于libc.so中。假设链接器在全局符号表里面找到”printf”的地址为0x08801234,那么链接器就会将这个地址填入到”.got.plt”中偏移为0x000015d8的位置中去，从而实现了地址的重定位。<br>R_386_GLOB_DAT是对”.got”的重定位，它跟R_386_JUMP_SLOT的做法一样。</p>
<hr>
<h2 id="hook方案的一种实现方案"><a href="#hook方案的一种实现方案" class="headerlink" title="hook方案的一种实现方案"></a>hook方案的一种实现方案</h2><p>具体实现来自Andrey Petrov的<a href="http://shadowwhowalks.blogspot.com/2013/01/android-hacking-hooking-system.html" target="_blank" rel="external">blog</a>. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line">#include &quot;linker.h&quot;  // get it from bionic</div><div class="line">static unsigned elfhash(const char *_name)  </div><div class="line">&#123;  </div><div class="line">  const unsigned char *name = (const unsigned char *) _name;  </div><div class="line">  unsigned h = 0, g;  </div><div class="line">  while(*name) &#123;  </div><div class="line">    h = (h &lt;&lt; 4) + *name++;  </div><div class="line">    g = h &amp; 0xf0000000;  </div><div class="line">    h ^= g;  </div><div class="line">    h ^= g &gt;&gt; 24;  </div><div class="line">  &#125;  </div><div class="line">  return h;  </div><div class="line">&#125;  </div><div class="line">static Elf32_Sym *soinfo_elf_lookup(soinfo *si, unsigned hash, const char *name)  </div><div class="line">&#123;  </div><div class="line">  Elf32_Sym *s;  </div><div class="line">  Elf32_Sym *symtab = si-&gt;symtab;  </div><div class="line">  const char *strtab = si-&gt;strtab;  </div><div class="line">  unsigned n;  </div><div class="line">  n = hash % si-&gt;nbucket;  </div><div class="line">  for(n = si-&gt;bucket[hash % si-&gt;nbucket]; n != 0; n = si-&gt;chain[n])&#123;  </div><div class="line">    s = symtab + n;  </div><div class="line">    if(strcmp(strtab + s-&gt;st_name, name)) continue;  </div><div class="line">      return s;  </div><div class="line">    &#125;  </div><div class="line">  return NULL;  </div><div class="line">&#125;  </div><div class="line"></div><div class="line">int hook_call(char *soname, char *symbol, unsigned newval) &#123;  </div><div class="line"> soinfo *si = NULL;  </div><div class="line"> Elf32_Rel *rel = NULL;  </div><div class="line"> Elf32_Sym *s = NULL;   </div><div class="line"> unsigned int sym_offset = 0;  </div><div class="line"> if (!soname || !symbol || !newval)  </div><div class="line">    return 0;  </div><div class="line"> si = (soinfo*) dlopen(soname, 0);  </div><div class="line"> if (!si)  </div><div class="line">  return 0;  </div><div class="line"> s = soinfo_elf_lookup(si, elfhash(symbol), symbol);  </div><div class="line"> if (!s)  </div><div class="line">   return 0;  </div><div class="line"> sym_offset = s - si-&gt;symtab;  </div><div class="line"> rel = si-&gt;plt_rel;  </div><div class="line"> /* walk through reloc table, find symbol index matching one we&apos;ve got */  </div><div class="line"> for (int i = 0; i &lt; si-&gt;plt_rel_count; i++, rel++) &#123;  </div><div class="line">  unsigned type = ELF32_R_TYPE(rel-&gt;r_info);  </div><div class="line">  unsigned sym = ELF32_R_SYM(rel-&gt;r_info);  </div><div class="line">  unsigned reloc = (unsigned)(rel-&gt;r_offset + si-&gt;base);  </div><div class="line">  unsigned oldval = 0;  </div><div class="line">  if (sym_offset == sym) &#123;  </div><div class="line">   switch(type) &#123;  </div><div class="line">     case R_ARM_JUMP_SLOT:  </div><div class="line">        /* we do not have to read original value, but it would be good   </div><div class="line">          idea to make sure it contains what we are looking for */  </div><div class="line">        oldval = *(unsigned*) reloc;  </div><div class="line">        *((unsigned*)reloc) = newval;  </div><div class="line">        return 1;  </div><div class="line">     default:  </div><div class="line">        return 0;  </div><div class="line">   &#125;  </div><div class="line">  &#125;  </div><div class="line"> &#125;  </div><div class="line"> return 0;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>用法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hook_call(&quot;libandroid_runtime.so&quot;, &quot;connect&quot;, &amp;my_connect);</div></pre></td></tr></table></figure></p>
<p>1.调用dlopen拿到so的句柄,得到soinfo,它包含了符号表、重定位表、plt表等信息。<br>2.查找需要hook的函数的符号，得到它在符号表中的索引。具体实现是soinfo_elf_lookup函数。</p>
<p><img src="http://ww4.sinaimg.cn/mw690/8b331ee1gw1f932uud83bj207r088mxj.jpg" alt=""></p>
<p>bucket数组包含nbucket个项目，chain数组包含nchain个项目，下标都是从0开始。bucket和chain中都保存了符号表的索引。chain表项和符号表存在对应。符号表项的数目应该和nchain相等，所以符号表的索引也可以用来选取chain表项。哈希函数能够接受符号名并返回一个可以用来计算bucket的索引。如果哈希函数针对某个名字返回了数值x，则bucket[x%nbucket]给出了一个索引y，该索引可用于符号表，也可用于chain表。如果该符号表项不是所需要的，那么chain[y]则给出了具有相同哈希值的下一个符号表项。我们可以沿着chain链一直搜索，直到所选中的符号表项包含了所需要的符号，或者chain项中包含值STN_UNDEF。</p>
<p> 3.遍历plt表，直到匹配第2步中找到的符号索引。<br> 如果是JUMP_SLOT类型（函数调用），替换为新的符号地址（函数指针）。</p>
<hr>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li>《程序员的自我修养》</li>
<li>《深入理解计算机系统》</li>
<li><a href="http://shadowwhowalks.blogspot.com/2013/01/android-hacking-hooking-system.html" target="_blank" rel="external">Andrey Petrov’s blog</a></li>
<li><a href="https://www.apriorit.com/dev-blog/181-elf-hook" target="_blank" rel="external">Redirecting functions in shared ELF libraries</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;ELF文件格式解析&quot;&gt;&lt;a href=&quot;#ELF文件格式解析&quot; class=&quot;headerlink&quot; title=&quot;ELF文件格式解析&quot;&gt;&lt;/a&gt;ELF文件格式解析&lt;/h2&gt;&lt;p&gt;可执行和可链接格式(Executable and Linkable Format，缩
    
    </summary>
    
      <category term="C" scheme="http://felixzhang00.github.io/categories/C/"/>
    
    
      <category term="C" scheme="http://felixzhang00.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>jpeg编码学习笔记</title>
    <link href="http://felixzhang00.github.io/2016/12/24/2016-12-24-jpeg%E7%BC%96%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://felixzhang00.github.io/2016/12/24/2016-12-24-jpeg编码学习笔记/</id>
    <published>2016-12-24T12:59:13.000Z</published>
    <updated>2017-01-14T09:32:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>各种图片格式目的是在网络传输和存储的时候使用更少的字节，即起到压缩的作用。在图片格式解码后，无论图片的格式，图片数据都是像素数组。<br>本文将尝试通过JPEG这种图片编码格式的学习，了解图片编码的秘密。</p>
<hr>
<h2 id="JPEG简介"><a href="#JPEG简介" class="headerlink" title="JPEG简介"></a>JPEG简介</h2><p>一张100X100大小的普通图片，如果未经压缩，大概在100x100x4x8bits=0.3MB左右,这也是图片在内存中占用的内存大小。<br>通常JPEG文件相对于原始图像,能够得到1/8的压缩比，如此高的压缩率是如何做到的呢？</p>
<p>JPEG能够获得如此高的压缩比是因为使用了有损压缩技术，所谓有损压缩，就是把原始数据中不重要的部分去掉，以便可以用更小的体积保存。</p>
<p>JPEG编码是基于两个idea，第一个是基于相邻的像素信息是相近的，即空间冗余性，尽量少记录重复的数据来达到压缩的效果。第二个是基于图像信号的频谱特性，图像包含各种频率，大部分为低频频谱，少部分为高频频谱。可以保留包含图像信息较多的低频频谱，舍去包含图像信息较少的高频频谱。而达到图片质量没有可察觉的损伤，又能达到压缩的效果。这也说明了JPEG是有损编码。</p>
<hr>
<h2 id="JPEG的编码过程"><a href="#JPEG的编码过程" class="headerlink" title="JPEG的编码过程"></a>JPEG的编码过程</h2><p>编码流程如下图：</p>
<p><img src="http://ww4.sinaimg.cn/large/8b331ee1gw1fb2c7jxxyaj20eg08d74o.jpg" alt="编码流程示意图"></p>
<hr>
<h3 id="1-色彩空间转换"><a href="#1-色彩空间转换" class="headerlink" title="1.色彩空间转换"></a>1.色彩空间转换</h3><p>将RGB色彩空间转换到其他色彩空间，比如<a href="https://en.wikipedia.org/wiki/YUV" target="_blank" rel="external">YUV</a>色彩空间。<br>出现YUV,主要有两个原因，一个是为了让彩色信号兼容黑白电视机，另外一个原因是为了减少传输的带宽。<br>下图为老电视后面的色差接口。</p>
<p><img src="http://ww3.sinaimg.cn/large/8b331ee1gw1fb24juusowj206u046q3w.jpg" alt="电视色差接口"></p>
<p>YUV中，Y表示亮度，U和V表示色度，总之它是将RGB信号进行了一种处理，根据人对亮度更敏感些，增加亮度的信号，减少颜色的信号，以这样“欺骗”人的眼睛的手段来节省空间。YUV的格式也很多，不过常见的就是422和420格式。</p>
<p>下图为420格式，每四个Y共用一组UV分量，每个YUV分量和RGB一样都用8位来表示，YUV色彩空间就比RGB色彩空间所需的存储空间少一半，数据就被压缩到了一半。</p>
<p><img src="http://ww4.sinaimg.cn/large/8b331ee1gw1fb24kvqketj20aa04n3zt.jpg" alt="Y420"></p>
<hr>
<h3 id="2-离散余弦变换DCT"><a href="#2-离散余弦变换DCT" class="headerlink" title="2.离散余弦变换DCT"></a>2.离散余弦变换DCT</h3><p>简单地说，DCT是傅里叶变换的一种，变换后会得到一个系数。<br>有关DCT的详细介绍可以看这个<a href="https://www.youtube.com/watch?v=Q2aEzeMDHMA" target="_blank" rel="external">视频</a>。</p>
<p>在JPEG压缩过程中，经过颜色空间的转换，每一个色值表示成8X8的图像块，下图为一个色彩域取样块，转化为频率域的DCT系数块：<br><img src="http://ww1.sinaimg.cn/large/8b331ee1gw1fb24n45lgbj20gv03qq3u.jpg" alt="转化为频率域的DCT系数块"></p>
<p>图片经过此步骤会输出一个频率系数矩阵，左上的系数幅度值最大，越往右下，系数的幅度值越小，频率越高。大部分图片信息都在频率域矩阵左上区域，右下几乎不含有图片信息，甚至只含杂波。<br>注意：转换后的DCT系数块矩阵(x,y)处的值并不和转换前的颜色空间矩阵（x,y）处的像素值直接对应。</p>
<p>这一步骤没有压缩作用，它目的是为下一步骤找低频和高频区域，也就是找出留下的区域和舍去的区域。</p>
<hr>
<h3 id="3-量化"><a href="#3-量化" class="headerlink" title="3.量化"></a>3.量化</h3><p>此步是将上步求得的DCT系数的简化的过程，利用人眼对高频部分不敏感的特性来舍去高频部分。<br>这里有两张表分别对亮度和色度做量化处理。</p>
<p>标准亮度量化表：<br><img src="http://ww3.sinaimg.cn/large/8b331ee1gw1fb24qq7yq0j20sw0b8t9r.jpg" alt="标准亮度量化表"></p>
<p>标准色度量化表：<br><img src="http://ww2.sinaimg.cn/large/8b331ee1gw1fb24rftccuj20sy0b8gmn.jpg" alt="标准色度量化表"></p>
<p>量化表是控制 JPEG 压缩比的关键。<br>DCT系数矩阵中的不同位置的值代表了图像数据中不同频率的分量，这两张表中的数据是根据人眼对不同频率的敏感程度的差别所积累下的经验制定的。这个步骤除掉了一些高频量, 损失了很多细节. 但事实上人眼对高空间频率远没有低频敏感.所以处理后的视觉损失很小。<br>另一个重要原因是所有的图片的点与点之间会有一个色彩过渡的过程. 大量的图象信息被包含在低空间频率中。 经过量化处理后, 在高空间频率段, 将出现大量连续的零。</p>
<p>把上面的DCT系数块通过量化后的结果如下图，其中第一个数-26是直流DC部分，它是一块图象样本的平均值，包含了原始8x8图像块中的很多能量，其余的是交流AC部分。<br>计算方法为：频率系数矩阵的数值除以对应量化表位置上的数值，并四舍五入到最近的整数。<br><img src="http://ww4.sinaimg.cn/large/8b331ee1gw1fb24usawejg20ie034t8o.gif" alt="量化过程"></p>
<p>解码的时候，反量化步骤会乘回量化表相应值，但是四舍五入导致低频有所损失，高频0字段被舍弃。此步为有损运算，会导致图像质量变低。所以说JPEG是有损编码。</p>
<hr>
<h3 id="4-zig-zag游程编码"><a href="#4-zig-zag游程编码" class="headerlink" title="4.zig-zag游程编码"></a>4.zig-zag游程编码</h3><p>量化后的数据还可以进行简化，更大程度的去压缩。</p>
<p><img src="http://ww2.sinaimg.cn/large/8b331ee1gw1fbqaat9zbqj20ac07vgmd.jpg" alt="zig-zag表"></p>
<p>根据上面的zig-zag表重排数据的过程：</p>
<p><img src="http://ww4.sinaimg.cn/large/8b331ee1gw1fb255f7vvsj208s05mq38.jpg" alt="zig-zag过程"></p>
<p>根据ZigZag表的规则对量化后的数据进行重排后的结果中可以看到出现连续的多个0，这样有利于进行游程编码。</p>
<hr>
<h3 id="5-范式Huffman编码"><a href="#5-范式Huffman编码" class="headerlink" title="5.范式Huffman编码"></a>5.范式Huffman编码</h3><h4 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h4><p>huffman编码的基本原理是根据数据中元素的使用频率，调整元素的编码长度，以得到更高的压缩比。<br>举个例子，比如下面这段数据</p>
<p><code>AABCBABBCDBBDDBAABDBBDABBBBDDEDBD</code></p>
<p>这段数据里面包含了33个字符，每种字符出现的次数统计如下</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
<th>E</th>
</tr>
</thead>
<tbody>
<tr>
<td>次数</td>
<td>6</td>
<td>15</td>
<td>2</td>
<td>9</td>
<td>1</td>
<td></td>
</tr>
</tbody>
</table>
<p>如果我们用我们常见的定长编码，因为有5个文字，可以用3个bit表示，那么这段文字共需要3*33 = 99个bit来保存</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
<th>E</th>
</tr>
</thead>
<tbody>
<tr>
<td>编码</td>
<td>001</td>
<td>010</td>
<td>011</td>
<td>100</td>
<td>101</td>
<td></td>
</tr>
</tbody>
</table>
<p>如果根据字符出现的概率，使用如下的编码</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
<th>E</th>
</tr>
</thead>
<tbody>
<tr>
<td>编码</td>
<td>100</td>
<td>0</td>
<td>1110</td>
<td>10</td>
<td>1111</td>
<td></td>
</tr>
</tbody>
</table>
<p>那么这段文字共需要3x6 + 1x15 + 4x2 + 2x9 + 4x1 = 63bit，压缩比为63%。 是较短的编码不能够是较长编码的前缀，比如上面这个编码，就是由下面的这颗二叉树生成的。<br>哈弗曼编码一般都是使用二叉树来生成的，频率会高的数据对应的树节点的位置越高。这样得到的编码符合前缀规则，也就是较短的编码不能够是较长编码的前缀。</p>
<p><img src="http://ww4.sinaimg.cn/large/8b331ee1gw1fb25jyerm4j207h0760sr.jpg" alt="哈夫曼树"></p>
<h4 id="Huffman编码在JPEG中"><a href="#Huffman编码在JPEG中" class="headerlink" title="Huffman编码在JPEG中"></a>Huffman编码在JPEG中</h4><p>假设在JPEG量化处理后的数据为：<br><code>35,7,0,0,0,-6,-2,0,0,-9,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8,0,0,0,…,0</code></p>
<p>根据<a href="https://en.wikipedia.org/wiki/Run-length_encoding" target="_blank" rel="external">RLE</a>编码(游程编码)规则<br>1、用固定的4位来存储重复的数量，所以最多重复内容可以记录数量为15，超过15次要进行分段处理；<br>2、只将0作为重复的内容，每个数值记录前面有多少重复的0，末尾如果都是0用EOB作为代表；<br>3、此步不包含第一个数值，第一个数为直流系数，此步只处理交流系数。<br>得到处理结果：</p>
<p><img src="http://ww1.sinaimg.cn/large/8b331ee1gw1fb262lkvzaj21kw048ab4.jpg" alt="RLE编码"></p>
<p>为了提高储存效率, JPEG 里并不直接保存数值, 而是将数值按位数分成 16 组,JPEG提供了一张标准的码表用于对这些数字编码<br><img src="http://ww1.sinaimg.cn/large/8b331ee1gw1fbqabfrjzej20p70bvq4z.jpg" alt="标准码表"><br>举例来说，第3个单元中的“-6”这个数字，在表中的位置是长度为3的那组，所对应的bit码是“001”，由于这种编码附带长度信息，所以我们的数据变成了如下的格式。<br><img src="http://ww4.sinaimg.cn/large/8b331ee1gw1fb265nsj1aj21kw065jt8.jpg" alt="BIT编码"> </p>
<p>对于括号前面的数字的编码，分成DC编码和AC编码。<br>下表是针对直流(DC)部分即第一个数字的哈弗曼表，由于直流部分没有前置的0，所以取值范围在0~15之间。</p>
<p><img src="http://ww1.sinaimg.cn/large/8b331ee1gw1fbqabrz6wpj208d07vt8z.jpg" alt=""></p>
<p>对于其余的交流（AC）部分，取值范围在0~255，哈夫曼表如下：</p>
<p><img src="http://ww2.sinaimg.cn/large/8b331ee1gw1fbqab7b25sj206l09gjrr.jpg" alt=""></p>
<p>完整个编码过程如下表，最终的数据使用10个字节保存了原本长度为64字节的数据，JPEG的压缩算法完成。<br><img src="http://ww2.sinaimg.cn/large/8b331ee1gw1fb268ej9k9j21kw09yn0a.jpg" alt=""></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://blog.mrriddler.com/2016/07/20/%E5%9B%BE%E7%89%87%E4%B9%8B%E6%97%85/" target="_blank" rel="external">http://blog.mrriddler.com/2016/07/20/%E5%9B%BE%E7%89%87%E4%B9%8B%E6%97%85/</a></li>
<li><a href="http://thecodeway.com/blog/?p=69" target="_blank" rel="external">http://thecodeway.com/blog/?p=69</a></li>
<li><a href="http://www.impulseadventure.com/photo/jpeg-huffman-coding.html" target="_blank" rel="external">http://www.impulseadventure.com/photo/jpeg-huffman-coding.html</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/linux/l-cn-jpeg/index.html" target="_blank" rel="external">http://www.ibm.com/developerworks/cn/linux/l-cn-jpeg/index.html</a></li>
<li>《数字图像处理编程入门》</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;各种图片格式目的是在网络传输和存储的时候使用更少的字节，即起到压缩的作用。在图片格式解码后，无论图片的格式，图片数据都是像素数组。&lt;br&gt;本文将尝试通过JPEG这种图片编码格式的学习，了解图片编码的秘密。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;JPEG简介&quot;&gt;&lt;a href=&quot;
    
    </summary>
    
      <category term="图形学" scheme="http://felixzhang00.github.io/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
      <category term="图形学" scheme="http://felixzhang00.github.io/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>用OpenGL构建粒子喷泉</title>
    <link href="http://felixzhang00.github.io/2015/05/18/2015-05-18-use_opengl_build_particleshooter/"/>
    <id>http://felixzhang00.github.io/2015/05/18/2015-05-18-use_opengl_build_particleshooter/</id>
    <published>2015-05-18T12:32:11.000Z</published>
    <updated>2015-05-19T10:11:37.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h2><p><img src="http://7viip0.com1.z0.glb.clouddn.com/particles-1.gif"></p>
<p>这是<a href="http://book.douban.com/subject/25979507/" target="_blank" rel="external">《OpenGL ES应用开发实践指南》</a>中的一个例子，写这篇blog简单总结下在Android上进行OpenGL ES开发的方法。</p>
<h2 id="工作流程概述"><a href="#工作流程概述" class="headerlink" title="工作流程概述"></a>工作流程概述</h2><pre><code>定义顶点着色器、片段着色器。
</code></pre><p>##在哪里画图<br>在Activity中设置ContentView为GLSurfaceView，在该控件上设置自定义渲染器Renderer完成OpenGL绘图。<br>Renderer接口定义的方法：<br>onSurfaceCreated(GL10 gl10, EGLConfig eglConfig)<br>在Surface被创建时调用。</p>
<p>onSurfaceChanged(GL10 gl10, int width, int height)<br>每次Suface尺寸变化时被调用，包括第一次刚创建时。</p>
<p>onDrawFrame(GL10 gl10)<br>当绘制一帧时会被调用，比如一秒钟会被调用执行60次。</p>
<p>##如何告诉GPU绘制信息</p>
<h3 id="把内存从java堆复制到本地堆"><a href="#把内存从java堆复制到本地堆" class="headerlink" title="把内存从java堆复制到本地堆"></a>把内存从java堆复制到本地堆</h3><p>图形有顶点和颜色构成，将这些信息存放在一个数组中，并且需要将java数组转移到本地数组中,可以使用这个工具类<a href="https://github.com/FelixZhang00/My_Particles2/blob/master/app/src/main/java/me/felixzhang/example/my_particles2/data/VertexArray.java" target="_blank" rel="external">VertexArray</a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by felix on 15/5/19.</div><div class="line"> * 负责将内存从java堆复制到本地堆。</div><div class="line"> * 关联属性与顶点数据，告诉OpenGL去哪里找属性对应的数据。</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VertexArray</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> FloatBuffer floatBuffer;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">VertexArray</span><span class="params">(<span class="keyword">float</span>[] vertexData)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.floatBuffer = ByteBuffer.allocateDirect(vertexData.length * BYTE_PER_FLOAT)</div><div class="line">                .order(ByteOrder.nativeOrder())</div><div class="line">                .asFloatBuffer();</div><div class="line">        floatBuffer.put(vertexData);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setVertexAttribPointer</span><span class="params">(<span class="keyword">int</span> dataOffset, <span class="keyword">int</span> attributeLocation, <span class="keyword">int</span> componentCount, <span class="keyword">int</span> stride)</span> </span>&#123;</div><div class="line">        floatBuffer.position(dataOffset);</div><div class="line">        glVertexAttribPointer(attributeLocation, componentCount, GL_FLOAT, <span class="keyword">false</span>, stride, floatBuffer);</div><div class="line">        glEnableVertexAttribArray(attributeLocation);</div><div class="line">        floatBuffer.position(<span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 在原有数组的基础上更新指定范围的元素，如果全部复制的话速度太慢</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> vertexData</div><div class="line">     * <span class="doctag">@param</span> start</div><div class="line">     * <span class="doctag">@param</span> count</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateBuffer</span><span class="params">(<span class="keyword">float</span>[] vertexData, <span class="keyword">int</span> start, <span class="keyword">int</span> count)</span> </span>&#123;</div><div class="line">        floatBuffer.position(start);</div><div class="line">        floatBuffer.put(vertexData, start, count);</div><div class="line">        floatBuffer.position(<span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>###还需要着色器<br>告诉GPU如何绘制数据，数据在着色器这一管道中传递。</p>
<p>着色器中变量的解释</p>
<pre><code>uniform：会让每个顶点都使用同一个值，不需要对每个顶点设置，除非我们再次改变它。
attribute：把顶点属性放进着色器的手段，每个顶点都要设置一次
varying：不需要设置，共顶点着色器和片段着色器之间共享数据。
</code></pre><p>下面是一个顶点着色器</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">uniform mat4 u_Matrix;</div><div class="line">uniform <span class="keyword">float</span> u_Time;                   <span class="comment">//当前系统的时间</span></div><div class="line"></div><div class="line">attribute vec3 a_Position;</div><div class="line">attribute vec3 a_Color;</div><div class="line">attribute vec3 a_DirectionVector;</div><div class="line">attribute <span class="keyword">float</span> a_ParticleStartTime;        <span class="comment">//例子创建的时间</span></div><div class="line"></div><div class="line"></div><div class="line">varying <span class="keyword">float</span> v_ElapseTime;</div><div class="line">varying vec3 v_Color;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">   v_Color=a_Color;</div><div class="line">   v_ElapseTime=u_Time-a_ParticleStartTime;</div><div class="line">   vec3 currentPosition=a_Position+(a_DirectionVector*v_ElapseTime);</div><div class="line"></div><div class="line">   gl_Position=u_Matrix*vec4(currentPosition,<span class="number">1.0</span>);</div><div class="line">   gl_PointSize=<span class="number">10.0</span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面是一个片段着色器：<br>告诉GPU每个片段最终颜色是什么，对于基本图元的每个片段都会被调用一次。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">precision mediump <span class="keyword">float</span>;</div><div class="line"></div><div class="line">varying vec3 v_Color;</div><div class="line">varying <span class="keyword">float</span> v_ElapseTime;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">gl_FragColor=vec4(v_Color/v_ElapseTime,<span class="number">1.0</span>);</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>###如何让OpenGL画图<br>当调用下面的方法时，OpenGL就会从缓冲区读数据，每读取完一组数据就会调用一次main方法，并把数据填到attribute对应的变量中。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">glDrawArrays(GL_POINTS, <span class="number">0</span>, currentParticleCount);</div></pre></td></tr></table></figure></p>
<p>着色器main方法中的gl_Position和gl_PointSize是OpenGL中的变量，也就是最终给GPU的信息。</p>
<p>##编译着色器<br>glsl文件需要编译链接成OpenGL的一个程序才能使用。<br>需要使用这几个<a href="https://github.com/FelixZhang00/My_Particles2/tree/master/app/src/main/java/me/felixzhang/example/my_particles2/util" target="_blank" rel="external">工具类</a>。<br><img src="http://7viip0.com1.z0.glb.clouddn.com/opengl-particlesshooter-compile-tool.jpg"></p>
<p>##构建粒子系统<br><img src="http://7viip0.com1.z0.glb.clouddn.com/particles-class-diagram.jpg"></p>
<p><a href="https://gist.github.com/FelixZhang00/bc6c7d4adc98319359b7" target="_blank" rel="external">ParticlesRenderer</a></p>
<p><a href="https://gist.github.com/FelixZhang00/353d9d25a853341d6623" target="_blank" rel="external">ParticlesShooter</a></p>
<p><a href="https://gist.github.com/FelixZhang00/1d010a3f4af23f348b6c" target="_blank" rel="external">ParticlsSystem</a></p>
<p>###向粒子系统中填充数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line">   * 向系统中添加粒子，每次添加一个</div><div class="line">   *</div><div class="line">   * <span class="doctag">@param</span> positionPoint 新加粒子的位置</div><div class="line">   */</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addParticles</span><span class="params">(Point positionPoint, <span class="keyword">int</span> color, Vector direction, <span class="keyword">float</span> particleStrtTime)</span> </span>&#123;</div><div class="line"></div><div class="line">      <span class="keyword">final</span> <span class="keyword">int</span> particleOffset = nextParticleOffset * TOTAL_COMPONENT_COUNT;  <span class="comment">//记住新粒子从数组的哪个编号开始</span></div><div class="line">      <span class="keyword">int</span> currentOffset = particleOffset;                       <span class="comment">//记住新粒子的每个属性从哪里开始</span></div><div class="line"></div><div class="line">      nextParticleOffset++;</div><div class="line">      <span class="keyword">if</span> (currentParticlesCount &lt; maxParticlesCount) &#123;</div><div class="line">          currentParticlesCount++;</div><div class="line">      &#125;</div><div class="line">      <span class="comment">//当超出数组范围时，将下一个粒子放在数组的开头位置，达到回收的目的</span></div><div class="line">      <span class="keyword">if</span> (nextParticleOffset == maxParticlesCount) &#123;</div><div class="line">          nextParticleOffset = <span class="number">0</span>;</div><div class="line">      &#125;</div><div class="line"></div><div class="line"></div><div class="line">      <span class="comment">//把新粒子的数据写到数组中</span></div><div class="line">      particles[currentOffset++] = positionPoint.x;</div><div class="line">      particles[currentOffset++] = positionPoint.y;</div><div class="line">      particles[currentOffset++] = positionPoint.z;</div><div class="line"></div><div class="line">      particles[currentOffset++] = Color.red(color) / <span class="number">255f</span>;       <span class="comment">//OpenGL需要[0,1)的颜色值</span></div><div class="line">      particles[currentOffset++] = Color.green(color) / <span class="number">255f</span>;</div><div class="line">      particles[currentOffset++] = Color.blue(color) / <span class="number">255f</span>;</div><div class="line"></div><div class="line"></div><div class="line">      particles[currentOffset++] = direction.x;</div><div class="line">      particles[currentOffset++] = direction.y;</div><div class="line">      particles[currentOffset++] = direction.z;</div><div class="line"></div><div class="line"></div><div class="line">      particles[currentOffset++] = particleStrtTime;</div><div class="line"></div><div class="line">      vertexArray.updateBuffer(particles, particleOffset, TOTAL_COMPONENT_COUNT);</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>通过发射器向粒子系统中添加数据<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParticlesShooter</span> </span>&#123;</div><div class="line"></div><div class="line">   <span class="comment">//确定粒子发射器的位置，方向和颜色</span></div><div class="line">   <span class="keyword">private</span> <span class="keyword">final</span> Point position;</div><div class="line">   <span class="keyword">private</span> <span class="keyword">final</span> Vector direction;</div><div class="line">   <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> color;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ParticlesShooter</span><span class="params">(Point position, Vector direction, <span class="keyword">int</span> color)</span> </span>&#123;</div><div class="line">       <span class="keyword">this</span>.position = position;</div><div class="line">       <span class="keyword">this</span>.direction = direction;</div><div class="line">       <span class="keyword">this</span>.color = color;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addParticles</span><span class="params">(ParticlsSystem particlsSystem, <span class="keyword">float</span> currentTime, <span class="keyword">int</span> count)</span> </span>&#123;</div><div class="line"></div><div class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</div><div class="line">           particlsSystem.addParticles(position,color,direction,currentTime);</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>最后在ParticlesRenderer中加入一些调用统一管理这一切。</p>
<p><a href="https://github.com/FelixZhang00/My_Particles2" target="_blank" rel="external">项目地址</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;效果展示&quot;&gt;&lt;a href=&quot;#效果展示&quot; class=&quot;headerlink&quot; title=&quot;效果展示&quot;&gt;&lt;/a&gt;效果展示&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://7viip0.com1.z0.glb.clouddn.com/particles-1.gi
    
    </summary>
    
    
      <category term="OpenGL" scheme="http://felixzhang00.github.io/tags/OpenGL/"/>
    
  </entry>
  
  <entry>
    <title>【LeetCode】Letter Combinations of a Phone Number</title>
    <link href="http://felixzhang00.github.io/2015/05/08/2015-05-08-%E3%80%90LeetCode%E3%80%91Letter%20Combinations%20of%20a%20Phone%20Number/"/>
    <id>http://felixzhang00.github.io/2015/05/08/2015-05-08-【LeetCode】Letter Combinations of a Phone Number/</id>
    <published>2015-05-08T11:43:23.000Z</published>
    <updated>2015-05-08T11:53:49.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a><a href="https://leetcode.com/submissions/detail/27236262/" target="_blank" rel="external">题目</a></h2><p>在手机九宫格键盘上输入一串数字，给出可能打印出来的字符串的集合。</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ul>
<li>先做一个map将数字映射到键盘上相应的字母集合。</li>
<li>把按键顺序看成深度优先遍历的深度，每次dfs将深度d+1直到d=按键字符串的长度未知，此时即完成了一次按键可能的输出。</li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">static</span> Map&lt;Integer, Character[]&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, Character[]&gt;();   <span class="comment">//数字键--键上的字母集合</span></div><div class="line"></div><div class="line">   <span class="keyword">static</span> &#123;</div><div class="line">       map.put(<span class="number">1</span>, <span class="keyword">new</span> Character[]&#123;<span class="string">'\0'</span>&#125;);</div><div class="line">       map.put(<span class="number">2</span>, <span class="keyword">new</span> Character[]&#123;<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>&#125;);</div><div class="line">       map.put(<span class="number">3</span>, <span class="keyword">new</span> Character[]&#123;<span class="string">'d'</span>, <span class="string">'e'</span>, <span class="string">'f'</span>&#125;);</div><div class="line">       map.put(<span class="number">4</span>, <span class="keyword">new</span> Character[]&#123;<span class="string">'g'</span>, <span class="string">'h'</span>, <span class="string">'i'</span>&#125;);</div><div class="line">       map.put(<span class="number">5</span>, <span class="keyword">new</span> Character[]&#123;<span class="string">'j'</span>, <span class="string">'k'</span>, <span class="string">'l'</span>&#125;);</div><div class="line">       map.put(<span class="number">6</span>, <span class="keyword">new</span> Character[]&#123;<span class="string">'m'</span>, <span class="string">'n'</span>, <span class="string">'o'</span>&#125;);</div><div class="line">       map.put(<span class="number">7</span>, <span class="keyword">new</span> Character[]&#123;<span class="string">'p'</span>, <span class="string">'q'</span>, <span class="string">'r'</span>, <span class="string">'s'</span>&#125;);</div><div class="line">       map.put(<span class="number">8</span>, <span class="keyword">new</span> Character[]&#123;<span class="string">'t'</span>, <span class="string">'u'</span>, <span class="string">'v'</span>&#125;);</div><div class="line">       map.put(<span class="number">9</span>, <span class="keyword">new</span> Character[]&#123;<span class="string">'w'</span>, <span class="string">'x'</span>, <span class="string">'y'</span>, <span class="string">'z'</span>&#125;);</div><div class="line">       map.put(<span class="number">0</span>, <span class="keyword">new</span> Character[]&#123;<span class="string">' '</span>&#125;);</div><div class="line"></div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">letterCombinations</span><span class="params">(String digits)</span> </span>&#123;</div><div class="line">       ArrayList&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;String&gt;();</div><div class="line">       <span class="keyword">if</span> (digits == <span class="keyword">null</span> || digits.length() == <span class="number">0</span>) <span class="keyword">return</span> result;</div><div class="line"></div><div class="line">       dfs(digits, <span class="number">0</span>, <span class="string">""</span>, result);</div><div class="line">       <span class="keyword">return</span> result;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="comment">/**</span></div><div class="line">    * 深度优先遍历，每次将数字键上的字母拼接到s中，一旦到达底部，则将s放入结果集中，并返回</div><div class="line">    */</div><div class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(String digits, <span class="keyword">int</span> d, String s, ArrayList&lt;String&gt; result)</span> </span>&#123;</div><div class="line">       <span class="keyword">if</span> (d == digits.length()) &#123;</div><div class="line">           result.add(s);</div><div class="line">           <span class="keyword">return</span>;</div><div class="line">       &#125;</div><div class="line">       Integer number = Integer.parseInt(digits.charAt(d) + <span class="string">""</span>);  <span class="comment">//得到输入数字串在深度d时的数字</span></div><div class="line"></div><div class="line">       <span class="keyword">for</span> (Character c : map.get(number)) &#123;                      <span class="comment">//遍历该数字对应的每一个字母</span></div><div class="line">           dfs(digits, d + <span class="number">1</span>, s + c, result);</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.com/submissions/detail/27236262/&quot; target=&quot;_blank&quot; rel=
    
    </summary>
    
      <category term="算法" scheme="http://felixzhang00.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://felixzhang00.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>【LeetCode】Merge Intervals</title>
    <link href="http://felixzhang00.github.io/2015/05/08/2015-05-08-%E3%80%90LeetCode%E3%80%91Merge%20Intervals/"/>
    <id>http://felixzhang00.github.io/2015/05/08/2015-05-08-【LeetCode】Merge Intervals/</id>
    <published>2015-05-08T06:27:14.000Z</published>
    <updated>2015-05-08T06:39:22.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a><a href="https://leetcode.com/problems/merge-intervals/" target="_blank" rel="external">题目</a></h2><pre><code>Given a collection of intervals, merge all overlapping intervals.

For example,
Given [1,3],[2,6],[8,10],[15,18],
return [1,6],[8,10],[15,18].
</code></pre><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>先对intervals集合按start从小到大排序，last变量用于保存可能插入到结果集中的元素，遍历每一个集合中的元素，如果符合合并的条件，将last和当前元素合并,并重新赋值给last，此时last仍然具有合并的潜力；如果不符合合并的条件，则将last放入结果集中，并把当前元素赋值给last，成为一个新的潜在具有合并性的元素。</p>
<h3 id="自定义比较类"><a href="#自定义比较类" class="headerlink" title="自定义比较类"></a>自定义比较类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">//      Definition for an interval</span></div><div class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Interval</span> </span>&#123;</div><div class="line">      <span class="keyword">int</span> start;</div><div class="line">      <span class="keyword">int</span> end;</div><div class="line"></div><div class="line">      Interval() &#123;</div><div class="line">          start = <span class="number">0</span>;</div><div class="line">          end = <span class="number">0</span>;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      Interval(<span class="keyword">int</span> s, <span class="keyword">int</span> e) &#123;</div><div class="line">          start = s;</div><div class="line">          end = e;</div><div class="line">      &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Comparator&lt;Interval&gt; BY_START = <span class="keyword">new</span> ByStart();</div><div class="line"></div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ByStart</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Interval</span>&gt; </span>&#123;</div><div class="line">      <span class="meta">@Override</span></div><div class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Interval o1, Interval o2)</span> </span>&#123;</div><div class="line">          <span class="keyword">return</span> o1.start - o2.start;</div><div class="line">      &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<h3 id="主方法"><a href="#主方法" class="headerlink" title="主方法"></a>主方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> List&lt;Interval&gt; <span class="title">merge</span><span class="params">(List&lt;Interval&gt; intervals)</span> </span>&#123;</div><div class="line">     ArrayList&lt;Interval&gt; result = <span class="keyword">new</span> ArrayList&lt;Interval&gt;();</div><div class="line"></div><div class="line">     <span class="keyword">if</span> (intervals == <span class="keyword">null</span> || intervals.size() == <span class="number">0</span>) &#123;</div><div class="line">         <span class="keyword">return</span> result;</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     <span class="comment">//按Interval的start对intervals排序</span></div><div class="line">     Collections.sort(intervals, BY_START);</div><div class="line"></div><div class="line">     Interval last = intervals.get(<span class="number">0</span>);</div><div class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; intervals.size(); i++) &#123;</div><div class="line">         Interval temp = intervals.get(i);</div><div class="line">         <span class="keyword">if</span> (canMerge(last, temp)) &#123;</div><div class="line">             <span class="keyword">if</span> (last.end &lt;= temp.end) &#123;</div><div class="line">                 last = <span class="keyword">new</span> Interval(last.start, temp.end);</div><div class="line">             &#125;</div><div class="line">             <span class="comment">//另外一种情况last保持不变</span></div><div class="line">         &#125; <span class="keyword">else</span> &#123;</div><div class="line">             result.add(last);</div><div class="line">             last = intervals.get(i);</div><div class="line">         &#125;</div><div class="line"></div><div class="line">     &#125;</div><div class="line">     result.add(last);</div><div class="line">     <span class="keyword">return</span> result;</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">canMerge</span><span class="params">(Interval item1, Interval item2)</span> </span>&#123;</div><div class="line">     <span class="keyword">if</span> (item1.end &gt;= item2.start) &#123;</div><div class="line">         <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">     &#125;</div><div class="line">     <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.com/problems/merge-intervals/&quot; target=&quot;_blank&quot; rel=&quot;ex
    
    </summary>
    
      <category term="算法" scheme="http://felixzhang00.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://felixzhang00.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode第207题--Course Schedule</title>
    <link href="http://felixzhang00.github.io/2015/05/07/2015-05-07-LeetCode%E7%AC%AC207%E9%A2%98--Course%20Schedule/"/>
    <id>http://felixzhang00.github.io/2015/05/07/2015-05-07-LeetCode第207题--Course Schedule/</id>
    <published>2015-05-07T06:28:09.000Z</published>
    <updated>2015-05-07T07:39:25.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="原题"><a href="#原题" class="headerlink" title="原题"></a><a href="https://leetcode.com/problems/course-schedule/" target="_blank" rel="external">原题</a></h2><p>给出课程总数，用不同整数编号表示不同课程，用一个二维数组表示多组先修课程的顺序对。</p>
<p>比如：有2门课，要学课程1必须先学课程0，这是有效的。</p>
<pre><code>2, [[1,0]]
</code></pre><p>如果有2门课，要学课程1必须先学课程0，要学课程0必须先学课程1，这是无效的。</p>
<pre><code>2, [[1,0],[0,1]]
</code></pre><p>需要完成的就是这个方法：</p>
<pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites)</span> </span>&#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre><h3 id="测试数据："><a href="#测试数据：" class="headerlink" title="测试数据："></a>测试数据：</h3><pre><code>8, [[1,0],[2,6],[1,7],[5,1],[6,4],[7,0],[0,5],[5,1],[6,4]]
</code></pre><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>由课程的编号构成一幅有向图，方向为先修顺序，构造完成后只要判断图是否有环。</p>
<h3 id="有向图数据结构"><a href="#有向图数据结构" class="headerlink" title="有向图数据结构"></a>有向图数据结构</h3><p>初始化时构造一张图，但只有顶点个事，顶点之间没有边相连。</p>
<p>用邻接表表示有向图。</p>
<p>调用<code>addEdge()</code>方法可以将课程之间先修关系写到图中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">	</div><div class="line">	</div><div class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Digraph</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> V;</div><div class="line">    <span class="keyword">private</span> ArrayList&lt;Integer&gt;[] adj;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Digraph</span><span class="params">(<span class="keyword">int</span> V)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.V = V;</div><div class="line">        adj = (ArrayList&lt;Integer&gt;[]) <span class="keyword">new</span> ArrayList[V];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; V; v++) &#123;</div><div class="line">            adj[v] = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</div><div class="line">        adj[v].add(w);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">V</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> V;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;Integer&gt; <span class="title">adj</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> adj[v];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="判断有向图中是否有环"><a href="#判断有向图中是否有环" class="headerlink" title="判断有向图中是否有环"></a>判断有向图中是否有环</h3><p>用一个数组<code>boolean[] onStack</code>保存递归调用期间栈上的所有顶点.</p>
<p>onStack[v]=true,记录顶点v出现在这次dfs中，在这次dfs结束后，是onStack[v]=false</p>
<p>在递归执行dfs的过程中，记录当前下当前顶点在递归调用栈中，这样以后的递归调用栈只要判断它的相连点是否在之前的递归调用栈中出现过，就能判断是否有环。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">DirectedCycle</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[] marked;        <span class="comment">// marked[v] 顶点v是否被访问过</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[] onStack;       <span class="comment">//保存递归调用期间栈上的所有顶点。 onStack[v] = ？顶点v是否在栈中</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> hasCycle;       <span class="comment">// 有向图中是否环</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DirectedCycle</span><span class="params">(Digraph G)</span> </span>&#123;</div><div class="line">        marked = <span class="keyword">new</span> <span class="keyword">boolean</span>[G.V()];</div><div class="line">        onStack = <span class="keyword">new</span> <span class="keyword">boolean</span>[G.V()];</div><div class="line">        hasCycle = <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; G.V(); v++)   <span class="comment">//对图中每一个没有被访问过的点做深度优先遍历</span></div><div class="line">            <span class="keyword">if</span> (!marked[v]) dfs(G, v);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 从v顶点开始做深度优先遍历</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Digraph G, <span class="keyword">int</span> v)</span> </span>&#123;</div><div class="line">        onStack[v] = <span class="keyword">true</span>;</div><div class="line">        marked[v] = <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> w : G.adj(v)) &#123;        <span class="comment">//遍历所有顶点v的相连点</span></div><div class="line">            <span class="keyword">if</span> (hasCycle) <span class="keyword">return</span>;       <span class="comment">//如果已经找到一个环就不再dfs</span></div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!marked[w]) &#123;      <span class="comment">//对每一个未访问过的点继续dfs</span></div><div class="line">                dfs(G, w);</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (onStack[w]) &#123;    <span class="comment">//顶点w在之前的递归调用栈中，并且已经被访问过，构成环</span></div><div class="line">                hasCycle = <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        onStack[v] = <span class="keyword">false</span>;             <span class="comment">//顶点v所有的相连点遍历结束,顶点v退出当前调用栈</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> hasCycle;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="主方法"><a href="#主方法" class="headerlink" title="主方法"></a>主方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites)</span> </span>&#123;</div><div class="line">      Digraph G = <span class="keyword">new</span> Digraph(numCourses);</div><div class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prerequisites.length; i++) &#123;</div><div class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; prerequisites[i].length; j++) &#123;</div><div class="line">              G.addEdge(prerequisites[i][j], prerequisites[i][++j]);</div><div class="line">          &#125;</div><div class="line">      &#125;</div><div class="line">      DirectedCycle dag = <span class="keyword">new</span> DirectedCycle(G);</div><div class="line"></div><div class="line">      <span class="keyword">return</span> !dag.hasCycle();</div><div class="line"></div><div class="line">  &#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;原题&quot;&gt;&lt;a href=&quot;#原题&quot; class=&quot;headerlink&quot; title=&quot;原题&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode.com/problems/course-schedule/&quot; target=&quot;_blank&quot; rel=&quot;ex
    
    </summary>
    
      <category term="算法" scheme="http://felixzhang00.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="leetcode" scheme="http://felixzhang00.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>霍夫曼压缩算法</title>
    <link href="http://felixzhang00.github.io/2015/05/05/2015-05-05-%E9%9C%8D%E5%A4%AB%E6%9B%BC%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95/"/>
    <id>http://felixzhang00.github.io/2015/05/05/2015-05-05-霍夫曼压缩算法/</id>
    <published>2015-05-05T10:58:11.000Z</published>
    <updated>2015-05-05T14:48:05.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>霍夫曼压缩算法的主要思想是用较少的比特表示出现频率较高的字符，用较多的比特表示出现频率较低的字符。如下图所示，<br><img src="http://7viip0.com1.z0.glb.clouddn.com/2015-05-05-trie-representation.jpeg"></p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><pre><code>①读入完整的输入流，并转化为字符数组。
②计算每个字符出现的次数
③构建Huffman树
④构建编译表
⑤将单词查找树编码成比特输出串并写入到输出流
⑥将单词总数编码成比特输出串并写入到输出流
⑦使用编译表翻译每个输入字符
</code></pre><h3 id="节点的表示"><a href="#节点的表示" class="headerlink" title="节点的表示"></a>节点的表示</h3><pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> R = <span class="number">256</span>;       <span class="comment">//字符为ASCII表示</span></div><div class="line"></div><div class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Node</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">       <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> ch;</div><div class="line">       <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> freq;</div><div class="line">       <span class="keyword">private</span> <span class="keyword">final</span> Node left, right;</div><div class="line"></div><div class="line">       <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">char</span> ch, <span class="keyword">int</span> freq, Node left, Node right)</span> </span>&#123;</div><div class="line">           <span class="keyword">this</span>.freq = freq;</div><div class="line">           <span class="keyword">this</span>.ch = ch;</div><div class="line">           <span class="keyword">this</span>.left = left;</div><div class="line">           <span class="keyword">this</span>.right = right;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isLeaf</span><span class="params">()</span> </span>&#123;</div><div class="line">           <span class="keyword">return</span> left == <span class="keyword">null</span> &amp;&amp; right == <span class="keyword">null</span>;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="meta">@Override</span></div><div class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Node that)</span> </span>&#123;</div><div class="line">           <span class="keyword">return</span> <span class="keyword">this</span>.freq - that.freq;</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
</code></pre><h3 id="构建Huffman单词查找树"><a href="#构建Huffman单词查找树" class="headerlink" title="构建Huffman单词查找树"></a>构建Huffman单词查找树</h3><p>构建初始有一堆没有父节点的节点，将它们放到最小队列中，这样对头总是freq为最小的那个节点。<br>从队列中找到freq最小的两个节点，创建一个它们的父节点，将三个节点归并成一个大节点，接着放入队列中，<br>循环往复直至队列中只剩一个节点。</p>
<pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line">    * <span class="doctag">@param</span> freq 字符出现的次数</div><div class="line">    * <span class="doctag">@return</span></div><div class="line">    */</div><div class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Node <span class="title">buildTrie</span><span class="params">(<span class="keyword">char</span>[] freq)</span> </span>&#123;</div><div class="line">       MinPQ&lt;Node&gt; pq = <span class="keyword">new</span> MinPQ&lt;Node&gt;();</div><div class="line"></div><div class="line">       <span class="comment">//初始化多个将构成一颗Huffman树的结点</span></div><div class="line">       <span class="keyword">for</span> (<span class="keyword">char</span> i = <span class="number">0</span>; i &lt; R; i++) &#123;</div><div class="line">           <span class="keyword">if</span> (freq[i] &gt; <span class="number">0</span>) pq.insert(<span class="keyword">new</span> Node(i, freq[i], <span class="keyword">null</span>, <span class="keyword">null</span>));</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="comment">// special case in case there is only one character with a nonzero frequency</span></div><div class="line">       <span class="keyword">if</span> (pq.size() == <span class="number">1</span>) &#123;</div><div class="line">           <span class="keyword">if</span> (freq[<span class="string">'\0'</span>] == <span class="number">0</span>) pq.insert(<span class="keyword">new</span> Node(<span class="string">'\0'</span>, <span class="number">0</span>, <span class="keyword">null</span>, <span class="keyword">null</span>));</div><div class="line">           <span class="keyword">else</span> pq.insert(<span class="keyword">new</span> Node(<span class="string">'\1'</span>, <span class="number">0</span>, <span class="keyword">null</span>, <span class="keyword">null</span>));</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="comment">//归并两个小树</span></div><div class="line">       <span class="keyword">while</span> (pq.size() &gt; <span class="number">1</span>) &#123;</div><div class="line">           Node left = pq.delMin();</div><div class="line">           Node right = pq.delMin();</div><div class="line"></div><div class="line">           Node parent = <span class="keyword">new</span> Node(<span class="string">'\0'</span>, left.freq + right.freq, left, right);      <span class="comment">//创建连接子树的中间结点</span></div><div class="line">           pq.insert(parent);</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="keyword">return</span> pq.delMin();</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
</code></pre><h3 id="将Huffman单词查找树转化成字节流写到压缩文件中"><a href="#将Huffman单词查找树转化成字节流写到压缩文件中" class="headerlink" title="将Huffman单词查找树转化成字节流写到压缩文件中"></a>将Huffman单词查找树转化成字节流写到压缩文件中</h3><p>做如下规定：<br>    中间结点写0；叶子结点写1，并在后面写结点上的字符。<br><img src="http://7viip0.com1.z0.glb.clouddn.com/2015-05-05-trie-encode.jpeg"></p>
<pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">    * 将单词查找树编码成比特输出串并写入到输出流</div><div class="line">    * 用前序遍历</div><div class="line">    */</div><div class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeTrie</span><span class="params">(Node x)</span> </span>&#123;</div><div class="line">       <span class="keyword">if</span> (x.isLeaf()) &#123;</div><div class="line">           BinaryStdOut.write(<span class="keyword">true</span>);</div><div class="line">           BinaryStdOut.write(x.ch);</div><div class="line">           <span class="keyword">return</span>;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       BinaryStdOut.write(<span class="keyword">false</span>);</div><div class="line">       writeTrie(x.left);</div><div class="line">       writeTrie(x.right);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
</code></pre><h3 id="将压缩文件中字节流转化为Huffman单词查找树"><a href="#将压缩文件中字节流转化为Huffman单词查找树" class="headerlink" title="将压缩文件中字节流转化为Huffman单词查找树"></a>将压缩文件中字节流转化为Huffman单词查找树</h3><p>按写入时的规定解析字节流。</p>
<pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">    * 读比特流，得出一颗单词查找树</div><div class="line">    */</div><div class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Node <span class="title">readTrie</span><span class="params">()</span> </span>&#123;</div><div class="line">       <span class="keyword">if</span> (BinaryStdIn.readBoolean()) &#123;   <span class="comment">//读到1，说明是叶子结点</span></div><div class="line">           <span class="keyword">return</span> <span class="keyword">new</span> Node(BinaryStdIn.readChar(), <span class="number">0</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="comment">//读到的是0，说明是中间结点，需要递归直到读到1为止</span></div><div class="line"></div><div class="line">       Node left = readTrie();</div><div class="line">       Node right = readTrie();</div><div class="line">       <span class="keyword">return</span> <span class="keyword">new</span> Node(<span class="string">'\0'</span>, <span class="number">0</span>, left, right);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
</code></pre><h3 id="构建编译表"><a href="#构建编译表" class="headerlink" title="构建编译表"></a>构建编译表</h3><p>构建编译表st，索引为字符，值为路径（比特字符串）。<br>根据这张表，可以将源文件中的某个字符，压缩为更少bit表示的Huffman树上的路径。</p>
<pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">buildCode</span><span class="params">(String[] st, Node x, String s)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (!x.isLeaf()) &#123;</div><div class="line">        buildCode(st, x.left, s + <span class="string">"0"</span>);</div><div class="line">        buildCode(st, x.right, s + <span class="string">"1"</span>);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        st[x.ch] = s;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre><h3 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h3><pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">	</div><div class="line"><span class="comment">/**</span></div><div class="line">  * 从输入流中读字节流，并将压缩后的结果写入输出流</div><div class="line">  */</div><div class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">compress</span><span class="params">()</span> </span>&#123;</div><div class="line">     <span class="comment">//①读入完整的输入流，并转化为字符数组</span></div><div class="line">     String s = BinaryStdIn.readString();</div><div class="line">     <span class="keyword">char</span>[] input = s.toCharArray();</div><div class="line"></div><div class="line">     <span class="comment">//②计算每个字符出现的次数，没有出现的就为0</span></div><div class="line">     <span class="keyword">char</span>[] freq = <span class="keyword">new</span> <span class="keyword">char</span>[R];</div><div class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; input.length; i++) &#123;</div><div class="line">         freq[input[i]]++;</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     <span class="comment">//③构建Huffman树</span></div><div class="line">     Node root = buildTrie(freq);</div><div class="line"></div><div class="line">     <span class="comment">//④构建编译表，将输入中的每个char值与一个比特字符串（即Huffman树上路径）相关联</span></div><div class="line">     String st[] = <span class="keyword">new</span> String[R];</div><div class="line">     buildCode(st, root, <span class="string">""</span>);</div><div class="line"></div><div class="line"></div><div class="line">     <span class="comment">//⑤将单词查找树编码成比特输出串并写入到输出流</span></div><div class="line">     writeTrie(root);</div><div class="line"></div><div class="line">     <span class="comment">//⑥将单词总数编码成比特输出串并写入到输出流</span></div><div class="line">     BinaryStdOut.write(input.length);</div><div class="line"></div><div class="line"></div><div class="line">     <span class="comment">//⑦使用编译表翻译每个输入字符</span></div><div class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; input.length; i++) &#123;</div><div class="line">         String code = st[input[i]];   <span class="comment">//code表示Huffman单词查找数上的路径</span></div><div class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; code.length(); j++) &#123;  <span class="comment">//要一位一位地输出</span></div><div class="line">             <span class="keyword">if</span> (code.charAt(j) == <span class="string">'1'</span>) &#123;</div><div class="line">                 BinaryStdOut.write(<span class="keyword">true</span>);</div><div class="line">             &#125; <span class="keyword">else</span> &#123;</div><div class="line">                 BinaryStdOut.write(<span class="keyword">false</span>);</div><div class="line">             &#125;</div><div class="line">         &#125;</div><div class="line"></div><div class="line">     &#125;</div><div class="line"></div><div class="line">     BinaryStdOut.close();</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
</code></pre><h3 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h3><pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">	</div><div class="line"><span class="comment">/**</span></div><div class="line">   * 解压</div><div class="line">   * 读取压缩文件的比特流，</div><div class="line">   * 将比特流对应为路径在单词查找树上找，将找到的结点中的字符写出</div><div class="line">   */</div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">expand</span><span class="params">()</span> </span>&#123;</div><div class="line">      Node root = readTrie();</div><div class="line">      <span class="keyword">int</span> N = BinaryStdIn.readInt();  <span class="comment">//读出存在压缩文件中的字符串长度</span></div><div class="line"></div><div class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;   <span class="comment">//找出源文件中每个字符</span></div><div class="line"></div><div class="line">          Node x = root;</div><div class="line">          <span class="keyword">while</span> (!x.isLeaf()) &#123;       <span class="comment">//遍历，知道叶子结点</span></div><div class="line">              <span class="keyword">if</span> (BinaryStdIn.readBoolean()) &#123;</div><div class="line">                  x = x.right;</div><div class="line">              &#125; <span class="keyword">else</span> &#123;</div><div class="line">                  x = x.left;</div><div class="line">              &#125;</div><div class="line"></div><div class="line">          &#125;</div><div class="line"></div><div class="line">          BinaryStdOut.write(x.ch);</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      BinaryStdOut.close();</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://algs4.cs.princeton.edu/home/" target="_blank" rel="external">Algorithms, 4th Edition by Robert Sedgewick and Kevin Wayne</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;霍夫曼压缩算法的主要思想是用较少的比特表示出现频率较高的字符，用较多的比特表示出现频率较低的字符。如下图所示，&lt;br&gt;&lt;img src=&quot;h
    
    </summary>
    
    
      <category term="算法" scheme="http://felixzhang00.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>游程编码算法</title>
    <link href="http://felixzhang00.github.io/2015/05/05/2015-05-05-%E6%B8%B8%E7%A8%8B%E7%BC%96%E7%A0%81%E7%AE%97%E6%B3%95/"/>
    <id>http://felixzhang00.github.io/2015/05/05/2015-05-05-游程编码算法/</id>
    <published>2015-05-05T06:46:41.000Z</published>
    <updated>2015-05-05T07:14:51.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>利用比特流常见的冗余形式：连续的重复数据，来压缩数据。</p>
<pre><code>0000000000000001111111000000011111111111    --40bit

在源数据中，记录重复bit的个数，记录到压缩数据中。

1111，0111，0111，1011                             --16bit            
</code></pre><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><pre><code>* 压缩原理：
* 将源文件中连续的1或0的个数（count）写到压缩文件中,
* 比如count用8位表示，规定压缩文件的格式为：
* 0连续的个数-1连续的个数-0连续的个数-1连续的个数.....
* 个数的大小为0~255，
* 如何处理连续的0(或1)的个数过大，无法存到count中：
* count0(=255)-count1(=0)-count0(=?)-.......
</code></pre><h3 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h3><pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> R = <span class="number">256</span>;</div><div class="line">   <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> lgR = <span class="number">8</span>;			<span class="comment">//存储cnt需要多少位</span></div><div class="line"><span class="comment">/**</span></div><div class="line">    * 压缩</div><div class="line">    */</div><div class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">compress</span><span class="params">()</span> </span>&#123;</div><div class="line">       <span class="keyword">boolean</span> b, old = <span class="keyword">false</span>;</div><div class="line">       <span class="keyword">int</span> cnt = <span class="number">0</span>;                            <span class="comment">//记录连续的0或1的个数</span></div><div class="line"></div><div class="line">       <span class="keyword">while</span> (!BinaryStdIn.isEmpty()) &#123;</div><div class="line">           b = BinaryStdIn.readBoolean();</div><div class="line">           <span class="keyword">if</span> (b != old) &#123;                     <span class="comment">//该向输出流写数据了</span></div><div class="line">               BinaryStdOut.write(cnt,lgR);</div><div class="line">               cnt = <span class="number">0</span>;</div><div class="line">               old = !old;</div><div class="line">           &#125; <span class="keyword">else</span> &#123;</div><div class="line"></div><div class="line">               <span class="keyword">if</span> (cnt == (R - <span class="number">1</span>)) &#123;           <span class="comment">// 处理连续的0(或1)的个数过大，无法存到count</span></div><div class="line">                   BinaryStdOut.write(cnt,lgR);    <span class="comment">//count0(=255)-count1(=0)-count0(=?)-.......</span></div><div class="line">                   cnt = <span class="number">0</span>;</div><div class="line">                   BinaryStdOut.write(cnt,lgR);</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">           cnt++;</div><div class="line"></div><div class="line">       &#125;</div><div class="line">       BinaryStdOut.write(cnt,lgR);    <span class="comment">//把剩余的cnt写出</span></div><div class="line">       BinaryStdOut.close();</div><div class="line"></div><div class="line">   &#125;</div></pre></td></tr></table></figure>
</code></pre><h3 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h3><pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">	</div><div class="line"><span class="comment">/**</span></div><div class="line"> * 解压</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">expand</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">boolean</span> bit = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (!BinaryStdIn.isEmpty()) &#123;</div><div class="line">        <span class="keyword">int</span> run = BinaryStdIn.readInt(lgR);   <span class="comment">//从输入流中读取lgR 位,这个数值代表了源文件中连续1或连续0的长度</span></div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; run; i++) &#123;       <span class="comment">//根据run的大小向输出流中写位</span></div><div class="line">            BinaryStdOut.write(bit);</div><div class="line">        &#125;</div><div class="line">        bit = !bit;                           <span class="comment">//压缩的格式要求</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    BinaryStdOut.close();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre><h3 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h3><pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">	</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (args[<span class="number">0</span>].equals(<span class="string">"-"</span>)) compress();</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (args[<span class="number">0</span>].equals(<span class="string">"+"</span>)) expand();</div><div class="line">    <span class="keyword">else</span> <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal command line argument"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;利用比特流常见的冗余形式：连续的重复数据，来压缩数据。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;000000000000000111111100000
    
    </summary>
    
    
      <category term="算法" scheme="http://felixzhang00.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
