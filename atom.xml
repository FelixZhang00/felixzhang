<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>FelixZhang&#39;s Blog</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://felixzhang00.github.io/"/>
  <updated>2020-03-24T07:16:33.057Z</updated>
  <id>http://felixzhang00.github.io/</id>
  
  <author>
    <name>Felix</name>
    <email>836828946@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>APK包大小优化总结</title>
    <link href="http://felixzhang00.github.io/2020/03/24/APK%E5%8C%85%E5%A4%A7%E5%B0%8F%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/"/>
    <id>http://felixzhang00.github.io/2020/03/24/APK包大小优化总结/</id>
    <published>2020-03-24T06:43:15.795Z</published>
    <updated>2020-03-24T07:16:33.057Z</updated>
    
    <content type="html"><![CDATA[<h2 id="导言"><a href="#导言" class="headerlink" title="导言"></a>导言</h2><p>随着业务快速增长，我们面临apk包体积不断增长的问题，在4.2版本包体积达到了历史最高点37.16MB，远远大于各竞品。包体积过大会影响到下载转化率、升级成功率，从线上数据看，apk升级失败的错误码主要集中在下载空间不足、socket异常和md5校验失败， 主要是包体积过大直接导致的。<br>为此我们成立了包大小优化项目，经过几个迭代的优化走后，在5.0版本包体积减少到15.16MB，领先竞品，同时apk升级失败率也大幅降低。</p>
<hr>
<h2 id="优化方案"><a href="#优化方案" class="headerlink" title="优化方案"></a>优化方案</h2><h3 id="native优化"><a href="#native优化" class="headerlink" title="native优化"></a>native优化</h3><p>1、使用共享C++ 运行时库<br>如果使用静态STL将会在每个 so 库中出现重复代码，增加应用大小。通过下面的配置可以改为使用共享C++运行时库。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"># for cmake</div><div class="line">externalNativeBuild &#123;</div><div class="line">    cmake &#123;</div><div class="line">        arguments &quot;-DANDROID_STL=c++_shared&quot;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"># 解决ibc++_shared.so 冲突问题</div><div class="line">packagingOptions &#123;</div><div class="line">    pickFirst &apos;lib/*/libc++_shared.so&apos;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#for ndk-build</div><div class="line">APP_STL := c++_shared</div></pre></td></tr></table></figure>
<p>通过<a href="https://github.com/Tencent/matrix/tree/master/matrix/matrix-android/matrix-apk-canary" target="_blank" rel="external">Matrix-ApkChecker</a>可以检测出使用静态STL的so。<br><img src="http://ww1.sinaimg.cn/large/8b331ee1gy1gakm9lfy8gj214e0fgdia.jpg" alt="2401578127039_.pic.jpg"></p>
<p>2、精简cocos代码<br>项目早期是基于cocos2d-x框架开发的，现已全面完成java化，C层的业务代码大部分可以删去。精简之后，apk包大小减少了约5MB。</p>
<p>3、开启编译优化</p>
<p>如果使用 GCC 可以 -Os 打开优化，如果使用 Clang 可以 -Oz 打开优化。</p>
<hr>
<h3 id="资源优化"><a href="#资源优化" class="headerlink" title="资源优化"></a>资源优化</h3><h4 id="删除无用资源"><a href="#删除无用资源" class="headerlink" title="删除无用资源"></a>删除无用资源</h4><p>随着业务快速迭代，产生了大量资源，由于初期对包大小不够重视，堆积了很多没有用到的资源，亟需检测出这部分无用资源并批量删除。</p>
<p>Android Lint可以检测无用资源，关于lint更详细的介绍可以看这篇<a href="https://cloud.tencent.com/developer/article/1014614" target="_blank" rel="external">文章</a>。<br><img src="http://ww1.sinaimg.cn/large/8b331ee1gy1g97p3x72d7j21c80rwnpd.jpg" alt="WeChat4bb3d7df2a8adac6f2bb2c3e98dd676f.png"></p>
<p>Lint 作为一个静态扫描工具，它最大的问题在于没有考虑到 ProGuard 的代码裁剪。在 ProGuard 过程我们会 shrink 掉大量的无用代码，但是 Lint 工具并不能检查出这些无用代码所引用的无用资源。lint也不支持配置资源白名单，防止误删。<br>正好<a href="https://github.com/Tencent/matrix/tree/master/matrix/matrix-android/matrix-apk-canary" target="_blank" rel="external">Matrix-ApkChecker</a>就具备这个功能。Matrix-ApkChecker还支持检测asset目录下的无用资源。</p>
<p>Matrix-ApkChecker搜索无用资源的原理:</p>
<blockquote>
<ol>
<li>找出apk中声明的资源：通过R.txt 文件（资源名与资源id的映射关系）中读取apk中包含的所有资源；</li>
<li>找出资源的引用：针对代码中对资源的引用，反编译dex成smali文件，搜索资源id常量；针对资源文件中对其他资源的引用，编译 xml 资源文件 和 AndroidManifest.xml，然后搜索 xml 文件中的每个节点，查看 attribute 和 text<br>中是否引用到其他资源</li>
</ol>
</blockquote>
<p>通过<code>getIdentifier</code>去访问的资源需要配置到白名单，防止误删。<br>扫描的结果会输出到<code>apk-checker-result.json</code>文件中，执行下面的脚本可以批量删除项目中的资源文件。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/usr/bin/env bash</span></div><div class="line"><span class="comment"># 用于删除apk-checker扫描出来的unused resources</span></div><div class="line"><span class="comment"># 输入参数1:unused-resources filename</span></div><div class="line"><span class="comment"># 输入参数2:待处理资源目录路径</span></div><div class="line"><span class="keyword">for</span> line <span class="keyword">in</span> $(cat <span class="string">"<span class="variable">$1</span>"</span>)</div><div class="line"><span class="keyword">do</span></div><div class="line">    <span class="built_in">type</span>=<span class="string">''</span></div><div class="line">    value=<span class="string">''</span></div><div class="line">    <span class="built_in">eval</span> $(<span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;line&#125;</span>"</span> | awk -F <span class="string">'.'</span> <span class="string">'&#123;print "type="$2";value="$3&#125;'</span>)</div><div class="line">    name=<span class="string">"&lt;"</span><span class="string">"<span class="variable">$&#123;type&#125;</span>"</span><span class="string">" name=\""</span><span class="string">"<span class="variable">$&#123;value&#125;</span>"</span><span class="string">"\"&gt;"</span></div><div class="line">    <span class="built_in">echo</span> <span class="variable">$name</span></div><div class="line">    find <span class="string">"<span class="variable">$2</span>"</span> -type f -name <span class="string">'*.xml'</span> | xargs  grep <span class="_">-l</span> <span class="string">"<span class="variable">$&#123;name&#125;</span>"</span> | xargs sed -i <span class="string">''</span> <span class="string">"/<span class="variable">$&#123;name&#125;</span>/d"</span></div><div class="line"></div><div class="line"><span class="keyword">done</span></div></pre></td></tr></table></figure></p>
<p>删除无用资源后，apk包大小减少了280K，仅无用的dimens资源就占用了137K。<br><img src="http://ww1.sinaimg.cn/large/8b331ee1gy1g97om9fjjqj21dc01pdg5.jpg" alt="企业微信截图_608b1862-eb8c-4916-8ecb-277a565ed2d7.png"><br>在接入<a href="https://github.com/JessYanCoding/AndroidAutoSize" target="_blank" rel="external">AndroidAutoSize</a>屏幕适配方案后，原先手工定义的定义的dimen都可以这种删除。</p>
<h4 id="删除重复的资源"><a href="#删除重复的资源" class="headerlink" title="删除重复的资源"></a>删除重复的资源</h4><p>随着工程的增大，开发人员的变动，有些资源文件名字不同，但是内容却完全相同。<br>可以通过扫描文件的MD5值，找出内容相同的文件。<br>在构建流水线中接入ipt腾讯云安装包检查工具后，可以检测出重复文件资源<br><img src="http://ww1.sinaimg.cn/large/8b331ee1gy1g97qygqgvfj20gw04wjrv.jpg" alt="企业微信截图_11e4c25c-1262-41d1-84b8-9ac5f4c9f336.png"><br>重复资源涉及到代码修改，需要手工删除。</p>
<p>Android在适配图片资源的时候，如果只有一套资源，低密度设备会缩放图片，高密度设备会拉伸图片。我们利用这个特性，存放一套资源图就可以供所有密度的设备使用。<br>综合考虑图片清晰度，包大小和内存占用情况，一般采用xhdpi下的资源图片。</p>
<h4 id="图片格式"><a href="#图片格式" class="headerlink" title="图片格式"></a>图片格式</h4><p>在Google I/O 2016中提到了针对图片格式的选择,<br>其建议是:如果能用VectorDrawable来表示的话优先使用VectorDrawable，如果支持WebP则优先用WebP，如果有透明度要求则使用PNG，其它场景可以使用JPG格式。<br><img src="http://ww1.sinaimg.cn/large/8b331ee1gy1g96x375bmhj20zk0jyabg.jpg" alt="图片格式选择"><br>目前4.2及以上的Android版本已经支持WebP，4.0,4.1的Android版本只支持不含透明度的有损压缩，<br>因为我们项目支持的最低版本是4.0，项目中的不含透明度的图片较少，考虑到兼容性问题，因此项目apk中的图片还是采用了PNG和JPG格式。</p>
<h4 id="图片压缩"><a href="#图片压缩" class="headerlink" title="图片压缩"></a>图片压缩</h4><p>Android项目构建过程中默认会使用<a href="https://developer.android.com/guide/topics/graphics/drawables#drawables-from-images" target="_blank" rel="external">pngcrush压缩res/drawable/下的图片资源</a>,<br>但是PNG cruncher的压缩率并不高，有必要选择更合适的压缩工具。</p>
<p><a href="https://cloud.tencent.com/developer/article/1034208" target="_blank" rel="external">png图片压缩工具对比</a>一文中，对比了主流的图片压缩工具。</p>
<blockquote>
<p>tinypng、pngquant、ImageAlpha、pngnq都是有损压缩，基本采用的都是quantization算法，将24位的PNG图片转换为8位的PNG图片，减少图片的颜色数；<br>pngcrush、optipng、pngout、advpng都是无损压缩，采用的都是基于LZ/Huffman的DEFLATE算法，减少图片IDAT chunk区域的数据。一般有损压缩的压缩率会大大高于无损压缩。</p>
</blockquote>
<p>我们项目选择了公司内开源的组件<a href="https://git.oa.com/chunyujin/auto_compress_pic" target="_blank" rel="external">pnghelper</a>，<br>它集成了pngquant、pngcrush、optipng，支持自动扫描，省去的人为压缩工作量的问题。<br>在保证图片质量的前提下，极大缩减了图片的大小。<br>同时需要关闭cruncherEnabled来禁止默认的优化算法，避免图片增大。<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">android &#123;</div><div class="line">    aaptOptions &#123;</div><div class="line">        cruncherEnabled <span class="keyword">false</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="图片网络化"><a href="#图片网络化" class="headerlink" title="图片网络化"></a>图片网络化</h4><p>为了进一步减少应用内图片资源，我们采用图片网络化的方案，根据产品功能有选择得将应用内比较大的图片配置到CDN上，客户端使用纯色或者小尺寸图片的兜底图，并会对图片做预下载，保证在使用到图片的场景中，可以尽快的展示出来。图片网络化的另一个好处是可以很方便支持动态更换图片，可以在线上配置，不用跟客户端版本。<br>对于图片预下载，Glide提供了downloadOnly的模式，支持仅下载图片文件，防止使用bytes解码出现内存的瞬间增长。</p>
<p><img src="http://ww1.sinaimg.cn/large/8b331ee1gy1gd519moe13j20n00f9jto.jpg" alt="screenshot.png"></p>
<p>对于新增超过10k的图片我们要求尽量做到网络化。<br>经过大图网络化方案的改造后，做到了产品体验与包体积兼顾，apk包大小减少了2.3M,并且也可持续化。</p>
<h4 id="资源混淆压缩"><a href="#资源混淆压缩" class="headerlink" title="资源混淆压缩"></a>资源混淆压缩</h4><p>我们项目中使用<a href="https://github.com/shwenzhang/AndResGuard" target="_blank" rel="external">AndResGuard</a>实现资源混淆和极限压缩处理。<br>通过将资源文件名混淆替换成短路径:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">res/drawable/icon -&gt; res/s/a</div></pre></td></tr></table></figure></p>
<p>达到减少 resources.arsc、签名文件以及 ZIP 文件大小的目的。<br>AndResGuard利用了 7-Zip 的大字典优化，提升APK整体压缩率，可以强制压缩PNG、JPG 以及 GIF 等Android默认不会打包压缩的文件，进一步减少包大小。</p>
<p>因为资源名字会做混淆处理，项目中通过<code>getIdentifier</code>去访问的资源，需要配置到白名单。<br>经过AndResGuard处理后，apk包大小减少了约800K。<br><img src="http://ww1.sinaimg.cn/large/8b331ee1gy1g97rvke7bwj22dq034q3n.jpg" alt="屏幕快照 2019-10-08 上午11.14.15.png"></p>
<hr>
<h3 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h3><h4 id="ProGuard"><a href="#ProGuard" class="headerlink" title="ProGuard"></a>ProGuard</h4><p>由于项目初期对于包大小不够重视，对于项目中的ProGuard配置文件关注不够，导致存在了很多过度keep的问题。</p>
<p>通过在<code>proguard.cfg</code>配置下面的规则，可以输出 ProGuard 的最终配置。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">-printconfiguration build/final_proguard_config.txt</div></pre></td></tr></table></figure></p>
<p>查看最终配置文件是否有过度keep的问题，比如：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">-keep class org.apache.** &#123; *; &#125;</div><div class="line">-keep class android.support.** &#123; *; &#125;</div></pre></td></tr></table></figure></p>
<p>很多情况下，我们只需要keep其中的某个包、某个方法，或者是类名就可以了。</p>
<p>通过Android Studio的APK Analyzer可以很方便得查看apk中不同库代码占比情况<br><img src="http://ww1.sinaimg.cn/large/8b331ee1gy1g97trsd67hj20lg07ugml.jpg" alt="APK Analyzer"><br>support包里的类名都没有混淆，是被过度keep了。</p>
<p>ProGuard 在每次运行时都会在工程 <code>build/outputs/mapping/release</code>目录输出结果文件：</p>
<ol>
<li>seeds.txt : 列出未混淆的类和成员</li>
<li>usage.txt : 列出从 .apk 删除的代码</li>
<li>mapping.txt ：列出原始与混淆后的类、方法和字段名称之间的对应关系</li>
<li>dump.txt ：描述 .apk 文件中所有类文件的内部结构</li>
</ol>
<p>我们可以根据 seeds.txt 文件检查未被混淆的类和成员中是否已包含所有期望保留的，再根据 usage.txt 文件查看是否有被误移除的代码。</p>
<p>需要注意的是，宿主提供给插件使用(compileonly)的代码需要keep住，否则会报找不到类方法的错误<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">type:java.lang.NoSuchMethodError</div><div class="line">message:<span class="function">No virtual method <span class="title">toJsonTree</span><span class="params">(Ljava/lang/Object;)</span>Lcom/google/gson/JsonElement</span>; in <span class="class"><span class="keyword">class</span> <span class="title">Lcom</span>/<span class="title">google</span>/<span class="title">gson</span>/<span class="title">Gson</span></span>; <span class="function">or its <span class="keyword">super</span> <span class="title">classes</span> <span class="params">(declaration of <span class="string">'com.google.gson.Gson'</span> appears in /data/app/com.ktcp.video==/base.apk)</span></span></div><div class="line">stack:</div><div class="line">com.ktcp.tvagent.stat.StatProperties.<span class="title">fromKVObject</span><span class="params">(StatProperties.java:xx)</span></div></pre></td></tr></table></figure></p>
<p>修改项目中不合理的配置规则后，apk包大小减少了约600k。</p>
<h4 id="Dex方法数优化"><a href="#Dex方法数优化" class="headerlink" title="Dex方法数优化"></a>Dex方法数优化</h4><p>jce协议自动生成的java代码可以选择精简模式，去掉set、get、display等方法。<br><img src="http://ww1.sinaimg.cn/large/8b331ee1gy1g97ukq91thj21ea0cqwi4.jpg" alt="jce精简模式"><br>去除jce大部分多余方法后，apk包大小减少了约40K，dex方法数减少了6千多个。</p>
<p>优化前：<br><img src="http://ww1.sinaimg.cn/large/8b331ee1gy1g97urkys3pj20k70ig793.jpg" alt="jce优化前"></p>
<p>优化后：<br><img src="http://ww1.sinaimg.cn/large/8b331ee1gy1g97us0yx6pj20l70lm0xo.jpg" alt="jce优化后"></p>
<h4 id="D8-amp-R8"><a href="#D8-amp-R8" class="headerlink" title="D8 &amp; R8"></a>D8 &amp; R8</h4><p>D8 作为下一代 dex 编译器，与之前的DX编译器相比，D8 运行速度更快，生成的 .dex 文件更小且具有同等或更好的运行时性能。<br>R8是一种用于执行代码压缩和混淆的新工具，可以兼容Proguard配置。</p>
<p><img src="http://ww1.sinaimg.cn/large/8b331ee1gy1g97vkangu7j216l0g5wfm.jpg" alt="之前的编译流程"><br><img src="http://ww1.sinaimg.cn/large/8b331ee1gy1g97vl213aqj215s0j5dgr.jpg" alt="新一代的编译流程"></p>
<p>有关D8 &amp; R8更多内容可以看这几篇文章：<br><a href="https://proandroiddev.com/android-cpu-compilers-d8-r8-a3aa2bfbc109" target="_blank" rel="external">Android CPU, Compilers, D8 &amp; R8</a><br><a href="https://jakewharton.com/d8-optimizations/" target="_blank" rel="external">D8 Optimizations</a><br><a href="https://jakewharton.com/r8-optimization-staticization/" target="_blank" rel="external">R8 Optimization: Staticization</a></p>
<p>为了使用R8，需要将项目AGP版本升级到3.4.1以上。<br>升级过程中遇到以下：<br>1、gradle api变动的问题，需要修改gradle plugin兼容性的api。<br><a href="https://github.com/getsentry/sentry-java/pull/724/files" target="_blank" rel="external">GRADLE Support AGP 3.4.0</a><br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123; <span class="comment">// Android Gradle Plugin &gt;= 3.3.0</span></div><div class="line">    <span class="keyword">return</span> variantOutput.processManifestProvider.get().manifestOutputDirectory.get().asFile</div><div class="line">&#125; <span class="keyword">catch</span> (Exception ignored) &#123;&#125;</div><div class="line"><span class="keyword">try</span> &#123; <span class="comment">// Android Gradle Plugin &lt; 3.0.0</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> File(variantOutput.processManifest.manifestOutputFile).parentFile</div><div class="line">&#125; <span class="keyword">catch</span> (Exception ignored) &#123;&#125;</div></pre></td></tr></table></figure></p>
<p>2、3.4.2版本的data binding需要把包名改成小写，大写的包名会被databinding-compiler误当做类名，编译报错。</p>
<p>配置打开D8 &amp; R8<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">android.enableD8=<span class="keyword">true</span></div><div class="line">android.enableR8=<span class="keyword">true</span></div></pre></td></tr></table></figure></p>
<p>开启D8 &amp; R8后，apk包大小减少了约1.3M，减少了1w多个方法。<br>但是在测试tinker升级的过程中发现，开启R8会造成mapping冲突问题，暂时只能先关闭R8。</p>
<h4 id="删除R类"><a href="#删除R类" class="headerlink" title="删除R类"></a>删除R类</h4><p>经过删除R类优化后，apk包大小减少245K。<br><img src="http://ww1.sinaimg.cn/large/8b331ee1gy1g97vql8v2gj21ty01ndfy.jpg" alt="R文件剔除效果"></p>
<p>可以通过下面命令检测R类是否删除成功。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">find . -name <span class="string">'*.dex'</span> | xargs dexdump | grep <span class="string">'Class descriptor'</span>|grep <span class="_">-e</span> <span class="string">'R\$'</span></div></pre></td></tr></table></figure></p>
<p>Android组件化工程会导致生成很多冗余的R类字段<br>Android多项目构建时，会将子项目生成R文件中的字段都声明为非 final类型，将 ID 的最终分配延迟到编译的打包期间，这样虽然可以提升构建性能和防止资源索引冲突，但是却带来了很多冗余的字段被打包到了最终的 APK，体现在两点：</p>
<ul>
<li>每个子项目都会产生一个R文件，造成R文件数量增多</li>
<li>项目依赖层级越深，产生冗余的R类字段就越多</li>
</ul>
<p>首先想到的是通过Proguard对R类做内联优化，但是项目中有反射R类的情况，proguard处理有bug，不会内联，第2种方案是基于 ASM 在字节码层面内联优化，优点是可增加白名单支持反射R类的场景。</p>
<p>基本原理是注册Gradle Transform，在由class到dex转换阶段，通过ASM技术操作修改class文件，读取所有的R类，将字段名和值记录起来，然后替换有对R类字段引用的地方。<br>由于存在反射R类的情况，需要额外支持一下白名单配置。<br><img src="http://ww1.sinaimg.cn/large/8b331ee1gy1gd5122v3kmj20s20jzjus.jpg" alt="screenshot.png"></p>
<h3 id="其它优化"><a href="#其它优化" class="headerlink" title="其它优化"></a>其它优化</h3><h4 id="渠道包"><a href="#渠道包" class="headerlink" title="渠道包"></a>渠道包</h4><p>有些代码资源只会在某些渠道apk中用到,没有必要打包到基线中，可以通过<code>flavors</code>配置。</p>
<h4 id="插件化"><a href="#插件化" class="headerlink" title="插件化"></a>插件化</h4><p>通过将功能较独立的业务做成插件，独立下发的方式，从而达到减少包体积的效果。</p>
<p>项目中由于语音模块相对较独立，风险点较小，我们首先对它进行了插件化改造试点。语音模块插件化之后，apk包大小减少了约2.7MB。</p>
<p>经过一个版本的线上数据观察（crash率无明显异常、插件安装成功率在99%以上），验证了插件化方案的可行性，于是我们开始着手Hippy模块的插件化<br>Hippy模块插件化之后，apk包大小减少了约4.2MB。</p>
<h4 id="自动化持续监控"><a href="#自动化持续监控" class="headerlink" title="自动化持续监控"></a>自动化持续监控</h4><p>包大小的持续监控方面，我们通过在蓝盾上构建一个用于监控apk大小的流水线，配置Git事件触发，每次代码push触发apk构建，通过配置IPT可检查每个版本跟上一个版本包大小的差值，超过阈值会导致构建失败，并通知开发者。这时可以通过查看具体的代码变更记录找出造成包体积增大的具体原因。<br><img src="http://ww1.sinaimg.cn/large/8b331ee1gy1gd51cigcfmj20v80kv0vv.jpg" alt="screenshot.png"><br><img src="http://ww1.sinaimg.cn/large/8b331ee1gy1gajjze1e2ij20ia0jcjth.jpg" alt="apk_monitor pipeline"></p>
<p>结合IPT和<a href="https://github.com/Tencent/matrix/wiki/Matrix-Android-ApkChecker" target="_blank" rel="external">Matrix-ApkChecker</a>可以帮助我们快速分析包体积增大的原因，如无用资源、大文件、重复文件、R 文件等。</p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>经过了几个迭代版本，通过native优化、删除无用重复资源、图片压缩、图片网络化、资源压缩、proguard配置、Dex方法数优化、删除R类、插件化等优化手段，<br>将apk从37.16MB减少到15.16MB。<br>通过自动化持续监控apk包大小，缩短问题发现路径，提升优化效率。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;导言&quot;&gt;&lt;a href=&quot;#导言&quot; class=&quot;headerlink&quot; title=&quot;导言&quot;&gt;&lt;/a&gt;导言&lt;/h2&gt;&lt;p&gt;随着业务快速增长，我们面临apk包体积不断增长的问题，在4.2版本包体积达到了历史最高点37.16MB，远远大于各竞品。包体积过大会影响到下
    
    </summary>
    
    
      <category term="android" scheme="http://felixzhang00.github.io/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>webview接入HttpDNS实践</title>
    <link href="http://felixzhang00.github.io/2017/10/19/webview%E6%8E%A5%E5%85%A5HttpDNS%E5%AE%9E%E8%B7%B5/"/>
    <id>http://felixzhang00.github.io/2017/10/19/webview接入HttpDNS实践/</id>
    <published>2017-10-19T01:45:42.000Z</published>
    <updated>2017-10-19T02:04:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文是对去年做的webview接入HttpDNS工作的一个总结，拖的时间有点久了。主要分享了GOT Hook webview中域名解析函数的方法。</p>
<h2 id="HttpDNS简介"><a href="#HttpDNS简介" class="headerlink" title="HttpDNS简介"></a>HttpDNS简介</h2><p>首先简单介绍下移动App接入HttpDNS后有什么好处，这里直接引用腾讯云文档中的<a href="https://www.qcloud.com/document/product/379/3520" target="_blank" rel="external">说明</a>:</p>
<blockquote>
<p>HttpDNS是通过将移动APP及桌面应用的默认域名解析方式，替换为通过Http协议进行域名解析，以规避由运营商Local DNS服务异常所导致的用户网络接入异常。减少用户跨网访问，降低用户解析域名时延。</p>
</blockquote>
<p>更详细的内容可以参考这篇文章：<a href="https://mp.weixin.qq.com/s?__biz=MzA3ODgyNzcwMw==&amp;mid=201837080&amp;idx=1&amp;sn=b2a152b84df1c7dbd294ea66037cf262&amp;scene=2&amp;from=timeline&amp;isappinstalled=0&amp;utm_source=tuicool" target="_blank" rel="external">【鹅厂网事】全局精确流量调度新思路-HttpDNS服务详解</a></p>
<h2 id="移动端的实现原理"><a href="#移动端的实现原理" class="headerlink" title="移动端的实现原理"></a>移动端的实现原理</h2><p>域名的解析工作将在HttpDNS服务器上完成，客户端只要把待解析的域名作为参数发起一个HTTP请求，HttpDNS服务器就会把解析结果下发给客户端了。<br>在客户端，默认的域名解析是系统的<code>getaddrinfo()</code>库函数实现的，默认的域名解析请求会走到LocalDNS。<br>所以域名解析的工作必须要交给app应用层来实现。下面介绍几种实现方案。</p>
<h3 id="1、okhttp"><a href="#1、okhttp" class="headerlink" title="1、okhttp"></a>1、okhttp</h3><p>okhttp的实现是建立在socket之上的，并且实现了HTTP协议。对于客户端发起的http请求，okhttp首先会跟远端服务器建立socket连接，在此之前okhttp会根据http请求中url的domain做域名解析，默认的实现是java网络库提供的<code>InetAddress.getAllByName</code>。</p>
<p>如果项目中用的网络库是okhttp，所有的网络请求都是通过它完成的话就可以使用okhttp提供的DNS解析接口，实现自己的DNS resolver，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpDns</span> <span class="keyword">implements</span> <span class="title">Dns</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> List&lt;InetAddress&gt; <span class="title">lookup</span><span class="params">(String hostname)</span> <span class="keyword">throws</span> UnknownHostException </span>&#123;</div><div class="line">	    <span class="comment">//DNSHelper完成DNS解析的具体工作，向HttpDNS服务器请求服务。</span></div><div class="line">        String ip = DNSHelper.getIpByHost(hostname);</div><div class="line">        List&lt;InetAddress&gt; inetAddresses = Arrays.asList(InetAddress.getAllByName(ip));</div><div class="line">        <span class="keyword">return</span> inetAddresses;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="2、native-hook的方法"><a href="#2、native-hook的方法" class="headerlink" title="2、native hook的方法"></a>2、native hook的方法</h3><p>通过Hook libc的<code>getaddrinfo</code>库函数，将函数指针指向app应用层实现的DNS解析函数地址。<br>要深入了解linux native hook的技术的话，需要了解ELF文件格式和动态链接的相关知识，可参考<a href="http://blog.csdn.net/u012455213/article/details/53862637" target="_blank" rel="external">ELF文件及android hook原理</a>。</p>
<p><code>getaddrinfo</code>是在libc.so中的定义的，其它库如<code>libandroid_runtime.so</code>、<code>libjavacore.so</code>要使用这个函数的话，只能通过动态导入符号的形式，好在java网络库底层是就是通过这个方式实现的。</p>
<h3 id="android-nativehook原理"><a href="#android-nativehook原理" class="headerlink" title="android nativehook原理"></a>android nativehook原理</h3><p>下面代码是arm架构的一种实现方案，具体实现参考Andrey Petrov的<a href="http://shadowwhowalks.blogspot.com/2013/01/android-hacking-hooking-system.html" target="_blank" rel="external">blog</a>. </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"linker.h"</span>  <span class="comment">// get it from bionic</span></span></div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">elfhash</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *_name)</span></span>; <span class="comment">//hash函数</span></div><div class="line"><span class="comment">//查找散列表。经典的链接法解决散列冲突</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> Elf32_Sym *<span class="title">soinfo_elf_lookup</span><span class="params">(soinfo *si, <span class="keyword">unsigned</span> hash, <span class="keyword">const</span> <span class="keyword">char</span> *name)</span>  </span></div><div class="line"> &#123;  </div><div class="line">   Elf32_Sym *s;  </div><div class="line">   Elf32_Sym *symtab = si-&gt;symtab;  </div><div class="line">   <span class="keyword">const</span> <span class="keyword">char</span> *strtab = si-&gt;strtab;  </div><div class="line">   <span class="keyword">unsigned</span> n;  </div><div class="line">   n = hash % si-&gt;nbucket;  </div><div class="line">   <span class="keyword">for</span>(n = si-&gt;bucket[hash % si-&gt;nbucket]; n != <span class="number">0</span>; n = si-&gt;chain[n])&#123;  </div><div class="line">     s = symtab + n;  </div><div class="line">     <span class="keyword">if</span>(<span class="built_in">strcmp</span>(strtab + s-&gt;st_name, name)) <span class="keyword">continue</span>;  </div><div class="line">       <span class="keyword">return</span> s;  </div><div class="line">     &#125;  </div><div class="line">   <span class="keyword">return</span> <span class="literal">NULL</span>;  </div><div class="line"> &#125;  </div><div class="line"></div><div class="line"></div><div class="line"> <span class="comment">//soname:动态库名称;</span></div><div class="line"> <span class="comment">//symbol:待hook的函数名;</span></div><div class="line"> <span class="comment">//newval:新函数地址</span></div><div class="line"> <span class="function"><span class="keyword">int</span> <span class="title">hook_call</span><span class="params">(<span class="keyword">char</span> *soname, <span class="keyword">char</span> *symbol, <span class="keyword">unsigned</span> newval)</span> </span>&#123;  </div><div class="line">  soinfo *si = <span class="literal">NULL</span>;  </div><div class="line">  Elf32_Rel *rel = <span class="literal">NULL</span>;  </div><div class="line">  Elf32_Sym *s = <span class="literal">NULL</span>;   </div><div class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> sym_offset = <span class="number">0</span>;  </div><div class="line">  <span class="comment">//打开动态库，得到soinfo对象</span></div><div class="line">  si = (soinfo*) dlopen(soname, <span class="number">0</span>);  </div><div class="line"> <span class="comment">//通过查找散列表找到symbol对应符号表的索引</span></div><div class="line">  s = soinfo_elf_lookup(si, elfhash(symbol), symbol);  </div><div class="line">  sym_offset = s - si-&gt;symtab;  </div><div class="line">  </div><div class="line">  rel = si-&gt;plt_rel;<span class="comment">//指向plt表的起始位置  </span></div><div class="line">  <span class="comment">//遍历plt表</span></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; si-&gt;plt_rel_count; i++, rel++) &#123;  </div><div class="line">   <span class="keyword">unsigned</span> type = ELF32_R_TYPE(rel-&gt;r_info);  </div><div class="line">   <span class="keyword">unsigned</span> sym = ELF32_R_SYM(rel-&gt;r_info);  </div><div class="line">   <span class="comment">//加上动态库的基址，定位到该符号重定向元素的内存</span></div><div class="line">   <span class="keyword">unsigned</span> reloc = (<span class="keyword">unsigned</span>)(rel-&gt;r_offset + si-&gt;base);  </div><div class="line">   <span class="keyword">uint32_t</span> page_size = <span class="number">0</span>;</div><div class="line">   <span class="keyword">uint32_t</span> entry_page_start = <span class="number">0</span>;</div><div class="line">   <span class="keyword">unsigned</span> oldval = <span class="number">0</span>;  </div><div class="line">   <span class="keyword">if</span> (sym_offset == sym) &#123;  <span class="comment">//是否是待hook的符号位置</span></div><div class="line">    <span class="keyword">switch</span>(type) &#123;  </div><div class="line">      <span class="keyword">case</span> R_ARM_JUMP_SLOT:</div><div class="line">	     <span class="comment">//修改内存页的属性为可读写  </span></div><div class="line">         page_size = getpagesize();</div><div class="line">         entry_page_start = reloc&amp; (~(page_size - <span class="number">1</span>));</div><div class="line">         <span class="keyword">int</span> ret = mprotect((<span class="keyword">uint32_t</span> *)entry_page_start, page_size, PROT_READ | PROT_WRITE); </div><div class="line">         </div><div class="line">         oldval = *(<span class="keyword">unsigned</span>*) reloc;  </div><div class="line">         *((<span class="keyword">unsigned</span>*)reloc) = newval;  <span class="comment">//成功替换这块内存的值为新函数的地址值 </span></div><div class="line">         <span class="keyword">return</span> <span class="number">1</span>;  </div><div class="line">      <span class="keyword">default</span>:  </div><div class="line">         <span class="keyword">return</span> <span class="number">0</span>;  </div><div class="line">    &#125;  </div><div class="line">   &#125;  </div><div class="line">  &#125;  </div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;  </div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>程序中调用mprotect的作用是： 修改一段指定内存区域的保护属性。以防万一，将这它改为可读写，因为后面就要对这块内存做写操作了。<br><a href="https://linux.die.net/man/2/mprotect" target="_blank" rel="external">函数原型</a>为：<code>int mprotect(const void *start, size_t len, int prot);</code><br>mprotect()函数把自start开始的、长度为len的内存区的保护属性修改为prot指定的值。<br>需要指出的是，指定的内存区间必须包含整个内存页（4K）。区间开始的地址start必须是一个内存页的起始地址，并且区间长度len必须是页大小的整数倍。</p>
<p>用法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hook_call(&quot;libjavacore.so&quot;, &quot;getaddrinfo&quot;, &amp;my_getaddrinfo);</div></pre></td></tr></table></figure></p>
<ul>
<li>1.调用dlopen拿到so的句柄,得到soinfo,它包含了符号表、重定位表、plt表等信息。</li>
<li>2.查找需要hook的函数的符号，得到它在符号表中的索引。</li>
<li>3.遍历plt表，直到匹配第2步中找到的符号索引。<br>如果是JUMP_SLOT类型（函数调用），替换为新的符号地址（函数指针）。<br>如下图所示，<code>my_code_func</code>的函数地址替换了GOT表项中原来指向libc中的<code>getaddrinfo</code>函数地址,达到了hook的效果。<br><img src="http://ww1.sinaimg.cn/large/8b331ee1gy1fknbjaa5c4j215m0q0jur.jpg" alt=""></li>
</ul>
<p>跟进一步地，可以把设备上的<code>libjavacore.so</code>导出，用IDA Pro打开，观察<code>getaddrinfo</code>的引用关系，将有助于理解上面的代码。</p>
<p>找到<code>libjavacore.so</code>中<code>getaddrinfo</code>导入符号的位置：<br><img src="http://ww1.sinaimg.cn/large/8b331ee1gy1fknbmf8o6oj20lc09o75g.jpg" alt=""><br><img src="http://ww1.sinaimg.cn/large/8b331ee1gy1fknbmu8d3cj218i0203z9.jpg" alt=""></p>
<p>定位到<code>getaddrinfo</code>在plt表中引用的位置：<br><img src="http://ww1.sinaimg.cn/large/8b331ee1gy1fknbn5ojkjj21ga03ygn7.jpg" alt=""></p>
<p>定位到<code>getaddrinfo</code>在GOT表中引用的位置：<br><img src="http://ww1.sinaimg.cn/large/8b331ee1gy1fknbnfg0q4j215q02ota6.jpg" alt=""></p>
<p>定位到在代码段中调用<code>getaddrinfo</code>的位置：<br><img src="http://ww1.sinaimg.cn/large/8b331ee1gy1fknbnwwei1j20yy044q44.jpg" alt=""></p>
<p>通过分析得知，虽然<code>getaddrinfo</code>是<code>libc.so</code>的导出函数，但是这种方法无法hook导出函数，没有一劳永逸的方法，只能hook导入函数，因为这种方案是通过修改GOT表项实现的，这是它的缺陷。</p>
<h3 id="3、webview"><a href="#3、webview" class="headerlink" title="3、webview"></a>3、webview</h3><p>webview作为H5的容器，在做网络请求的时候也需要做DNS域名解析，要对其接入HttpDNS的一般做法是通过拦截WebView的各类网络请求，截取URL请求的host，然后调用HttpDns解析该host，通过得到的ip组成新的URL来请求网络地址。<br>不过这种方式只能处理资源，处理正常的http/https请求会存在问题。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> WebResourceResponse <span class="title">shouldInterceptRequest</span><span class="params">(WebView view, WebResourceRequest request)</span> </span>&#123; </div><div class="line">	<span class="keyword">if</span> (request.getMethod().equalsIgnoreCase(<span class="string">"get"</span>)) &#123; </div><div class="line">		String url = request.getUrl().toString(); </div><div class="line">		<span class="comment">// HttpDns解析css文件的网络请求及图片请求 </span></div><div class="line">		<span class="keyword">if</span> (url.contains(<span class="string">".css"</span>) || url.endsWith(<span class="string">".png"</span>)) &#123; </div><div class="line">		<span class="keyword">try</span> &#123; </div><div class="line">			URL oldUrl = <span class="keyword">new</span> URL(url); </div><div class="line">			URLConnection connection = oldUrl.openConnection(); </div><div class="line">			<span class="comment">// 获取HttpDns域名解析结果 </span></div><div class="line">			String ips = MSDKDnsResolver.getInstance().getAddrByName(oldUrl.getHost()); </div><div class="line">			String newUrl = url.replaceFirst(oldUrl.getHost(), ip); </div><div class="line">			<span class="comment">// 设置HTTP请求头Host域 </span></div><div class="line">			connection = (HttpURLConnection) <span class="keyword">new</span> URL(newUrl).openConnection(); </div><div class="line">			connection.setRequestProperty(<span class="string">"Host"</span>, oldUrl.getHost()); </div><div class="line">			&#125;</div><div class="line">			<span class="keyword">return</span> <span class="keyword">new</span> WebResourceResponse(<span class="string">"text/css"</span>, <span class="string">"UTF-8"</span>, connection.getInputStream()); </div><div class="line">		&#125;</div><div class="line">	&#125;&#125;</div></pre></td></tr></table></figure></p>
<p>必须要对webview的DNS域名解析函数进行拦截替换。<br>webview的DNS域名解析函数具体实现是在<code>chromiumn.so</code>，不同版本的实现也不同，5.0版本的代码见<a href="http://androidxref.com/5.0.0_r2/xref/external/chromium_org/ppapi/cpp/host_resolver.h" target="_blank" rel="external">host_resolver.h</a><br>webview的DNS域名解析函数是否也跟java的网络库一样最终调用的<code>libc.so</code>动态库中<code>getaddrinfo</code>呢？<br>通过源码注释得知确实如此。<br><img src="http://ww1.sinaimg.cn/large/8b331ee1gy1fknbo84ymdj21aa08sq77.jpg" alt=""><br><a href="http://blog.csdn.net/u012455213/article/details/54691340" target="_blank" rel="external">用Android Studio调试Framework层代码</a>中也对其进行过断点调试。<br>所以解决方法很简单，只需要hook <code>libchromium_net.so</code>中<code>getaddrinfo</code>导入符号即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hook_call(&quot;libchromium_net.so&quot;, &quot;getaddrinfo&quot;, &amp;my_getaddrinfo);</div></pre></td></tr></table></figure></p>
<h2 id="机型问题"><a href="#机型问题" class="headerlink" title="机型问题"></a>机型问题</h2><p>在实践中我们发现，不同机型不同版本的android在实现DNS解析函数的导出符号是不同的，更糟糕的是调用DNS解析函数的动态库也不一定就是<code>libjavacore.so</code>。<br>我之前定位过Android5.0设备的DNS解析函数，发现它的名字改为<code>android_getaddrinfofornet</code>。<br><img src="http://ww1.sinaimg.cn/large/8b331ee1gy1fknbok6ktgj213y0f20tk.jpg" alt=""><br>webview的so库位置也曾遇到过找不到的问题。</p>
<p>解决方法是通过一个脚本，pull下测试设备上的所有so到主机上，然后用readelf工具查找so的导入符号，观察是否有<code>getaddrinfo</code>字样的导入符号。<br>为此我写了一个<a href="https://github.com/FelixZhang00/so-finder" target="_blank" rel="external">脚本</a>，方便自动化进行。运行如下命令即可<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ python sofinder.py <span class="_">-e</span> getaddrinfo</div></pre></td></tr></table></figure></p>
<p><img src="http://ww1.sinaimg.cn/large/8b331ee1gy1fknbotls24j20wj0bw74u.jpg" alt=""><br>在上面输出的第一行可以看到，android 5.0以上版本webview的so已经被放在system/app目录中了。<br>需要写全so的路径：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hook_call(&quot;/system/app/WebViewGoogle/lib/arm/libwebviewchromium.so&quot;, &quot;getaddrinfo&quot;, &amp;my_getaddrinfo);</div></pre></td></tr></table></figure></p>
<hr>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://mp.weixin.qq.com/s?__biz=MzA3ODgyNzcwMw==&amp;mid=201837080&amp;idx=1&amp;sn=b2a152b84df1c7dbd294ea66037cf262&amp;scene=2&amp;from=timeline&amp;isappinstalled=0&amp;utm_source=tuicool" target="_blank" rel="external">【鹅厂网事】全局精确流量调度新思路-HttpDNS服务详解</a><br><a href="http://blog.csdn.net/u012455213/article/details/53862637" target="_blank" rel="external">ELF文件及android hook原理</a><br><a href="http://shadowwhowalks.blogspot.com/2013/01/android-hacking-hooking-system.html" target="_blank" rel="external">Andrey Petrov’s blog</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是对去年做的webview接入HttpDNS工作的一个总结，拖的时间有点久了。主要分享了GOT Hook webview中域名解析函数的方法。&lt;/p&gt;
&lt;h2 id=&quot;HttpDNS简介&quot;&gt;&lt;a href=&quot;#HttpDNS简介&quot; class=&quot;headerlink&quot; 
    
    </summary>
    
    
      <category term="android" scheme="http://felixzhang00.github.io/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>JVM的简单实现</title>
    <link href="http://felixzhang00.github.io/2017/10/08/JVM%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/"/>
    <id>http://felixzhang00.github.io/2017/10/08/JVM的简单实现/</id>
    <published>2017-10-08T02:27:22.000Z</published>
    <updated>2017-10-08T02:28:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍java虚拟机的一些知识，并以<a href="https://github.com/zxh0/jvmgo" target="_blank" rel="external">jvmgo</a>为例介绍一些虚拟机的简单实现。jvmgo是用Go语言实现的java虚拟机，其作者说这个项目的主要目的是学习Go和JVM，所以只是一个toy，对于破除JVM的神秘感还是很有帮助的。</p>
<h2 id="class类文件结构"><a href="#class类文件结构" class="headerlink" title="class类文件结构"></a>class类文件结构</h2><p>使用java编译器（java程序用javac，Groovy程序用groovyc编译器）可以把java代码编译位存储字节码的class文件，虚拟机并不关心class文件的来源是何种语言。这种做法达到了语言无关性的目的。另外有各种可以运行在不同操作系统上的虚拟机，都可以载入和执行同一种平台无关的字节码，实现了平台无关性。</p>
<p>class文件是一组以8位字节为基础单位的二进制流，占用8位字节以上空间的数据项时以大端方式存储，最高位字节在地址最低位。<br>Class文件格式采用下面伪结构来存储数据，只有两种数据类型：无符号数和表。无符号数可以作为指向表的索引，或者bitmask。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">ClassFile &#123;</div><div class="line">    u4             magic;</div><div class="line">    u2             minor_version;</div><div class="line">    u2             major_version;</div><div class="line">    u2             constant_pool_count;</div><div class="line">    cp_info        constant_pool[constant_pool_count<span class="number">-1</span>];</div><div class="line">    u2             access_flags;</div><div class="line">    u2             this_class;</div><div class="line">    u2             super_class;</div><div class="line">    u2             interfaces_count;</div><div class="line">    u2             interfaces[interfaces_count];</div><div class="line">    u2             fields_count;</div><div class="line">    field_info     fields[fields_count];</div><div class="line">    u2             methods_count;</div><div class="line">    method_info    methods[methods_count];</div><div class="line">    u2             attributes_count;</div><div class="line">    attribute_info attributes[attributes_count];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>class字节码文件可以用图形化工具<a href="https://github.com/zxh0/classpy" target="_blank" rel="external">classpy</a>查看，比命令行工具javap更加方便参看。效果如下：<br><img src="https://ws1.sinaimg.cn/large/8b331ee1gy1fk9xxqguobj20qo0fmqms.jpg" alt=""><br>在<a href="https://github.com/zxh0/jvmgo" target="_blank" rel="external">jvmgo</a>中用ClassFile结构体表示，把.class文件以字节流的方式读出，然后填到这个结构体中。</p>
<p>calss文件格式详情可以看《Java虚拟机规范》和jvm相关文档:<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html" target="_blank" rel="external">The class File Format</a>.<br>这里简单举几个例子。</p>
<h3 id="方法表"><a href="#方法表" class="headerlink" title="方法表"></a>方法表</h3><p>一个方法用如下数据结构表示后缀_index表示是指向常量池的索引。<br>name_index指出了方法名。<br>descriptor_index指出了方法返回值和参数列表信息，是java中方法重载的关键。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">method_info &#123;</div><div class="line">    u2             access_flags;</div><div class="line">    u2             name_index;</div><div class="line">    u2             descriptor_index;</div><div class="line">    u2             attributes_count;</div><div class="line">    attribute_info attributes[attributes_count];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如下是javac编译器为类自动生成的<code>&lt;init&gt;</code>默认构造函数，它的名称索引和描述符索引分别指向常量池中对应的位置。<br>方法表第0项：<br><img src="https://ws1.sinaimg.cn/large/8b331ee1gy1fk9yuptfkyj20d4094q3p.jpg" alt=""><br>常量池第12、13项：<br><img src="https://ws1.sinaimg.cn/large/8b331ee1gy1fk9yyrdm38j208o0b8t9b.jpg" alt=""></p>
<h3 id="属性表"><a href="#属性表" class="headerlink" title="属性表"></a>属性表</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">attribute_info &#123;</div><div class="line">    u2 attribute_name_index;</div><div class="line">    u4 attribute_length;</div><div class="line">    u1 info[attribute_length];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在Class文件、字段表、方法表都可以携带自己的属性表结合，用于描述某些场景专有的信息。<br>属性是可以扩展的，不同的虚拟机实现可以定义自己的属性类型。由于这个原因，Java虚拟机规范没有使用tag，而是使用属性名来区别不同的属性</p>
<p>Code属性中存放字节码等方法相关信息。<br>Code是变长属性，只存在于method_info结构中。在classpy中观察main方法的code属性如下，其中max_stack代表了操作数栈(Operand Stacks)深度的最大值。max_locaks代表了局部变量表所需的存储空间（包括方法参数），code_length和code用来存储java程序编译后生成的字节码指令。<br><img src="https://ws1.sinaimg.cn/large/8b331ee1gy1fk9z5t2wllj20j00qqn01.jpg" alt=""></p>
<hr>
<h2 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h2><p><img src="https://ws1.sinaimg.cn/large/8b331ee1gy1fk9zjn57t3j21fs0ya3zx.jpg" alt="运行时数据区"><br>在运行Java程序时，虚拟机需要使用内存来存放各种的数据，这个内存区域就是运行时数据区。<br>多线程共享的内存区域主要存放两类数据：类数据和类实例 （也就是对象Object）。对象数据存放在堆（Heap）中，类数据存放在方法区 （Method Area）中。堆由垃圾收集器GC定期清理。类数据包括字段和方法信息、方法的字节码、 运行时常量池，等等。<br>线程私有的运行时数据区用于辅助执行Java字节码。每个线程都有自己的pc寄存器（Program Counter）和Java虚拟机栈（JVM Stack）。Java虚拟机栈又由栈帧（Stack Frame）构成，帧中保存方法执行的状态，包括局部变量表（Local Variable）和操作数栈（Operand Stack）等。如果当前方法是Java方法，则 pc寄存器中存放当前正在执行的Java虚拟机指令的地址，否则，当前方法是本地方法，pc寄存器中的值没有明确定义。</p>
<h2 id="解释器"><a href="#解释器" class="headerlink" title="解释器"></a>解释器</h2><p><a href="https://github.com/zxh0/jvmgo" target="_blank" rel="external">jvmgo</a>中虚拟机字节码执行引擎代码如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">interpret</span><span class="params">(method *heap.Method)</span></span> &#123;</div><div class="line">	thread := rtda.NewThread()</div><div class="line">	frame := thread.NewFrame(method)</div><div class="line">	thread.PushFrame(frame)</div><div class="line">	loop(thread)</div><div class="line">&#125;</div><div class="line">	</div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">loop</span><span class="params">(thread *rtda.Thread)</span></span> &#123;</div><div class="line">	reader := &amp;base.BytecodeReader&#123;&#125;</div><div class="line">	<span class="keyword">for</span> &#123;</div><div class="line">		frame := thread.CurrentFrame()</div><div class="line">		pc := frame.NextPC()</div><div class="line">		thread.SetPC(pc)</div><div class="line">		<span class="comment">// decode</span></div><div class="line">		reader.Reset(frame.Method().Code(), pc)</div><div class="line">		opcode := reader.ReadUint8()</div><div class="line">		inst := instructions.NewInstruction(opcode)</div><div class="line">		inst.FetchOperands(reader)</div><div class="line">		frame.SetNextPC(reader.PC())</div><div class="line">		<span class="comment">// execute</span></div><div class="line">		inst.Execute(frame)</div><div class="line">		<span class="keyword">if</span> thread.IsStackEmpty() &#123;</div><div class="line">			<span class="keyword">break</span></div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>interpret()法的参数是MemberInfo指针，调用MemberInfo结 构体的CodeAttribute()法可以获取它的Code属性，从class文件结构中得到bytecode、maxstack等信息后，创建一个Frame，在一个loop中不停循环解释字节码。</p>
<p>每个指令是一个u1类型的单字节，当虚拟机读取到code中的一个字节码时，就可以对应找出这个字节码代表什么指令，并且可以知道这条指令后面是否需要跟随参数，以及参数应当如何理解。<br>如iload指令根据第一个操作数作为索引从局部变量表取出一个int值，然后push到操作数栈。<br>指令比较多，做个总结的话，无非是从操作数栈或者局部变量表取出来，算一算，把结果再放回运行时数据区，如果遇到跳转指令就改变下frame上的pc。</p>
<h2 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h2><p>虚拟机的类加载机制：虚拟机把class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的java类型。</p>
<p>java代码在进行javac编译的时候，并没有链接这一步骤，而是在虚拟机加载Class文件的时候进行动态链接。所以在Class文件中不会保存各个方法、字段的最终内存布局信息，当虚拟机运行时，需要从常量池获得对应的符号引用，再在类创建时或运行时解析翻译到具体的内存地址之中。<br>在jvmgo中有class_loader的parseClass方法完成类和字段符号引用解析。</p>
<p>类的加载大致可以分为三个步骤：首先找到class文件并把数据读取到内存；然后解析class文件，生成虚拟机可以使用的类数据，并放入方法区；最后进行链接。<br>jvmgo中相关实现如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> ClassLoader <span class="keyword">struct</span> &#123;</div><div class="line">	cp          *classpath.Classpath</div><div class="line">	classMap    <span class="keyword">map</span>[<span class="keyword">string</span>]*Class <span class="comment">// loaded classes</span></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(self *ClassLoader)</span> <span class="title">loadNonArrayClass</span><span class="params">(name <span class="keyword">string</span>)</span> *<span class="title">Class</span></span> &#123;</div><div class="line">   data, entry := self.readClass(name)</div><div class="line">   class := self.defineClass(data)</div><div class="line">   link(class)</div><div class="line">   <span class="keyword">return</span> class</div><div class="line">&#125;</div><div class="line"><span class="comment">// jvms 5.3.5</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(self *ClassLoader)</span> <span class="title">defineClass</span><span class="params">(data []<span class="keyword">byte</span>)</span> *<span class="title">Class</span></span> &#123;</div><div class="line">   class := parseClass(data) <span class="comment">//把class文件数据转换成Class结构体</span></div><div class="line">   class.loader = self</div><div class="line">   resolveSuperClass(class) <span class="comment">//解析类符号引用</span></div><div class="line">   resolveInterfaces(class)</div><div class="line">   self.classMap[class.name] = class</div><div class="line">   <span class="keyword">return</span> class</div><div class="line">&#125;</div><div class="line"><span class="comment">// jvms 5.4.3.1</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">resolveSuperClass</span><span class="params">(class *Class)</span></span> &#123;</div><div class="line">   <span class="keyword">if</span> class.name != <span class="string">"java/lang/Object"</span> &#123;</div><div class="line">      class.superClass = class.loader.LoadClass(class.superClassName)</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">link</span><span class="params">(class *Class)</span></span> &#123;</div><div class="line">   verify(class)</div><div class="line">   prepare(class) <span class="comment">//准备阶段主要是给类变量分配空间并给予初始值</span></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">prepare</span><span class="params">(class *Class)</span></span> &#123;</div><div class="line">	calcInstanceFieldSlotIds(class) </div><div class="line">	calcStaticFieldSlotIds(class) <span class="comment">//计算并分配静态变量所需内存</span></div><div class="line">	allocAndInitStaticVars(class)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h2><p>java虚拟机提供了5条方法调用字节码指令：<br>invokestatic指令：调用静态方法。<br>invokespecial指令：调用无须动态绑定的实例方法，包括构造函数、私有方法和通过super 关键字调用的超类方法。<br>invokevirtual指令：调用所有虚方法。<br>invokeinterface指令：调用接口方法，会在运行时再确定一个实现此接口的对象。<br>invokedynamic指令：先在运行时动态解析出调用点限定符所引用的方法，然后再自行该方法，分派的逻辑是由用户所设定的引导方法决定的。</p>
<p>方法调用参数传递如下，对于实例方法，Java编译器会在参数列表的前面添加一个参数，这个隐藏的参数就是this引用。<br>依次把这n个变量从调用者的操作数栈中弹出，放进被调用方法的局部变量表中，参数传递就完成了<br><img src="https://ws1.sinaimg.cn/large/8b331ee1gy1fkalpzj75mj21ew0r0dgz.jpg" alt=""></p>
<p>在定位到需要调用的方法之后，Java虚拟机要给这个方法创建 一个新的帧并把它推入Java虚拟机栈顶，然后传递参数。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">InvokeMethod</span><span class="params">(invokerFrame *rtda.Frame, method *heap.Method)</span></span> &#123;</div><div class="line">   thread := invokerFrame.Thread()</div><div class="line">   newFrame := thread.NewFrame(method)</div><div class="line">   thread.PushFrame(newFrame)</div><div class="line"></div><div class="line">   argSlotCount := <span class="keyword">int</span>(method.ArgSlotCount())</div><div class="line">   <span class="keyword">if</span> argSlotCount &gt; <span class="number">0</span> &#123;</div><div class="line">      <span class="keyword">for</span> i := argSlotCount - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</div><div class="line">         slot := invokerFrame.OperandStack().PopSlot()</div><div class="line">         newFrame.LocalVars().SetSlot(<span class="keyword">uint</span>(i), slot)</div><div class="line">      &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>解释器的loop下一个循环就会从New Frame的开头开始执行。</p>
<h2 id="实例化对象"><a href="#实例化对象" class="headerlink" title="实例化对象"></a>实例化对象</h2><p>实例化对象主要通过new指令。<br>new指令的操作数是一个uint16索引，来自字节码。通过这个索引，<br>可以从当前类的运行时常量池中找到一个类符号引用。<br>解析这个类符号引用，拿到类数据，然后创建对象（根据类实例变量的个数分配空间），并把对象引用推入栈顶，new指令的工作就完成了。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Create new object</span></div><div class="line"><span class="keyword">type</span> NEW <span class="keyword">struct</span>&#123; base.Index16Instruction &#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(self *NEW)</span> <span class="title">Execute</span><span class="params">(frame *rtda.Frame)</span></span> &#123;</div><div class="line">	cp := frame.Method().Class().ConstantPool()</div><div class="line">	classRef := cp.GetConstant(self.Index).(*heap.ClassRef)</div><div class="line">	class := classRef.ResolvedClass()</div><div class="line">	<span class="keyword">if</span> !class.InitStarted() &#123; <span class="comment">//类初始化</span></div><div class="line">		frame.RevertNextPC()</div><div class="line">		base.InitClass(frame.Thread(), class)</div><div class="line">		<span class="keyword">return</span></div><div class="line">	&#125;</div><div class="line">	ref := class.NewObject()</div><div class="line">	frame.OperandStack().PushRef(ref)</div><div class="line">&#125;</div><div class="line"><span class="comment">//创建对象</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">newObject</span><span class="params">(class *Class)</span> *<span class="title">Object</span></span> &#123;</div><div class="line">   <span class="keyword">return</span> &amp;Object&#123;</div><div class="line">      class:  class,</div><div class="line">      fields: newSlots(class.instanceSlotCount),</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>比如对于如下的java代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyObject</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.instanceVar = a;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyObject</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span>&#123;</div><div class="line">    a = a+b;</div><div class="line">    <span class="keyword">this</span>.instanceVar = a;</div><div class="line">&#125;</div><div class="line">MyObject myObj = <span class="keyword">new</span> MyObject(<span class="number">100</span>); <span class="comment">// new</span></div></pre></td></tr></table></figure></p>
<p>编译后，再用javap反编译如下：<br><figure class="highlight powershell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="number">3</span>: new           <span class="comment">#4                  // class jvmgo/book/ch06/MyObject</span></div><div class="line"><span class="number">6</span>: dup</div><div class="line"><span class="number">7</span>: bipush        <span class="number">100</span></div><div class="line"><span class="number">9</span>: invokespecial <span class="comment">#5                  // Method "&lt;init&gt;":(I)V</span></div></pre></td></tr></table></figure></p>
<p>先调用new指令，开辟一个Object的内存空间，再调用构造函数方法，这里jvm将通过索引5找到相关的构造函数</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>jvmgo还实现了数组和字符串、本地方法调用、反射机制、自动装箱和拆箱、异常处理，感兴趣的看看。</p>
<hr>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://github.com/zxh0/jvmgo" target="_blank" rel="external">https://github.com/zxh0/jvmgo</a><br><a href="https://github.com/zxh0/classpy" target="_blank" rel="external">https://github.com/zxh0/classpy</a><br>《Java虚拟机规范》<br>《深入理解java虚拟机》<br>《自己动手写Java虚拟机》</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文介绍java虚拟机的一些知识，并以&lt;a href=&quot;https://github.com/zxh0/jvmgo&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;jvmgo&lt;/a&gt;为例介绍一些虚拟机的简单实现。jvmgo是用Go语言实现的java虚拟机，其
    
    </summary>
    
    
      <category term="java" scheme="http://felixzhang00.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>理解对C++裸指针释放后重用的问题</title>
    <link href="http://felixzhang00.github.io/2017/07/20/%E7%90%86%E8%A7%A3%E5%AF%B9C++%E8%A3%B8%E6%8C%87%E9%92%88%E9%87%8A%E6%94%BE%E5%90%8E%E9%87%8D%E7%94%A8%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://felixzhang00.github.io/2017/07/20/理解对C++裸指针释放后重用的问题/</id>
    <published>2017-07-20T00:08:16.000Z</published>
    <updated>2017-07-20T06:59:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文将以Android 2.2-2.3上的一个zergRush漏洞为例，分析指针释放后重用的问题。</p>
<p><a href="https://nvd.nist.gov/vuln/detail/CVE-2011-3874" target="_blank" rel="external">zergRush</a>是Android 2.2-2.3上的一个漏洞，主要问题就在于指针的释放后重用。<br>zergRush利用了libsysutils库提供的Framework套接字的通用接口。<br>程序从套接字收到的消息中出抽取出的文本命令会导致栈缓冲区溢出，进而造成释放后重用问题。<br>具体地，是vold后台程序调用了libsysutils.so，bug出在FrameworkListener.cpp的dispatchCommand方法。</p>
<hr>
<h2 id="什么是释放后重用"><a href="#什么是释放后重用" class="headerlink" title="什么是释放后重用"></a>什么是释放后重用</h2><p>释放后重用(Use After Free)问题是指，程序使用指针访问了一个已经通过free函数或者delete操作符释放过的对象，并且这个指针没有置空，攻击者在这块释放后的内存中写入了恶意的数据shellcode，当程序第2次使用这个指针的时候，控制流就转向了攻击者构造的恶意数据中了。</p>
<h2 id="FrameworkListener中的bug"><a href="#FrameworkListener中的bug" class="headerlink" title="FrameworkListener中的bug"></a>FrameworkListener中的bug</h2><p>FrameworkListener.cpp中有bug的关键代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//参数cli为与用户进程连接的socket链接；参数data为用户进程的命令参数</span></div><div class="line"><span class="keyword">void</span> FrameworkListener::dispatchCommand(SocketClient *cli, <span class="keyword">char</span> *data)&#123;</div><div class="line">	FrameworkCommandCollection::iterator i;</div><div class="line">    <span class="keyword">int</span> argc = <span class="number">0</span>;</div><div class="line">    <span class="comment">//在栈上临时分配的局部缓冲区，用来存放从socket中解析命令参数指针</span></div><div class="line">    <span class="keyword">char</span> *argv[<span class="number">16</span>];</div><div class="line">    <span class="comment">//栈上分配的缓冲区，存放从socket中解析命令参数数据</span></div><div class="line">    <span class="keyword">char</span> tmp[<span class="number">255</span>];</div><div class="line">    <span class="keyword">char</span> *p = data; <span class="comment">//p指向用户数据</span></div><div class="line">    <span class="keyword">char</span> *q = tmp; <span class="comment">//q指向tmp数组</span></div><div class="line">	<span class="comment">//...	</span></div><div class="line">	<span class="comment">//下面的循环遍历输入中的所有字符，直到遇到一个结尾\0</span></div><div class="line">	<span class="keyword">while</span>(*p) &#123;</div><div class="line">		<span class="comment">//...</span></div><div class="line">		<span class="comment">//将用户输入复制到缓冲区，参数放入tmp数组，但是没有检查边界</span></div><div class="line">		*q = *p++;</div><div class="line">		<span class="comment">//如果引用的字符串外面还有一个空格，则将q重置到tmp的起始位置</span></div><div class="line">        <span class="keyword">if</span> (!quote &amp;&amp; *q == <span class="string">' '</span>) &#123;</div><div class="line">            *q = <span class="string">'\0'</span>;</div><div class="line">            <span class="comment">//strdup会在堆上分配空间，返回这块堆内存的指针</span></div><div class="line">            argv[argc++] = strdup(tmp);</div><div class="line">            <span class="built_in">memset</span>(tmp, <span class="number">0</span>, <span class="keyword">sizeof</span>(tmp));</div><div class="line">            q = tmp;</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        &#125;</div><div class="line">        q++;</div><div class="line">	&#125;</div><div class="line">	argv[argc++] = strdup(tmp);</div><div class="line">    </div><div class="line">    <span class="keyword">for</span> (i = mCommands-&gt;begin(); i != mCommands-&gt;end(); ++i) &#123;</div><div class="line">        FrameworkCommand *c = *i;</div><div class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">0</span>], c-&gt;getCommand())) &#123;</div><div class="line">		    <span class="comment">//调用FrameworkCommand的虚函数</span></div><div class="line">            <span class="keyword">if</span> (c-&gt;runCommand(cli, argc, argv)) &#123;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> j;</div><div class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; argc; j++)&#123;</div><div class="line">	   <span class="comment">//因为是strdup动态分配出来的，所以需要主动释放</span></div><div class="line">       <span class="built_in">free</span>(argv[j]);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>下图是第1次调用<code>dispatchCommand</code>的内存布局：<br><img src="https://ws1.sinaimg.cn/large/8b331ee1gy1fhq0hg4cbtj20x60w2424.jpg" alt=""></p>
<p>假设其中一个FrameworkCommand对象所在的内存地址是0x12345678，这个地址值，用户进程可以在参数中以字符串的形式提供，即<code>\x78\x56\x34\x12</code>，这里要考虑到字节序，内存低地址将存放小端的字节。</p>
<p>假设参数data的数据为<code>“cmd p1 p2 p3 p4 p5 p6 p7 p8 p9 p10 p11 p12 p13 p14 p15 p16 \x78\x56\x34\x12”</code>。<br>前15个参数的处理过程中，argv数组中的元素都是正常的从strdup返回的指向堆的指针值，即指向参数字符串的指针。<br>当p指针指向p16这个参数值，argv[16]=strdup(“p16”)，这时argv[16]已经超出了argv数组的范围，此时<code>&amp;argv[16]=&amp;tmp[0]</code>，这个参数值将覆盖tmp数组的头4字节。之后tmp清空，q指针重新指向tmp数组的开头，继续读入最后一个参数。</p>
<p>继续调用<code>*q = *p++</code>,此时tmp开头4字节即为<code>\x78\x56\x34\x12</code>,同时也是argv[16]元素的值，注意到这个值有别于argv数组中其它的元素的值，其它元素的值都是strdup动态分配返回的堆指针，而argv[16]是攻击者恶意构造的地址值。</p>
<p>此时argv[16]的头4字节，也就是tmp头4字节的数据是0x78,0x56,0x34,0x12，<br>free(argv[16])调用的是free(0x12345678),即释放掉了FrameworkCommand所在内存，即这块内存被内存分配器添加到类似freelist这样的数据结构中，供下一次动态分配使用。</p>
<p>这里需要说明下strdup这个函数。<code>char* strdup(const char *s1)</code>函数会为s1指针指向的字符串数据分配等大小的内存，并返回指向这块内存的指针。因为是动态分配的，这块内存在堆上，实际使用Android系统中Bionic lib库内置的dlmalloc分配器来动态分配的。dlmalloc分配器在某些情况下内存被free后不会马上释放回内核，而是保留给应用程序重新申请。</p>
<p>下图是第2次调用<code>dispatchCommand</code>的内存布局：<br><img src="https://ws1.sinaimg.cn/large/8b331ee1gy1fhq0aprp4zj219m0wadko.jpg" alt=""><br>当用户进程第2次调用<code>dispatchCommand</code>，走到<code>argv[0] = strdup(tmp)</code>处时，strdup分配的内存就是上次释放掉的FrameworkCommand所在内存，并把tmp的字节数据拷贝到这块内存中。这时可以构造恶意数据覆盖vtable指针，让它指向shellcode的内存地址，这样当函数主动调用runCommand时，控制流就会跑到shellcode中了。比如第二次传给dispatchCommand的命令是”AAAA param”，vtable指针会被覆盖成0x41414141，EIP将被指向 <code>[0x41414141+runCommand虚函数在虚表中的偏移]</code>。剩下的问题就是如何巧妙的构造shellcode和放在哪块内存区域了。</p>
<h2 id="修复方法"><a href="#修复方法" class="headerlink" title="修复方法"></a>修复方法</h2><p>补丁<a href="https://cloud.seu.edu.cn/gitlab/frederickjoe/android-aosp-sdcard/commit/c6b0def5f039dc3bbe1d4b7dc1666c24316eb020" target="_blank" rel="external">libsysutils: Fix potential overwrites in FrameworkListener</a><br>给出了一个修复方法,增加了数组越界检查。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">+            <span class="keyword">if</span> (argc &gt;= CMD_ARGS_MAX)</div><div class="line">+                <span class="keyword">goto</span> overflow;</div></pre></td></tr></table></figure></p>
<hr>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.cnblogs.com/daishuo/p/4002963.html" target="_blank" rel="external">zergRush (CVE-2011-3874) 提权漏洞分析</a><br><a href="http://huntcve.github.io/2015/06/14/uaf/" target="_blank" rel="external">从zergRush深入理解Use After Free</a><br>《Android安全攻防权威指南》</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将以Android 2.2-2.3上的一个zergRush漏洞为例，分析指针释放后重用的问题。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://nvd.nist.gov/vuln/detail/CVE-2011-3874&quot; target=&quot;_blank&quot; rel=&quot;ex
    
    </summary>
    
    
      <category term="c++ 安全" scheme="http://felixzhang00.github.io/tags/c-%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>C++与汇编小结</title>
    <link href="http://felixzhang00.github.io/2017/07/15/C++%E4%B8%8E%E6%B1%87%E7%BC%96%E5%B0%8F%E7%BB%93/"/>
    <id>http://felixzhang00.github.io/2017/07/15/C++与汇编小结/</id>
    <published>2017-07-15T04:41:58.000Z</published>
    <updated>2017-09-13T11:35:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文通过C++反编译，帮助理解C++中的一些概念（指针引用、this指针、虚函数、析构函数、lambda表达式），<br>希望能在深入理解C++其它一些高级特性（多重继承、RTTI、异常处理）能起到抛砖引玉的作用吧</p>
<p>常用反汇编工具有：objdump、IDA Pro、<a href="https://gcc.godbolt.org/" target="_blank" rel="external">godbolt</a><br>以下代码均使用x86-64 gcc 6.3编译。</p>
<h2 id="指针和引用"><a href="#指针和引用" class="headerlink" title="指针和引用"></a>指针和引用</h2><p>引用类型的存储方式和指针是一样的，都是使用内存空间存放地址值。<br>只是引用类型是通过编译器实现寻址，而指针需要手动寻址。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">funRef</span><span class="params">(<span class="keyword">int</span> &amp;ref)</span></span>&#123;</div><div class="line">	ref++;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">	<span class="comment">//定义int类型变量</span></div><div class="line">	<span class="keyword">int</span> var = <span class="number">0x41</span>;</div><div class="line">	<span class="comment">//int指针变量，初始化为变量var的地址</span></div><div class="line">	<span class="keyword">int</span> *pnVar = &amp;var;</div><div class="line">	<span class="comment">//取出指针pcVar指向的地址内容并显示</span></div><div class="line">	<span class="keyword">char</span> *pcVar = (<span class="keyword">char</span>*)&amp;var;</div><div class="line">	<span class="built_in">printf</span>(<span class="string">"%s"</span>,pcVar);</div><div class="line"></div><div class="line">	<span class="comment">//引用作为参数，即把var的地址作为参数</span></div><div class="line">	funRef(var);</div><div class="line"></div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  用godbolt查看的效果如图，C++代码与对应的汇编代码用相同的颜色标注，非常方便查看。<br><img src="https://ws1.sinaimg.cn/large/8b331ee1gy1fhkgjfj3g5j21b01864b0.jpg" alt=""></p>
<hr>
<h2 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h2><p>在分支数少的情况下可以用if–else if模拟，<br>但是分支比较大的情况下，需要比较的次数太多，<br>如果是有序线性的数值，可将每个case语句块的地址预先保存在数组中，<br>考察switch语句的参数，并依次查询case语句块地址的数组，<br>从而得到对应case语句块的首地址，<br>这样可以降低比较的次数，提升效率。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">	<span class="keyword">int</span> nIdx=<span class="number">1</span>;</div><div class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;nIdx);</div><div class="line"></div><div class="line">	<span class="keyword">int</span> result = <span class="number">0</span>;</div><div class="line">	<span class="keyword">switch</span>(nIdx)&#123;</div><div class="line">		<span class="keyword">case</span> <span class="number">1</span>:</div><div class="line">			result = <span class="number">1</span>;</div><div class="line">			<span class="keyword">break</span>;</div><div class="line">		<span class="keyword">case</span> <span class="number">2</span>:</div><div class="line">			result = <span class="number">2</span>;</div><div class="line">			<span class="keyword">break</span>;	</div><div class="line">		<span class="keyword">case</span> <span class="number">3</span>:</div><div class="line">			result = <span class="number">3</span>;</div><div class="line">			<span class="keyword">break</span>;</div><div class="line">		<span class="keyword">case</span> <span class="number">5</span>:</div><div class="line">			result = <span class="number">3</span>;</div><div class="line">			<span class="keyword">break</span>;	</div><div class="line">		<span class="keyword">case</span> <span class="number">7</span>:</div><div class="line">			result = <span class="number">3</span>;</div><div class="line">			<span class="keyword">break</span>;		</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如下图，编译器把switch跳转表放到了.L4所指向的区域，其中的元素.L2、.L3 … .L8指向case对应代码地址。<br><img src="https://ws1.sinaimg.cn/large/8b331ee1gy1fhkglbho4lj21ba1m4ws4.jpg" alt=""></p>
<hr>
<h2 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h2><p>this指针中保存了所属对象的首地址。</p>
<p>在调用成员函数的过程中，编译器利用rdi寄存器保存了对象的首地址，<br>并以寄存器传参的方式传递到成员函数中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">class</span> Location&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	Location()&#123;</div><div class="line">		<span class="comment">//this指针指向一块16字节的内存区域</span></div><div class="line">		m_x = <span class="number">1</span>;</div><div class="line">		<span class="comment">//m_x是一个8字节类型，所以mov一个4字</span></div><div class="line">		<span class="comment">//mov     DWORD PTR [rax], 1</span></div><div class="line">		m_y = <span class="number">2</span>;</div><div class="line">		<span class="comment">//mov     WORD PTR [rax+4], 2</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">short</span> <span class="title">getY</span><span class="params">()</span></span>&#123;</div><div class="line">		<span class="comment">//获取this指针（对象首地址）偏移4处的数据，即m_y的值</span></div><div class="line">		<span class="comment">//movzx   eax, WORD PTR [rbp-8+4]</span></div><div class="line">		<span class="keyword">return</span> m_y;</div><div class="line">	&#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">	<span class="keyword">int</span> m_x; <span class="comment">//占4字节</span></div><div class="line">	<span class="keyword">short</span> m_y; <span class="comment">//占2字节</span></div><div class="line">	<span class="comment">//由于内存对齐，整个对象占8字节</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">	<span class="comment">//在栈上分配16字节，其中有8字节分配给是loc</span></div><div class="line">	<span class="comment">//把栈上loc的内存地址（即this指针）作为参数调用Location构造函数。</span></div><div class="line">	Location loc;</div><div class="line"></div><div class="line">	<span class="comment">//把栈上loc的内存地址（即this指针）作为参数调用getY成员函数。</span></div><div class="line">	<span class="keyword">short</span> y = loc.getY();</div><div class="line">	<span class="comment">//y变量位于[rbp-2]处</span></div><div class="line">	<span class="comment">//mov     WORD PTR [rbp-2], ax</span></div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对应的汇编如下：<br><img src="https://ws1.sinaimg.cn/large/8b331ee1gy1fhkglyyv96j21xy174qh5.jpg" alt=""></p>
<h2 id="虚函数和虚表"><a href="#虚函数和虚表" class="headerlink" title="虚函数和虚表"></a>虚函数和虚表</h2><p>编译器会为每一个包含虚函数的类（或通过继承得到的子类）生成一个表，其中包含指向类中每一个虚函数的指针。<br>这样的表就叫做虚表（vtable）。<br>此外，每个包含虚函数的类都获得另外一个数据成员，用于在运行时指向适当的虚表。<br>这个成员通常叫做虚表指针（vtable pointer），并且是类中的第一个数据成员。</p>
<p>在运行时创建对象时，对象的虚表指针将设置为指向合适的虚表。<br>如果该对象调用一个虚函数，则通过在该对象的虚表中进行查询来选择正确的函数。</p>
<p>代码举例如下，详细代码在<a href="https://gist.github.com/FelixZhang00/173be139404ec703a47dd4d1e52137ad" target="_blank" rel="external">这里</a>。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> BaseClass &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">   BaseClass()&#123;x=<span class="number">1</span>;y=<span class="number">2</span>;&#125;;</div><div class="line">   <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfunc1</span><span class="params">()</span> </span>= <span class="number">0</span>;</div><div class="line">   <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfunc2</span><span class="params">()</span></span>&#123;&#125;;</div><div class="line">   <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfunc3</span><span class="params">()</span></span>;</div><div class="line">   <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfunc4</span><span class="params">()</span></span>&#123;&#125;;</div><div class="line">   <span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span>&#123;<span class="built_in">printf</span>(<span class="string">"hello，y=%d"</span>,<span class="keyword">this</span>-&gt;y);&#125;;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">   <span class="keyword">int</span> x;<span class="comment">//4字节</span></div><div class="line">   <span class="keyword">int</span> y;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">class</span> SubClass : <span class="keyword">public</span> BaseClass &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">   SubClass()&#123;z=<span class="number">3</span>;&#125;;</div><div class="line">   <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfunc1</span><span class="params">()</span></span>&#123;&#125;;</div><div class="line">   <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfunc3</span><span class="params">()</span></span>;</div><div class="line">   <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfunc5</span><span class="params">()</span></span>&#123;&#125;;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">   <span class="keyword">int</span> z;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h3 id="虚表布局"><a href="#虚表布局" class="headerlink" title="虚表布局"></a>虚表布局</h3><p>下图是一个简化后的内存布局，它动态分配了一个SubClass类型的对象，编译器会确保该对象的第一个字段虚表指针指向正确的虚表。虚表指向编译器为每个类在只读段创建的一块区域，即虚表，类似于数组，其中的大部分元素指向在代码段中的成员函数地址。C++编译器会在编译阶段给这些函数名做name mangling，以实现c++中函数重载、namespace等标准。<br><img src="https://ws1.sinaimg.cn/large/8b331ee1gy1fhkgbscy1sj20yk0ysn3h.jpg" alt="虚表布局"></p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">vtable for SubClass:</div><div class="line"><span class="meta">        .quad</span>   <span class="number">0</span></div><div class="line"><span class="meta">        .quad</span>   typeinfo for SubClass <span class="comment">;RTTI相关</span></div><div class="line"><span class="meta">        .quad</span>   SubClass::vfunc1() <span class="comment">;this指针中的虚表指针一般指向这个偏移处</span></div><div class="line"><span class="meta">        .quad</span>   BaseClass::vfunc2()</div><div class="line"><span class="meta">        .quad</span>   SubClass::vfunc3()</div><div class="line"><span class="meta">        .quad</span>   BaseClass::vfunc4()</div><div class="line"><span class="meta">        .quad</span>   SubClass::vfunc5()</div><div class="line">vtable for BaseClass:</div><div class="line"><span class="meta">        .quad</span>   <span class="number">0</span></div><div class="line"><span class="meta">        .quad</span>   typeinfo for BaseClass <span class="comment">;RTTI相关</span></div><div class="line"><span class="meta">        .quad</span>   __cxa_pure_virtual <span class="comment">;vfunc1是纯虚函数</span></div><div class="line"><span class="meta">        .quad</span>   BaseClass::vfunc2()</div><div class="line"><span class="meta">        .quad</span>   BaseClass::vfunc3()</div><div class="line"><span class="meta">        .quad</span>   BaseClass::vfunc4()</div></pre></td></tr></table></figure>
<p> SubClass 中包含两个指向属于BaseClass的函数（ BaseClass::vfunc2 和 BaseClass::vfunc4）的指针。<br> 这是因为 SubClass 并没有重写这2个函数，而是直接继承自BaseClass 。<br>由于没有针对纯虚函数BaseClass::vfunc1的实现，因此，在 BaseClass的虚表中并没有存储 vfunc1 的地址。<br>这时，编译器会插入一个错误处理函数的地址，名为 purecall，万一被调用，它会令程序终止或者其他编译器想要发生的行为。<br>另外，一般的成员函数不在虚表里面，因为不涉及动态调用，如BaseClass中的hello()函数。</p>
<p>###创建对象<br>这里已在堆上动态创建对象为例。<br>调用new操作符，在堆上动态分配一块SubClass大小的内存，rax指向这块内存的开始。<br>SubClass需要的内存大小为<code>24字节=8(虚表指针)+4*3(3个int类型的成员变量)+4(内存对齐)</code><br>对象首地址的值作为参数调用SubClass构造函数。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">BaseClass *a_ptr = <span class="keyword">new</span> SubClass();</div></pre></td></tr></table></figure></p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">main:</span></div><div class="line">		<span class="comment">;...</span></div><div class="line">        <span class="keyword">mov</span>     <span class="built_in">edi</span>, <span class="number">24</span> <span class="comment">;SubClass需要24字节的内存</span></div><div class="line">        <span class="keyword">call</span>    operator new(unsigned long)</div><div class="line">        <span class="keyword">mov</span>     <span class="built_in">rbx</span>, <span class="built_in">rax</span></div><div class="line">        <span class="keyword">mov</span>     <span class="built_in">rdi</span>, <span class="built_in">rbx</span> <span class="comment">;this指针作为参数</span></div><div class="line">        <span class="keyword">call</span>    SubClass::SubClass()</div></pre></td></tr></table></figure>
<p>SubClass的构造函数，在完成自身的任务之前会调用基类的构造函数，然后对this指针的内存的虚表指针修改为指向SubClass自身的虚表。<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">SubClass:</span>:SubClass():</div><div class="line">        <span class="keyword">push</span>    <span class="built_in">rbp</span></div><div class="line">        <span class="keyword">mov</span>     <span class="built_in">rbp</span>, <span class="built_in">rsp</span></div><div class="line">        <span class="keyword">sub</span>     <span class="built_in">rsp</span>, <span class="number">16</span></div><div class="line">        <span class="keyword">mov</span>     <span class="built_in">QWORD</span> <span class="built_in">PTR</span> [<span class="built_in">rbp</span>-<span class="number">8</span>], <span class="built_in">rdi</span></div><div class="line">        <span class="keyword">mov</span>     <span class="built_in">rax</span>, <span class="built_in">QWORD</span> <span class="built_in">PTR</span> [<span class="built_in">rbp</span>-<span class="number">8</span>]</div><div class="line">        <span class="keyword">mov</span>     <span class="built_in">rdi</span>, <span class="built_in">rax</span> <span class="comment">;this指针</span></div><div class="line">        <span class="keyword">call</span>    BaseClass::BaseClass()</div><div class="line">        <span class="keyword">mov</span>     <span class="built_in">edx</span>, OFFSET FLAT:vtable for SubClass+<span class="number">16</span> <span class="comment">;指向SubClass虚表</span></div><div class="line">        <span class="keyword">mov</span>     <span class="built_in">rax</span>, <span class="built_in">QWORD</span> <span class="built_in">PTR</span> [<span class="built_in">rbp</span>-<span class="number">8</span>]</div><div class="line">        <span class="keyword">mov</span>     <span class="built_in">QWORD</span> <span class="built_in">PTR</span> [<span class="built_in">rax</span>], <span class="built_in">rdx</span> <span class="comment">;this指针的虚表指针字段赋值</span></div><div class="line">        <span class="keyword">mov</span>     <span class="built_in">rax</span>, <span class="built_in">QWORD</span> <span class="built_in">PTR</span> [<span class="built_in">rbp</span>-<span class="number">8</span>]</div><div class="line">        <span class="keyword">mov</span>     <span class="built_in">DWORD</span> <span class="built_in">PTR</span> [<span class="built_in">rax</span>+<span class="number">16</span>], <span class="number">3</span> <span class="comment">;z=3</span></div><div class="line">        <span class="keyword">nop</span></div><div class="line">        <span class="keyword">leave</span></div><div class="line">        <span class="keyword">ret</span></div></pre></td></tr></table></figure></p>
<p>BaseClass的构造函数:<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">BaseClass:</span>:BaseClass():</div><div class="line">        <span class="keyword">push</span>    <span class="built_in">rbp</span></div><div class="line">        <span class="keyword">mov</span>     <span class="built_in">rbp</span>, <span class="built_in">rsp</span></div><div class="line">        <span class="keyword">mov</span>     <span class="built_in">QWORD</span> <span class="built_in">PTR</span> [<span class="built_in">rbp</span>-<span class="number">8</span>], <span class="built_in">rdi</span> <span class="comment">;this指针</span></div><div class="line">        <span class="keyword">mov</span>     <span class="built_in">edx</span>, OFFSET FLAT:vtable for BaseClass+<span class="number">16</span> <span class="comment">;指向BaseClass虚表</span></div><div class="line">        <span class="keyword">mov</span>     <span class="built_in">rax</span>, <span class="built_in">QWORD</span> <span class="built_in">PTR</span> [<span class="built_in">rbp</span>-<span class="number">8</span>]</div><div class="line">        <span class="keyword">mov</span>     <span class="built_in">QWORD</span> <span class="built_in">PTR</span> [<span class="built_in">rax</span>], <span class="built_in">rdx</span> <span class="comment">;this指针的虚表指针字段赋值</span></div><div class="line">        <span class="keyword">mov</span>     <span class="built_in">rax</span>, <span class="built_in">QWORD</span> <span class="built_in">PTR</span> [<span class="built_in">rbp</span>-<span class="number">8</span>]</div><div class="line">        <span class="keyword">mov</span>     <span class="built_in">DWORD</span> <span class="built_in">PTR</span> [<span class="built_in">rax</span>+<span class="number">8</span>], <span class="number">1</span> <span class="comment">;x=1</span></div><div class="line">        <span class="keyword">mov</span>     <span class="built_in">rax</span>, <span class="built_in">QWORD</span> <span class="built_in">PTR</span> [<span class="built_in">rbp</span>-<span class="number">8</span>]</div><div class="line">        <span class="keyword">mov</span>     <span class="built_in">DWORD</span> <span class="built_in">PTR</span> [<span class="built_in">rax</span>+<span class="number">12</span>], <span class="number">2</span> <span class="comment">;y=2</span></div><div class="line">        <span class="keyword">nop</span></div><div class="line">        <span class="keyword">pop</span>     <span class="built_in">rbp</span></div><div class="line">        <span class="keyword">ret</span></div></pre></td></tr></table></figure></p>
<h3 id="调用成员函数"><a href="#调用成员函数" class="headerlink" title="调用成员函数"></a>调用成员函数</h3><h4 id="1、非虚函数"><a href="#1、非虚函数" class="headerlink" title="1、非虚函数"></a>1、非虚函数</h4><p>hello()是类BaseClass中的非虚成员函数，不需要通过虚表查找，编译器直接生成调用语句<code>call    BaseClass::hello()</code>，并且第一个参数默认为this指针。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">BaseClass *a_ptr = <span class="keyword">new</span> SubClass();</div><div class="line">  <span class="comment">//一般的成员函数，不在虚表里</span></div><div class="line">  a_ptr-&gt;hello();</div></pre></td></tr></table></figure></p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">main:</span></div><div class="line">		<span class="comment">;...		</span></div><div class="line">        <span class="keyword">mov</span>     <span class="built_in">rdi</span>, <span class="built_in">rax</span> <span class="comment">;参数:this指针</span></div><div class="line">        <span class="keyword">call</span>    BaseClass::hello()</div><div class="line"><span class="symbol"></span></div><div class="line">.LC0:</div><div class="line"><span class="meta">        .string</span> <span class="string">"hello\357\274\214y=%d"</span></div><div class="line"><span class="symbol">BaseClass:</span>:hello():</div><div class="line">        <span class="keyword">push</span>    <span class="built_in">rbp</span></div><div class="line">        <span class="keyword">mov</span>     <span class="built_in">rbp</span>, <span class="built_in">rsp</span></div><div class="line">        <span class="keyword">sub</span>     <span class="built_in">rsp</span>, <span class="number">16</span></div><div class="line">        <span class="keyword">mov</span>     <span class="built_in">QWORD</span> <span class="built_in">PTR</span> [<span class="built_in">rbp</span>-<span class="number">8</span>], <span class="built_in">rdi</span>  <span class="comment">;this指针放到栈上</span></div><div class="line">        <span class="keyword">mov</span>     <span class="built_in">rax</span>, <span class="built_in">QWORD</span> <span class="built_in">PTR</span> [<span class="built_in">rbp</span>-<span class="number">8</span>]</div><div class="line">        <span class="keyword">mov</span>     <span class="built_in">eax</span>, <span class="built_in">DWORD</span> <span class="built_in">PTR</span> [<span class="built_in">rax</span>+<span class="number">12</span>] <span class="comment">;this指针偏移12处，即成员变量y的位置</span></div><div class="line">        <span class="keyword">mov</span>     <span class="built_in">esi</span>, <span class="built_in">eax</span>              <span class="comment">;参数:format的数据，即y的值</span></div><div class="line">        <span class="keyword">mov</span>     <span class="built_in">edi</span>, OFFSET FLAT:.LC0 <span class="comment">;参数:format string</span></div><div class="line">        <span class="keyword">mov</span>     <span class="built_in">eax</span>, <span class="number">0</span>                <span class="comment">;参数:fd，指向stdout</span></div><div class="line">        <span class="keyword">call</span>    printf</div><div class="line">        <span class="keyword">nop</span></div><div class="line">        <span class="keyword">leave</span></div><div class="line">        <span class="keyword">ret</span></div></pre></td></tr></table></figure>
<h4 id="2、虚函数"><a href="#2、虚函数" class="headerlink" title="2、虚函数"></a>2、虚函数</h4><p>a_ptr是BaseClass类型的指针，动态分配的是SubClass类型的内存。<br>call_vfunc函数的参数是基类BaseClass，再调用vfunc3函数时需要先根据虚表指针定位到虚表，再通过偏移，解引用找到vfunc3的代码段地址，完成调用。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">	BaseClass *a_ptr = <span class="keyword">new</span> SubClass();</div><div class="line">	<span class="comment">//对象首地址作为参数调用函数call_vfunc</span></div><div class="line">   call_vfunc(a_ptr);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">call_vfunc</span><span class="params">(BaseClass *a)</span> </span>&#123;</div><div class="line">   a-&gt;vfunc3();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">main:</span></div><div class="line">	<span class="comment">;...	</span></div><div class="line">	<span class="keyword">mov</span>     <span class="built_in">rax</span>, <span class="built_in">QWORD</span> <span class="built_in">PTR</span> [<span class="built_in">rbp</span>-<span class="number">24</span>]</div><div class="line">    <span class="keyword">mov</span>     <span class="built_in">rdi</span>, <span class="built_in">rax</span> <span class="comment">;rax为this指针</span></div><div class="line">    <span class="keyword">call</span>    call_vfunc(BaseClass*)</div><div class="line"> </div><div class="line">call_vfunc(BaseClass*):</div><div class="line">        <span class="keyword">push</span>    <span class="built_in">rbp</span></div><div class="line">        <span class="keyword">mov</span>     <span class="built_in">rbp</span>, <span class="built_in">rsp</span></div><div class="line">        <span class="keyword">sub</span>     <span class="built_in">rsp</span>, <span class="number">16</span></div><div class="line">        <span class="keyword">mov</span>     <span class="built_in">QWORD</span> <span class="built_in">PTR</span> [<span class="built_in">rbp</span>-<span class="number">8</span>], <span class="built_in">rdi</span> <span class="comment">;把this指针放到栈上</span></div><div class="line">        <span class="keyword">mov</span>     <span class="built_in">rax</span>, <span class="built_in">QWORD</span> <span class="built_in">PTR</span> [<span class="built_in">rbp</span>-<span class="number">8</span>]</div><div class="line">        <span class="keyword">mov</span>     <span class="built_in">rax</span>, <span class="built_in">QWORD</span> <span class="built_in">PTR</span> [<span class="built_in">rax</span>]   <span class="comment">;this指向的内存的开头8个字节的数据复制给rax,即虚表指针</span></div><div class="line">        <span class="keyword">add</span>     <span class="built_in">rax</span>, <span class="number">16</span>                <span class="comment">;找到虚表指针偏移16</span></div><div class="line">        <span class="keyword">mov</span>     <span class="built_in">rax</span>, <span class="built_in">QWORD</span> <span class="built_in">PTR</span> [<span class="built_in">rax</span>]   <span class="comment">;虚表指针偏移16处解引用，得到函数的SubClass::vfunc3的地址</span></div><div class="line">        <span class="keyword">mov</span>     <span class="built_in">rdx</span>, <span class="built_in">QWORD</span> <span class="built_in">PTR</span> [<span class="built_in">rbp</span>-<span class="number">8</span>]</div><div class="line">        <span class="keyword">mov</span>     <span class="built_in">rdi</span>, <span class="built_in">rdx</span>              <span class="comment">;rdi为this指针，作为参数</span></div><div class="line">        <span class="keyword">call</span>    <span class="built_in">rax</span>                   <span class="comment">;调用vfunc3</span></div><div class="line">        <span class="keyword">nop</span></div><div class="line">        <span class="keyword">leave</span></div><div class="line">        <span class="keyword">ret</span></div></pre></td></tr></table></figure>
<hr>
<h2 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h2><p>这里以堆分配的对象析构为例，完整代码在<a href="https://gist.github.com/FelixZhang00/4bcfeec2ba3f8568a6da8e4151379800" target="_blank" rel="external">这里</a>。<br>堆分配的对象的析构函数在分配给对象的内存释放之前通过 delete 操作符调用。<br>其过程如下：<br>1、如果类拥有任何虚函数，则还原对象的虚表指针，使其指向相关类的虚表。如果一个子类在创建过程中覆盖了虚表指针，就需要这样做。<br>2、执行程序员为析构函数指定的代码。<br>3、如果类拥有本身就是对象的数据成员，则执行这些成员的析构函数。<br>4、如果对象拥有一个超类，则调用超类的析构函数<br>5、如果是释放堆的对象，则用一个代理析构函数执行1~4步骤，并在最后调用delete操作符释放堆上的对象。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> BaseClass &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">   BaseClass()&#123;x=<span class="number">1</span>;y=<span class="number">2</span>;&#125;;</div><div class="line">   <span class="keyword">virtual</span> ~BaseClass()&#123;<span class="built_in">printf</span>(<span class="string">"~BaseClass()\n"</span>);&#125;;</div><div class="line">   <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfunc1</span><span class="params">()</span> </span>= <span class="number">0</span>;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">   <span class="keyword">int</span> x;<span class="comment">//4字节</span></div><div class="line">   <span class="keyword">int</span> y;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">class</span> SubClass : <span class="keyword">public</span> BaseClass &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">   SubClass()&#123;z=<span class="number">3</span>;&#125;;</div><div class="line">   <span class="keyword">virtual</span> ~SubClass()&#123;<span class="built_in">printf</span>(<span class="string">"~SubClass()\n"</span>);&#125;;</div><div class="line">   <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfunc1</span><span class="params">()</span></span>&#123;&#125;;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">   <span class="keyword">int</span> z;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">   BaseClass *a_ptr = <span class="keyword">new</span> SubClass();</div><div class="line">   <span class="comment">//触发析构 </span></div><div class="line">   <span class="keyword">delete</span> a_ptr; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div></pre></td><td class="code"><pre><div class="line"><span class="comment">;只读段中的虚表结构</span></div><div class="line">vtable for SubClass:</div><div class="line"><span class="meta">    .quad</span>   <span class="number">0</span></div><div class="line"><span class="meta">    .quad</span>   typeinfo for SubClass</div><div class="line"><span class="meta">    .quad</span>   SubClass::<span class="string">'scalar deleting destructor'</span> <span class="comment">;代理析构函数的地址</span></div><div class="line"><span class="meta">    .quad</span>   SubClass::~SubClass() <span class="comment">;析构函数的地址，这里godbolt没有把它们区分出来</span></div><div class="line"><span class="meta">    .quad</span>   SubClass::vfunc1()</div><div class="line"><span class="symbol">        </span></div><div class="line">main:</div><div class="line">     <span class="keyword">mov</span>     <span class="built_in">QWORD</span> <span class="built_in">PTR</span> [<span class="built_in">rbp</span>-<span class="number">24</span>], <span class="built_in">rbx</span>  <span class="comment">;rbx为a_ptr的指针</span></div><div class="line">     <span class="keyword">cmp</span>     <span class="built_in">QWORD</span> <span class="built_in">PTR</span> [<span class="built_in">rbp</span>-<span class="number">24</span>], <span class="number">0</span>    <span class="comment">;判断a_ptr是否为null，这是编译器加的。</span></div><div class="line">     <span class="keyword">je</span>      .L9                      <span class="comment">;如果为null直接跳过析构</span></div><div class="line">     <span class="keyword">mov</span>     <span class="built_in">rax</span>, <span class="built_in">QWORD</span> <span class="built_in">PTR</span> [<span class="built_in">rbp</span>-<span class="number">24</span>]</div><div class="line">     <span class="keyword">mov</span>     <span class="built_in">rax</span>, <span class="built_in">QWORD</span> <span class="built_in">PTR</span> [<span class="built_in">rax</span>]</div><div class="line">     <span class="keyword">add</span>     <span class="built_in">rax</span>, <span class="number">8</span>                   <span class="comment">;this指针偏移8处，即指向代理析构函数</span></div><div class="line">     <span class="keyword">mov</span>     <span class="built_in">rax</span>, <span class="built_in">QWORD</span> <span class="built_in">PTR</span> [<span class="built_in">rax</span>]     <span class="comment">;rax为代理析构函数的地址</span></div><div class="line">     <span class="keyword">mov</span>     <span class="built_in">rdx</span>, <span class="built_in">QWORD</span> <span class="built_in">PTR</span> [<span class="built_in">rbp</span>-<span class="number">24</span>] </div><div class="line">     <span class="keyword">mov</span>     <span class="built_in">rdi</span>, <span class="built_in">rdx</span>                 <span class="comment">;参数：this指针</span></div><div class="line">     <span class="keyword">call</span>    <span class="built_in">rax</span>                      <span class="comment">;调用代理析构函数</span></div><div class="line"></div><div class="line"><span class="comment">;SubClass的代理析构函数</span></div><div class="line"><span class="symbol">SubClass:</span>:<span class="string">'scalar deleting destructor'</span>:</div><div class="line">        <span class="keyword">push</span>    <span class="built_in">rbp</span></div><div class="line">        <span class="keyword">mov</span>     <span class="built_in">rbp</span>, <span class="built_in">rsp</span></div><div class="line">        <span class="keyword">sub</span>     <span class="built_in">rsp</span>, <span class="number">16</span></div><div class="line">        <span class="keyword">mov</span>     <span class="built_in">QWORD</span> <span class="built_in">PTR</span> [<span class="built_in">rbp</span>-<span class="number">8</span>], <span class="built_in">rdi</span></div><div class="line">        <span class="keyword">mov</span>     <span class="built_in">rax</span>, <span class="built_in">QWORD</span> <span class="built_in">PTR</span> [<span class="built_in">rbp</span>-<span class="number">8</span>]</div><div class="line">        <span class="keyword">mov</span>     <span class="built_in">rdi</span>, <span class="built_in">rax</span>              <span class="comment">;参数:this指针</span></div><div class="line">        <span class="keyword">call</span>    SubClass::~SubClass() <span class="comment">;调用析构函数</span></div><div class="line">        <span class="keyword">mov</span>     <span class="built_in">rax</span>, <span class="built_in">QWORD</span> <span class="built_in">PTR</span> [<span class="built_in">rbp</span>-<span class="number">8</span>]</div><div class="line">        <span class="keyword">mov</span>     <span class="built_in">esi</span>, <span class="number">24</span>               <span class="comment">;参数:释放24字节大小的堆空间</span></div><div class="line">        <span class="keyword">mov</span>     <span class="built_in">rdi</span>, <span class="built_in">rax</span>              <span class="comment">;参数:堆空间的首地址</span></div><div class="line">        <span class="keyword">call</span>    operator delete(void*, unsigned long) <span class="comment">;释放堆空间</span></div><div class="line">        <span class="keyword">leave</span></div><div class="line">        <span class="keyword">ret</span></div><div class="line"><span class="symbol">        </span></div><div class="line"> .LC1:</div><div class="line"><span class="meta">        .string</span> <span class="string">"~SubClass()"</span>       </div><div class="line"><span class="comment">;SubClass的析构函数，执行析构函数中的代码</span></div><div class="line"><span class="symbol">SubClass:</span>:~SubClass():</div><div class="line">    <span class="keyword">push</span>    <span class="built_in">rbp</span></div><div class="line">    <span class="keyword">mov</span>     <span class="built_in">rbp</span>, <span class="built_in">rsp</span></div><div class="line">    <span class="keyword">sub</span>     <span class="built_in">rsp</span>, <span class="number">16</span></div><div class="line">    <span class="keyword">mov</span>     <span class="built_in">QWORD</span> <span class="built_in">PTR</span> [<span class="built_in">rbp</span>-<span class="number">8</span>], <span class="built_in">rdi</span></div><div class="line">    <span class="keyword">mov</span>     <span class="built_in">edx</span>, OFFSET FLAT:vtable for SubClass+<span class="number">16</span></div><div class="line">    <span class="keyword">mov</span>     <span class="built_in">rax</span>, <span class="built_in">QWORD</span> <span class="built_in">PTR</span> [<span class="built_in">rbp</span>-<span class="number">8</span>]</div><div class="line">    <span class="keyword">mov</span>     <span class="built_in">QWORD</span> <span class="built_in">PTR</span> [<span class="built_in">rax</span>], <span class="built_in">rdx</span>      <span class="comment">;还原对象的虚表指针，使其指向相关类的虚表</span></div><div class="line">    <span class="keyword">mov</span>     <span class="built_in">edi</span>, OFFSET FLAT:.LC1</div><div class="line">    <span class="keyword">call</span>    puts                      <span class="comment">;调用puts函数，这里编译器把printf调用转换成puts了。</span></div><div class="line">    <span class="keyword">mov</span>     <span class="built_in">rax</span>, <span class="built_in">QWORD</span> <span class="built_in">PTR</span> [<span class="built_in">rbp</span>-<span class="number">8</span>]</div><div class="line">    <span class="keyword">mov</span>     <span class="built_in">rdi</span>, <span class="built_in">rax</span>                  <span class="comment">;参数：this指针 </span></div><div class="line">    <span class="keyword">call</span>    BaseClass::~BaseClass()   <span class="comment">;调用基类的析构函数</span></div><div class="line">    <span class="keyword">nop</span></div><div class="line">    <span class="keyword">leave</span></div><div class="line">    <span class="keyword">ret</span></div><div class="line"><span class="symbol"></span></div><div class="line">.LC0:</div><div class="line"><span class="meta">        .string</span> <span class="string">"~BaseClass()"</span></div><div class="line"><span class="comment">;BaseClass的析构函数，执行析构函数中的代码        </span></div><div class="line"><span class="symbol">BaseClass:</span>:~BaseClass():</div><div class="line">        <span class="keyword">push</span>    <span class="built_in">rbp</span></div><div class="line">        <span class="keyword">mov</span>     <span class="built_in">rbp</span>, <span class="built_in">rsp</span></div><div class="line">        <span class="keyword">sub</span>     <span class="built_in">rsp</span>, <span class="number">16</span></div><div class="line">        <span class="keyword">mov</span>     <span class="built_in">QWORD</span> <span class="built_in">PTR</span> [<span class="built_in">rbp</span>-<span class="number">8</span>], <span class="built_in">rdi</span></div><div class="line">        <span class="keyword">mov</span>     <span class="built_in">edx</span>, OFFSET FLAT:vtable for BaseClass+<span class="number">16</span></div><div class="line">        <span class="keyword">mov</span>     <span class="built_in">rax</span>, <span class="built_in">QWORD</span> <span class="built_in">PTR</span> [<span class="built_in">rbp</span>-<span class="number">8</span>]</div><div class="line">        <span class="keyword">mov</span>     <span class="built_in">QWORD</span> <span class="built_in">PTR</span> [<span class="built_in">rax</span>], <span class="built_in">rdx</span></div><div class="line">        <span class="keyword">mov</span>     <span class="built_in">edi</span>, OFFSET FLAT:.LC0</div><div class="line">        <span class="keyword">call</span>    puts</div><div class="line">        <span class="keyword">nop</span></div><div class="line">        <span class="keyword">leave</span></div><div class="line">        <span class="keyword">ret</span></div></pre></td></tr></table></figure>
<p>通过分析C++析构函数的调用过程，我们就知道了为什么C++基类的析构函数要声明为virtual了。我们希望当调用C++基类BaseClass的析构函数时能够触发动态绑定，能够找到当前对象所属类的虚函数表中的析构函数。<br>如果不声明BaseClass的析构函数为virtual，那么在调用<code>delete a_ptr</code>时，将只会释放BaseClass大小的内存，给SubClass中成员变量分配的内存将得不到释放，从而导致内存泄漏。</p>
<h2 id="C-11中的Lambda表达式"><a href="#C-11中的Lambda表达式" class="headerlink" title="C++11中的Lambda表达式"></a>C++11中的Lambda表达式</h2><p>lambda表达式表示一个可调用的代码单元。可以理解为一个未命名的内联函数。<br>lambda表达式具有如下形式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[capture list](parameter list) -&gt; return type &#123;function body&#125;</div></pre></td></tr></table></figure></p>
<p>下面定义了一个C++函数，其中有一个lambda表达式。v1之前的&amp;符号指出v1是以引用方式捕获，当lambda返回v1时，它返回的是v1指向对象的值，所以j的值是0，而不是42.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">void fcn1()&#123;</div><div class="line">    int v1 =42;</div><div class="line">    auto f= [&amp;v1] &#123;return v1;&#125;;</div><div class="line">    v1 = 0;</div><div class="line">    auto j = f();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>对应的反汇编代码如下，可以看到编译器为fcn1中的lambda表达式在代码段中生成了一段指令，当调用这个lambda时就会执行到这段指令，跟普通的函数调用一致。<br>可以看出传递给<code>fcn1()::{lambda()#1}</code>函数的参数rdi的值其实就是v1变量的地址，所以这个lambda是是采用引用方式捕获变量的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">.Ltext0:</div><div class="line">fcn1()::&#123;lambda()#1&#125;::operator()() const:</div><div class="line"></div><div class="line">        push    rbp</div><div class="line">        mov     rbp, rsp</div><div class="line">        mov     QWORD PTR [rbp-8], rdi</div><div class="line">        mov     rax, QWORD PTR [rbp-8]</div><div class="line">        mov     rax, QWORD PTR [rax]</div><div class="line">        mov     eax, DWORD PTR [rax]</div><div class="line">        pop     rbp</div><div class="line">        ret</div><div class="line">fcn1():</div><div class="line">        push    rbp</div><div class="line">        mov     rbp, rsp</div><div class="line">        sub     rsp, 16</div><div class="line">        mov     DWORD PTR [rbp-8], 42</div><div class="line">        lea     rax, [rbp-8]</div><div class="line">        mov     QWORD PTR [rbp-16], rax</div><div class="line">        mov     DWORD PTR [rbp-8], 0</div><div class="line">        lea     rax, [rbp-16]</div><div class="line">        mov     rdi, rax</div><div class="line">        call    fcn1()::&#123;lambda()#1&#125;::operator()() const</div><div class="line">        mov     DWORD PTR [rbp-4], eax</div><div class="line">        nop</div><div class="line">        leave</div><div class="line">        ret</div></pre></td></tr></table></figure></p>
<hr>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《IDA Pro权威指南》<br>《C++反汇编与逆向分析技术揭秘》<br>《C++ Primer（第5版）》</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文通过C++反编译，帮助理解C++中的一些概念（指针引用、this指针、虚函数、析构函数、lambda表达式），&lt;br&gt;希望能在深入理解C++其它一些高级特性（多重继承、RTTI、异常处理）能起到抛砖引玉的作用吧&lt;/p&gt;
&lt;p&gt;常用反汇编工具有：objdump、IDA P
    
    </summary>
    
    
      <category term="c++" scheme="http://felixzhang00.github.io/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>Stetho的通信原理</title>
    <link href="http://felixzhang00.github.io/2017/03/12/Stetho%E7%9A%84%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86/"/>
    <id>http://felixzhang00.github.io/2017/03/12/Stetho的通信原理/</id>
    <published>2017-03-12T06:34:48.000Z</published>
    <updated>2017-03-12T06:51:15.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Stetho简介"><a href="#Stetho简介" class="headerlink" title="Stetho简介"></a>Stetho简介</h2><p><a href="http://facebook.github.io/stetho/" target="_blank" rel="external">stetho</a>是Facebook推出的安卓APP网络诊断和数据监控的工具，接入方便，功能强大，是Android开发者必备的友好工具。<br>主要功能包括：</p>
<ul>
<li>实时查看App的布局</li>
<li>网络请求抓包</li>
<li>数据库、SharedPreferences文件内容监控</li>
<li>自定义dumpapp插件</li>
<li>对于JavaScript的支持</li>
</ul>
<p>具体的使用方法可以看这篇<a href="https://www.figotan.org/2016/04/18/using-stetho-to-diagnose-data-on-android/" target="_blank" rel="external">文章</a>。<br>本文主要想讲一下自定义dumpapp插件的通信原理。</p>
<h2 id="dumpapp插件示例"><a href="#dumpapp插件示例" class="headerlink" title="dumpapp插件示例"></a>dumpapp插件示例</h2><p>在主机上给设备发送一个<code>files tree</code>命令，得到如下结果：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ ./dumpapp files tree</div><div class="line">+---lib</div><div class="line">+---cache</div><div class="line">|   +---com.android.opengl.shaders_cache</div><div class="line">+---files</div></pre></td></tr></table></figure></p>
<p>在app中对应这样一段java代码，来处理<code>files tree</code>命令。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doTree</span><span class="params">(PrintStream writer)</span> <span class="keyword">throws</span> DumpUsageException </span>&#123;</div><div class="line">  File baseDir = getBaseDir(mContext);</div><div class="line">  printDirectoryVisual(baseDir, <span class="number">0</span>, writer);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>问题是，为什么在主机上执行一段脚本(<a href="https://github.com/facebook/stetho/blob/master/scripts/dumpapp" target="_blank" rel="external"><code>dumpapp.py</code></a>)后会让设备上的app执行相应的处理程序呢？</p>
<p>一般PushService可以完成类似的功能，后台下发一条指令，客户端完成指定的动作。对于Stetho这样的Android调试工具来说，显然不需要使用后台，用ADB就可以实现。</p>
<hr>
<h2 id="ADB通信的原理"><a href="#ADB通信的原理" class="headerlink" title="ADB通信的原理"></a>ADB通信的原理</h2><p>ADB的结构是一个client-server的结构，包含3个部分：</p>
<ul>
<li>Client ： 发送命令。客户端在PC主机上运行，在shell里使用Adb命令的时候就会开启一个client。</li>
<li>Daemon : 在设备上执行命令。守护进程在设备上后台运行。(aabd运行在Andriod设备的底层)</li>
<li>Server ： 管理客户端（client）和守护进程（daemon）的连接。server在PC主机上后台运行。<br><img src="http://7viip0.com1.z0.glb.clouddn.com/17-3-12/10223878-file_1489286370152_c45a.jpg" alt=""></li>
</ul>
<h3 id="smartsocket"><a href="#smartsocket" class="headerlink" title="smartsocket"></a>smartsocket</h3><p>android提供了smartsocket,详见<a href="https://android.googlesource.com/platform/system/core/+/master/adb/protocol.txt" target="_blank" rel="external">这里</a></p>
<blockquote>
<p>— smartsockets ——————————————————-<br>Port 5037 is used for smart sockets which allow a client on the host<br>side to request access to a service in the host adb daemon or in the<br>remote (device) daemon.  The service is requested by ascii name,<br>preceeded by a 4 digit hex length.  Upon successful connection an<br>“OKAY” response is sent, otherwise a “FAIL” message is returned.  Once<br>connected the client is talking to that (remote or local) service.<br>client: <hex4> <service-name><br>server: “OKAY”<br>client: <hex4> <service-name><br>server: “FAIL” <hex4> <reason></reason></hex4></service-name></hex4></service-name></hex4></p>
</blockquote>
<p>总结来说，就是可以给adb-server发送一条指令<code>&lt;service-name&gt;</code>，然后adb-server会转发给adbd，让adbd来执行<code>&lt;service-name&gt;</code>.<br>举例来说，当我们执行<code>adb shell cat /proc/net/unix</code>,最终就是通过adbd在设备上执行的。</p>
<p>Stetho的通信模型如下：<br><img src="http://7viip0.com1.z0.glb.clouddn.com/17-3-12/75166063-file_1489297004530_117bc.png" alt=""><br>其中stetho-server就是app启的一个Thread用来accept客户端的connect。</p>
<hr>
<h2 id="程序流程"><a href="#程序流程" class="headerlink" title="程序流程"></a>程序流程</h2><p>可以通过在关键位置打上断点的方式来看程序的流程。<br>Python可以用<a href="https://www.jetbrains.com/pycharm/" target="_blank" rel="external">Pycharm</a>来打断点。<br>如图配置一个debug版本,这样就可以以<code>./dumapp -l</code>的方式debug了。<br><img src="http://7viip0.com1.z0.glb.clouddn.com/17-3-12/84731891-file_1489298066962_2a09.jpg" alt=""><br>Android app当然是用Android Studio打断点了。</p>
<h3 id="dumpapp-py流程分析"><a href="#dumpapp-py流程分析" class="headerlink" title="dumpapp.py流程分析"></a>dumpapp.py流程分析</h3><p>详见代码(<a href="https://github.com/facebook/stetho/blob/master/scripts/dumpapp" target="_blank" rel="external"><code>dumpapp.py</code></a>)<br><img src="http://7viip0.com1.z0.glb.clouddn.com/17-3-12/32838177-file_1489290757916_15931.png" alt=""></p>
<p>例子1：<br><code>adb.select_service(&#39;shell:cat /proc/net/unix&#39;)</code><br><img src="http://7viip0.com1.z0.glb.clouddn.com/17-3-12/77046872-file_1489287023930_14c4e.png" alt=""><br>通过这个命令其实是在找到指定的Unix域套接字。<br><img src="http://7viip0.com1.z0.glb.clouddn.com/17-3-12/74443269-file_1489287115563_17cdf.png" alt=""><br>在<code>/proc/net/unix</code>文件下可以看到所有的unix域套接字，Path字段前面有@符号的表示它是一个ABSTRACT类型的socket，如果是绝对路径则表示是FILESYSTEM类型的。<br><img src="http://7viip0.com1.z0.glb.clouddn.com/17-3-12/30789563-file_1489287608725_1bbf.jpg" alt=""><br>例子2：<br>发起一个connect到Unix域套接字的请求<br><code>adb.select_service(&#39;localabstract:%s&#39; % (socket_name))</code><br><img src="http://7viip0.com1.z0.glb.clouddn.com/17-3-12/3363418-file_1489287410599_b640.png" alt=""></p>
<p>这里的python用到的几个service协议应该是android提供的smartsocket本身就支持的，在与adb的端口号连接后就能使用socket来发送service的名字给android设备了。<br>详见<a href="https://developer.chrome.com/devtools/docs/remote-debugging-legacy" target="_blank" rel="external">这里</a>.<br>如下的命令就可以直接跟stetho-server连接。<br><img src="http://7viip0.com1.z0.glb.clouddn.com/17-3-12/10703667-file_1489287758769_63f.png" alt=""></p>
<h3 id="stetho-server流程分析"><a href="#stetho-server流程分析" class="headerlink" title="stetho-server流程分析"></a>stetho-server流程分析</h3><p>详见代码<a href="https://github.com/facebook/stetho/blob/36aa5bd356d9cf5893b9424b06a83dda9ec5e44f/stetho/src/main/java/com/facebook/stetho/server/LocalSocketServer.java" target="_blank" rel="external">LocalSocketServer.java</a><br><img src="http://7viip0.com1.z0.glb.clouddn.com/17-3-12/85652381-file_1489291638319_11cf3.png" alt=""><br>这里创建ServerSocket时的address格式是<code>stetho_+进程名+_ devtools_remote</code></p>
<hr>
<h2 id="Unix域套接字"><a href="#Unix域套接字" class="headerlink" title="Unix域套接字"></a>Unix域套接字</h2><p>socket API原本是为网络通讯设计的，但后来在socket的框架上发展出一种IPC机制，就是UNIX Domain Socket（Unix域协议）。虽然网络socket也可用于同一台主机的进程间通讯（通过loopback地址127.0.0.1），但是UNIX Domain Socket用于IPC更有效率：不需要经过网络协议栈，不需要打包拆包、计算校验和、维护序号和应答等，只是将应用层数据从一个进程拷贝到另一个进程。这是因为，IPC机制本质上是可靠的通讯，而网络协议是为不可靠的通讯设计的。UNIX Domain Socket也提供面向流和面向数据包两种API接口，类似于TCP和UDP，但是面向消息的UNIX Domain Socket也是可靠的，消息既不会丢失也不会顺序错乱。</p>
<p>Unix域协议所用的API就是在不同主机上执行客户/服务通信所用的套接字API。</p>
<h3 id="Android中的Unix域套接字"><a href="#Android中的Unix域套接字" class="headerlink" title="Android中的Unix域套接字"></a>Android中的Unix域套接字</h3><p>在Android API中，有几个类对Unix域套接字（也叫localsocket）进行了封装，不仅可以用来应用程序之间进行IPC通信，还可以跨应用程序层和Linux层运行的程序进行通信。<br><code>LocalSocket</code>在Unix域名空间创建一个套接字（非服务端）。<br><code>LocalSocketImpl</code>是Framework层Socket的实现，通过JNI调用系统socket API。<br><code>LocalServerSocket</code>创建服务器端Unix域套接字，与LocalSocket对应。<br><img src="http://7viip0.com1.z0.glb.clouddn.com/17-3-12/89412003-file_1489294912573_1445f.png" alt=""></p>
<p>创建socket时指定的domain类型是AF_UNIX。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Creates a socket in the underlying OS.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">create</span> <span class="params">(<span class="keyword">int</span> sockType)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    <span class="comment">//...</span></div><div class="line">    fd = Os.socket(OsConstants.AF_UNIX, osType, <span class="number">0</span>);    </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>通过搜索发现LocalSocketImpl的native实现是在libandroid_runtime.so中。<br><img src="http://7viip0.com1.z0.glb.clouddn.com/17-3-12/62841029-file_1489288277901_16a7e.png" alt=""><br>比如listen的native实现就是调用了socket的listen函数。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* private native void listen_native(int fd, int backlog) throws IOException; */</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></div><div class="line"><span class="title">socket_listen</span> <span class="params">(JNIEnv *env, jobject object, jobject fileDescriptor, jint backlog)</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> ret,fd;</div><div class="line">    fd = jniGetFDFromFileDescriptor(env, fileDescriptor);</div><div class="line">    ret = listen(fd, backlog);</div><div class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</div><div class="line">        jniThrowIOException(env, errno);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.jianshu.com/p/f82b733bd6ac" target="_blank" rel="external">ADB原理，Wi-Fi连接，常用命令及拓展</a><br>《UNIX网络编程卷1》<br><a href="http://blog.csdn.net/shuzui1985/article/details/50178929" target="_blank" rel="external">Android LocalSocket与Socket 区别</a><br><a href="https://www.figotan.org/2016/04/18/using-stetho-to-diagnose-data-on-android/" target="_blank" rel="external">如何给安卓APP安装听诊器,检查数据问题</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Stetho简介&quot;&gt;&lt;a href=&quot;#Stetho简介&quot; class=&quot;headerlink&quot; title=&quot;Stetho简介&quot;&gt;&lt;/a&gt;Stetho简介&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://facebook.github.io/stetho/&quot; ta
    
    </summary>
    
    
      <category term="android" scheme="http://felixzhang00.github.io/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>理解mmap</title>
    <link href="http://felixzhang00.github.io/2017/02/25/%E7%90%86%E8%A7%A3mmap/"/>
    <id>http://felixzhang00.github.io/2017/02/25/理解mmap/</id>
    <published>2017-02-25T11:35:26.000Z</published>
    <updated>2017-02-25T12:06:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>在接入日志组件xlog的工作中，对mmap内存映射加深了了解，分享一下学习心得。</p>
<h2 id="1-一个Linux进程的虚拟内存"><a href="#1-一个Linux进程的虚拟内存" class="headerlink" title="1.一个Linux进程的虚拟内存"></a>1.一个Linux进程的虚拟内存</h2><p><img src="http://7viip0.com1.z0.glb.clouddn.com/17-2-25/50851685-file_1488011866599_1378c.jpg" alt=""><br>如图展示了一个Linux进程的虚拟内存。<br>虚拟的意思是进程以为自己有这么一大块内存，实际上物理内存可能还没有分配给它，等到缺页异常是系统才会分配，通过这种以时间换空间的方式提高了内存利用效率。从虚拟内存到物理内存的映射过程需要一个专门的硬件单元MMU来完成。<br>系统调用的代码和数据就在内核虚拟内存中，<br>因为在保护模式下，用户态进程无法访问到这里，必须要通过系统调用的方式陷入到内核态才行。</p>
<h2 id="2-Linux是如何组织虚拟内存的"><a href="#2-Linux是如何组织虚拟内存的" class="headerlink" title="2.Linux是如何组织虚拟内存的"></a>2.Linux是如何组织虚拟内存的</h2><p><img src="http://7viip0.com1.z0.glb.clouddn.com/17-2-25/44198324-file_1488012277201_ee2a.png" alt=""><br>内核为系统中的每个进程维护一个单独的任务结构<code>task_struct</code>，其中元素包含了内核运行该进程所需要的所有信息（PID、指向用户栈的指针、可执行目标文件的名字、虚拟内存状态、pc指针等）<br><code>task_struct</code>中的<code>mm_struct</code>描述了虚拟内存的当前状态，其中mmap字段指向一个<code>vm_area_struct</code>（区域结构）的链表。顺序搜索区域结构的链表花销会很大，实际上Linux在链表中构建了一个树，并在这棵树中进行查找。<br>进程对某一虚拟内存区域的任何操作需要用要的信息，都可以从<code>vm_area_struct</code>中获得。mmap函数就是要创建一个新的<code>vm_area_struct</code>结构，并将其与文件的物理磁盘地址相连。</p>
<h2 id="3-缺页处理"><a href="#3-缺页处理" class="headerlink" title="3.缺页处理"></a>3.缺页处理</h2><p><img src="http://7viip0.com1.z0.glb.clouddn.com/17-2-25/30649400-file_1488012949934_13c4.jpg" alt=""><br>当MMU在试图翻译某个虚拟地址A时，触发了一个缺页。缺页异常处理程序会做如下检查：</p>
<ul>
<li>1）虚拟地址A是否合法？即是否在链表<code>mm_struct</code>所描述的区域内。</li>
<li>2）试图进行的内存访问是否合法？即检查指令的权限是否与vm_prot字段所描述的页读写许可权限相匹配。</li>
<li>3）正常缺页。系统会负责把该虚拟内存区域对应的文件加载到内存中。</li>
</ul>
<h2 id="4-内存映射"><a href="#4-内存映射" class="headerlink" title="4.内存映射"></a>4.内存映射</h2><p>Linux通过将一个虚拟内存区域与一个磁盘上的对象关联起来，以初始化这个虚拟内存区域的内容，这个过程称为内存映射。<br>Linux进程可以使用mmap函数来创建新的虚拟内存区域，并将对象映射到这些区域中。<br>mmap函数定义在libc中：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> *</span></div><div class="line">    <span class="title">mmap</span><span class="params">(<span class="keyword">void</span> *start, <span class="keyword">size_t</span> length, <span class="keyword">int</span> prot, <span class="keyword">int</span> flags, <span class="keyword">int</span> fd, <span class="keyword">off_t</span> offset)</span>;</div></pre></td></tr></table></figure></p>
<p>具体内容可以通过命令<code>man 2 mmap</code>查看。<br>mmap参数的可视化解释：<br><img src="http://7viip0.com1.z0.glb.clouddn.com/17-2-25/21318677-file_1488018309700_943f.png" alt=""></p>
<h3 id="mmap原理"><a href="#mmap原理" class="headerlink" title="mmap原理"></a>mmap原理</h3><p>在调用mmap实现这样的映射关系后，它只是在进程的虚拟空间中分配了一段空间，真实的物理地址还不会分配的，当进程第一次访问这段空间（当作内存一样），CPU陷入OS内核执行异常处理，然后异常处理会在这个时间分配物理内存，并用文件的内容填充这片内存，然后才返回进程的上下文，这时进程才会感知到这片内存里有数据。<br>之后进程即可对这片主存进行读或者写的操作，如果写操作改变了其内容，一定时间后系统会自动回写脏页面到对应磁盘地址，也即完成了写入到文件的过程。</p>
<p>mmap 的回写时机：</p>
<ul>
<li>内存不足</li>
<li>进程退出</li>
<li>调用 msync 或者 munmap</li>
<li>不设置 MAP_NOSYNC 情况下 30s-60s(仅限FreeBSD)</li>
</ul>
<h3 id="程序的加载"><a href="#程序的加载" class="headerlink" title="程序的加载"></a>程序的加载</h3><p>Linux执行一个ELF格式的程序，这个程序在磁盘上，为了执行这个程序，需要把程序加载到内存中，这时采用的就是mmap，mmap让虚拟空间和文件的内容组成的空间（文件空间）对应。因为ELF格式是区分代码、数据段的，这里的就不是简单的整个文件的映射了，需要将文件的分段区域映射到内存的不同位置。OS加载ELF文件的过程非常复杂这里就不展开了，具体内容可以看《程序员的自我修养》。<br>当CPU真的在这个地址上发起读写执行等操作时，因为文件的内容在磁盘上是不能被CPU访问的，所以OS会进入异常，系统的缺页处理程序会调用文件系统把一页或者多页的文件内容加载到物理内存中。</p>
<p>可以通过 <code>cat /proc/&lt;pid&gt;/maps</code>看到某个进程的mmap状态，其实就是通过遍历<code>vm_area_struct</code>链表得到的，有关maps的解释可以看<a href="http://askubuntu.com/questions/93509/how-to-interpret-proc-pid-maps-for-pidgin-application" target="_blank" rel="external">这里</a>。<br>下面是使用xlog的Android程序进程的内存状态（截取一小部分）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">shell@shamu:<span class="comment"># cat /proc/9032/maps</span></div><div class="line">address           perms offset  dev   inode   pathname</div><div class="line">//...</div><div class="line"><span class="number">0804</span>d000<span class="number">-0806e000</span> rwxp <span class="number">0804</span>d000 <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span>          [heap]</div><div class="line">b7e88000-b7e89000 rwxp b7e88000 <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span> </div><div class="line">x-x r--p <span class="number">00000000</span> fe:<span class="number">00</span> <span class="number">791721</span>     /data/dalvik-cache/arm/data@app@com.x<span class="number">-1</span>@base.apk@classes.dex</div><div class="line">x-x r-xp <span class="number">00</span>a6f000 fe:<span class="number">00</span> <span class="number">791721</span>     /data/dalvik-cache/arm/data@app@com.x<span class="number">-1</span>@base.apk@classes.dex</div><div class="line">x-x rw-p <span class="number">0155</span>d000 fe:<span class="number">00</span> <span class="number">791721</span>     /data/dalvik-cache/arm/data@app@com.x<span class="number">-1</span>@base.apk@classes.dex</div><div class="line">x-x r--p <span class="number">00000000</span> <span class="number">103</span>:<span class="number">09</span> <span class="number">630</span>       /system/fonts/CarroisGothicSC-Regular.ttf</div><div class="line">b35b7000-b35dd000 rw-s <span class="number">00000000</span> <span class="number">00</span>:<span class="number">14</span> <span class="number">3082</span>       /storage/emulated/<span class="number">0</span>/log.mmap2</div><div class="line">b6fb6000-b6fc3000 r-xp <span class="number">00000000</span> <span class="number">103</span>:<span class="number">09</span> <span class="number">206</span>       /system/bin/linker</div><div class="line">b6fc3000-b6fc4000 r-xp <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span>          [sigpage]</div><div class="line">b6fc4000-b6fc5000 r--p <span class="number">0000</span>d000 <span class="number">103</span>:<span class="number">09</span> <span class="number">206</span>       /system/bin/linker</div><div class="line">b6fc5000-b6fc6000 rw-p <span class="number">0000e000</span> <span class="number">103</span>:<span class="number">09</span> <span class="number">206</span>       /system/bin/linker</div><div class="line">b6fc6000-b6fc7000 rw-p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span> </div><div class="line">b6fc7000-b6fca000 r-xp <span class="number">00000000</span> <span class="number">103</span>:<span class="number">09</span> <span class="number">136</span>       /system/bin/app_process32</div><div class="line">b6fca000-b6fcb000 r--p <span class="number">00002000</span> <span class="number">103</span>:<span class="number">09</span> <span class="number">136</span>       /system/bin/app_process32</div><div class="line">be246000-bea45000 rw-p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span>          [stack]</div><div class="line">ffff0000-ffff1000 r-xp <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span>          [vectors]</div></pre></td></tr></table></figure>
<p>这些分段空间后面的那些，就是每个虚拟空间分段对应的文件。这些文件，称为这片虚拟空间的backlog文件，它的作用是当这些内存需要被使用的时候，从磁盘中把对应的文件内容加载到物理内存中。<br>这里同一个文件<code>/system/bin/linker</code>在虚拟内存中有不同的内存映射区域，就是因为其文件中有不同的分段，从<code>offset</code>可以看出来。<br><code>/storage/emulated/0/log.mmap2</code>就是xlog用作mmap的backlog文件了，它被映射到<code>b35b7000-b35dd000</code>这段内存区域。</p>
<h2 id="5-为什么mmap-可以节约IO读写时间"><a href="#5-为什么mmap-可以节约IO读写时间" class="headerlink" title="5.为什么mmap()可以节约IO读写时间"></a>5.为什么mmap()可以节约IO读写时间</h2><p>常规文件操作为了提高读写效率和保护磁盘，使用了页缓存机制，这是由OS控制的。这样造成读文件时需要先将文件页从磁盘拷贝到页缓存中，由于页缓存处在内核空间，不能被用户进程直接寻址，所以还需要将页缓存中数据页再次拷贝到内存对应的用户空间中。这样，通过了两次数据拷贝过程，才能完成进程对文件内容的获取任务。写操作也是一样，待写入的buffer在内核空间不能直接访问，必须要先拷贝至内核空间对应的主存，再写回磁盘中（延迟写回），也是需要两次数据拷贝。</p>
<p>而使用mmap操作文件中，由于不需要经过内核空间的数据缓存，只使用一次数据拷贝，就从磁盘中将数据传入内存的用户空间中，供进程使用。<br>mmap的关键点是实现了用户空间和内核空间的数据直接交互而省去了空间不同数据不通的繁琐过程。因此mmap效率更高。</p>
<h3 id="xlog对mmap的效率做了验证"><a href="#xlog对mmap的效率做了验证" class="headerlink" title="xlog对mmap的效率做了验证"></a>xlog对mmap的效率做了验证</h3><p>为了验证 mmap 是否真的有直接写内存的效率，通过一个简单的测试用例进行验证：把512 Byte的数据分别写入150 kb大小的内存和 mmap，以及磁盘文件100w次并统计耗时<br><img src="http://7viip0.com1.z0.glb.clouddn.com/17-2-25/57475458-file_1488014455835_4ad2.jpg" alt=""><br>从上图看出mmap几乎和直接写内存一样的性能，而且 mmap 既不会丢日志，回写时机又基本可控。 </p>
<hr>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li>《深入理解计算机操作系统》</li>
<li>《程序员的自我修养》</li>
<li><a href="http://www.cnblogs.com/huxiao-tee/p/4660352.html" target="_blank" rel="external">认真分析mmap：是什么 为什么 怎么用 </a></li>
<li><a href="http://dev.qq.com/topic/581c2c46bef1702a2db3ae53" target="_blank" rel="external">微信mars 的高性能日志模块 xlog</a></li>
<li><a href="https://www.zhihu.com/question/48161206/answer/110418693" target="_blank" rel="external">Linux 中 mmap() 函数的内存映射问题理解</a></li>
<li><a href="https://linux.die.net/man/5/proc" target="_blank" rel="external">proc(5) - Linux man page</a></li>
<li><a href="http://askubuntu.com/questions/93509/how-to-interpret-proc-pid-maps-for-pidgin-application" target="_blank" rel="external">How to interpret /proc/pid/maps</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在接入日志组件xlog的工作中，对mmap内存映射加深了了解，分享一下学习心得。&lt;/p&gt;
&lt;h2 id=&quot;1-一个Linux进程的虚拟内存&quot;&gt;&lt;a href=&quot;#1-一个Linux进程的虚拟内存&quot; class=&quot;headerlink&quot; title=&quot;1.一个Linux进程的
    
    </summary>
    
    
      <category term="Linux" scheme="http://felixzhang00.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>用Android Studio调试Framework层代码</title>
    <link href="http://felixzhang00.github.io/2017/01/23/%E7%94%A8Android%20Studio%E8%B0%83%E8%AF%95Framework%E5%B1%82%E4%BB%A3%E7%A0%81/"/>
    <id>http://felixzhang00.github.io/2017/01/23/用Android Studio调试Framework层代码/</id>
    <published>2017-01-23T01:20:06.000Z</published>
    <updated>2020-04-13T06:52:27.295Z</updated>
    
    <content type="html"><![CDATA[<p>Android程序员不得不知的调试技巧。<br>本文以webview loadUrl和域名解析为例,介绍配合使用LLDB和Android Studio调试Framework代码的技巧。</p>
<h2 id="java-层调试"><a href="#java-层调试" class="headerlink" title="java 层调试"></a>java 层调试</h2><p>首先需要把AOSP源码导入到Android Studio中，如果是macOS系统可以参考<a href="http://blog.csdn.net/u012455213/article/details/54647010" target="_blank" rel="external">这篇文章</a>。<br>导入后如下图所示：<br><img src="http://ww1.sinaimg.cn/large/8b331ee1gy1gds4vshutdj207a0fzdiw.jpg" alt=""></p>
<h3 id="调试原理"><a href="#调试原理" class="headerlink" title="调试原理"></a>调试原理</h3><p>Java平台的调试是有一个规范化的标准的，那就是JPDA（Java Platform Debugger Architecture）；通过 JPDA 提供的 API，开发人员可以方便灵活的搭建 Java 调试应用程序。 JPDA 主要由三个部分组成：Java 虚拟机工具接口（JVMTI），Java 调试线协议（JDWP），以及 Java 调试接口（JDI）。<br>调试需要堆栈、符号等信息都保存在JVM中，调试器（debugger）需要通过一种渠道获取这些信息，并通过这个渠道发送调试指令给JVM，JDWP就是调试器与JVM通信的渠道。在JVM内部有一个专门的jdwp线程，Android系统的adbd守护进程通过socket与各个虚拟机的jdwp线程进行通信，外部调试器通过主机的adb与adbd通信进而完成与jdwp的通信。具体过程如下图：<br><img src="http://ww1.sinaimg.cn/large/8b331ee1gy1gds4wwfle0j20fh0bejs2.jpg" alt="调试架构图"></p>
<h3 id="配置Debug选项"><a href="#配置Debug选项" class="headerlink" title="配置Debug选项"></a>配置Debug选项</h3><p>在菜单栏上依次点击Run -&gt; Edit Configurations -&gt; Remote，打开并配置成如下的页面<br><img src="http://ww1.sinaimg.cn/large/8b331ee1gy1gds4xjyk10j21900u00zk.jpg" alt="aosp_java_debug"></p>
<h3 id="Exclued-不必要的文件夹"><a href="#Exclued-不必要的文件夹" class="headerlink" title="Exclued 不必要的文件夹"></a>Exclued 不必要的文件夹</h3><p>在断点调试时，JVM会告诉AS自己在xx.java的第xx行被断住了，AS就会定位到这个位置，但是如果有重复的文件的名的，往往会出现定位不准的情况，所以需要把不必要的文件夹排除在整个源码结构之外。打开Project Structure,做如下修改<br><img src="http://ww1.sinaimg.cn/large/8b331ee1gy1gds4y6n8oaj20dc085767.jpg" alt="Exclued"><br>如果遇上断点文件对不上的情况时，就手动在这里Exclued好了。<br>也可以直接修改<code>aosp-root/development/tools/idegen/excluded-paths</code>文件中的内容，添加exclude，再运行<code>idegen.sh</code> 重新生成IDE代码树。</p>
<h3 id="在源码处打断点"><a href="#在源码处打断点" class="headerlink" title="在源码处打断点"></a>在源码处打断点</h3><p>我们在WebView.java的loadUrl处打断点<br><img src="http://ww1.sinaimg.cn/large/8b331ee1gy1gds4ymbc98j21900ckjx9.jpg" alt="dd"><br>点击调试按钮，你会看到Console中的提示<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Connected to the target VM, address: <span class="string">'localhost:8700'</span> , transport: <span class="string">'socket'</span></div></pre></td></tr></table></figure></p>
<h3 id="打开DDMS"><a href="#打开DDMS" class="headerlink" title="打开DDMS"></a>打开DDMS</h3><p>在菜单栏上依次点击Tools -&gt;Android -&gt; Android Device Monitor，打开DDMS后,点击<br><img src="http://ww1.sinaimg.cn/large/8b331ee1gy1gds4zc44wnj218n0d341s.jpg" alt="ddms.png"></p>
<p>在monitor中我们可以看到有3列，分别是</p>
<ul>
<li>进程名(以包名显示)</li>
<li>PID(Process ID)</li>
<li>端口号(映射端口号/实际端口号)<br>点击我们要调试的browser程序的那一行，会出现一只绿色的bug，表示我们的Debugger已经跟设备上的程序联系上，可以调试了。</li>
</ul>
<h3 id="开始调试"><a href="#开始调试" class="headerlink" title="开始调试"></a>开始调试</h3><p>当在浏览器中加载一个网页时，就能触发之前设置的loadUrl的断点了，如此就可以使用各种调试手段了。<br><img src="http://ww1.sinaimg.cn/large/8b331ee1gy1gds4zxmc02j210i0s6dnq.jpg" alt="loadUrl堆栈.png"></p>
<hr>
<h2 id="C-层调试"><a href="#C-层调试" class="headerlink" title="C++层调试"></a>C++层调试</h2><p>Android Framework中native代码的调试方法采用的是 2.2以上版本的Android Studio配合LLDB调试器。<br>这里以调试webview的dns查找过程为例，说明native调试的方法。</p>
<h3 id="调试原理-1"><a href="#调试原理-1" class="headerlink" title="调试原理"></a>调试原理</h3><p>LLDB作为Android Native层的调试工具，其原理跟gdb一样，也是采用C/S架构，通过push一个lldb-server到设备上，pc机的debugger作为lldb-client与其通信，以达到调试的效果。<br>C++在编译时有一个选项<code>-g</code>表示编译出来的可执行文件是带有调试信息的，比如源文件、行号信息，都会存放在ELF文件中的<br><code>.debug_*</code>段之中， 知道了这些调试信息后，调试器配合IDE就可以定位代码了。<br>这里还需要保证你的符号文件和设备上真正运行的动态链接库或者可执行文件是对应的，就是同一份，不然调试信息就对不上了。<br>最简单的办法就是使用模拟器。我们编译完源码之后，一个主要的编译产物就是 system.img，这个 system.img会在启动之后挂载到设备的 /system 分区，而system分区包含了Android系统运行时的绝大部分可执行文件和动态链接库，而这些文件就是我们的编译输出，正好可以与编译得到的调试符号进行配合调试。模拟器有一个 -system选项用来指定模拟器使用的 system.img文件。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ emulator -avd Nexus5-API22 -verbose -no-boot-anim -system (the path of system.img)</div></pre></td></tr></table></figure></p>
<p>我这里的做法是使用烧录了自己编译源码的Nexus手机。</p>
<h3 id="配置Debugger"><a href="#配置Debugger" class="headerlink" title="配置Debugger"></a>配置Debugger</h3><p>这里需要新建一个Android Demo工程了，直接用AOSP源码那个工程，没有是Native Debug那个选项的。<br>按如下方式配置符号表，需要与设备上用的so是同一份。并且改Debug type 为Native。<br><img src="http://ww1.sinaimg.cn/large/8b331ee1gy1gds51d4y7yj211t0d4dhl.jpg" alt="配置Debugger.png"></p>
<p>符号表的添加也可以通过lldb命令行的方式添加</p>
<p><img src="http://ww1.sinaimg.cn/large/8b331ee1gy1gds51ol9u2j203d02q0sl.jpg" alt="lldb-pause"></p>
<p><img src="http://ww1.sinaimg.cn/large/8b331ee1gy1gds52iv28sj219006vn1a.jpg" alt="lldb-add-dsym.png"><br>LLDB需要这些符号信息才能帮你定位到调试断点的代码。</p>
<h3 id="配置源码到AS"><a href="#配置源码到AS" class="headerlink" title="配置源码到AS"></a>配置源码到AS</h3><p>当LLDB告诉AS源文件行号信息时，AS需要定位到对应的代码处，所以必须先把源文件导入到AS中，最简单的做法是建立软链接。在Android Demo工程下建立一个source文件夹，然后执行如下命令。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ ln <span class="_">-s</span> xx/external/chromium_org  xx/<span class="built_in">source</span>/chromium_org</div><div class="line">$ ln <span class="_">-s</span> xx/bionic/libc  xx/<span class="built_in">source</span>/libc</div></pre></td></tr></table></figure></p>
<p>这里只是把需要用到的源文件导入进来，当然也可以把整个AOSP源码导入AS中，但是这样会比较耗时。</p>
<h3 id="打断点"><a href="#打断点" class="headerlink" title="打断点"></a>打断点</h3><p>我在getaddrinfo.c的getaddrinfo方法处打一个断点，看看webview在加载网页时的域名解析会不会走到这里。<br><img src="http://ww1.sinaimg.cn/large/8b331ee1gy1gds534tma5j219005vjv1.jpg" alt="getaddrinfo.png"><br>点击Debug按钮，当Demo程序开始LoadUrl之后，就会被Debug断住，如下是chromium域名解析线程的堆栈（这里的方法名真够长的。。。），这样我们就可以进一步了解webview加载网页时域名解析的过程了。<br><img src="http://ww1.sinaimg.cn/large/8b331ee1gy1gds55b7bb0j21900e3n5v.jpg" alt="getaddrinfo-stack.png"><br>让我们看看其他线程在干啥，整个世界都停止了。<br><img src="http://ww1.sinaimg.cn/large/8b331ee1gy1gds55pzoetj20um0d4416.jpg" alt="chromium-threads.png"></p>
<p><img src="http://ww1.sinaimg.cn/large/8b331ee1gy1gds568u1hrj20zo0fmmzw.jpg" alt="renderthread.png"></p>
<p><img src="http://ww1.sinaimg.cn/large/8b331ee1gy1gds56o9vk0j20zo0duq5k.jpg" alt="jdwp.png"></p>
<hr>
<h2 id="不足之处"><a href="#不足之处" class="headerlink" title="不足之处"></a>不足之处</h2><p>目前的调试framework方案只能把java层和c++ native层的分开来做，还不能做到java层和c++ native层互相跳转的效果。虽然目前我们开发Android App用AS调试时能做大这一点，要是framework的调试也能做到这一点就好了。获取真有这样的方法，如果有知道的大神，还请赐教。</p>
<hr>
<h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><p><a href="http://ronubo.blogspot.com/2016/01/debugging-aosp-platform-code-with.html" target="_blank" rel="external">Debugging AOSP Platform code with Android Studio - Part I - Java Debugger</a><br><a href="http://ronubo.blogspot.com/2016/01/android-debugging-old-school-bringup.html" target="_blank" rel="external">Android Debugging: Old School bringup routines - Command line Java debugging with JDWP</a><br><a href="http://weishu.me/2016/05/30/how-to-debug-android-framework/index.html" target="_blank" rel="external">如何调试Android Framework</a><br><a href="http://weishu.me/2017/01/14/how-to-debug-android-native-framework-source/index.html" target="_blank" rel="external">如何调试Android Native Framework</a><br><a href="http://blog.csdn.net/u012455213/article/details/54647010" target="_blank" rel="external">在macOS 10.12 上编译 Android 5.1</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Android程序员不得不知的调试技巧。&lt;br&gt;本文以webview loadUrl和域名解析为例,介绍配合使用LLDB和Android Studio调试Framework代码的技巧。&lt;/p&gt;
&lt;h2 id=&quot;java-层调试&quot;&gt;&lt;a href=&quot;#java-层调试&quot; cl
    
    </summary>
    
    
      <category term="Android DEBUG" scheme="http://felixzhang00.github.io/tags/Android-DEBUG/"/>
    
  </entry>
  
  <entry>
    <title>在macOS 10.12 上编译 Android 5.1</title>
    <link href="http://felixzhang00.github.io/2017/01/21/%E5%9C%A8macOS%2010.12%20%E4%B8%8A%E7%BC%96%E8%AF%91%20Android%205.1/"/>
    <id>http://felixzhang00.github.io/2017/01/21/在macOS 10.12 上编译 Android 5.1/</id>
    <published>2017-01-21T10:55:45.000Z</published>
    <updated>2017-01-21T11:03:56.000Z</updated>
    
    <content type="html"><![CDATA[<hr>
<p>官方文档虽然也有介绍，但是macOS平台上的编译环境问题还存在很多坑。本文介绍下如何在在macOS 10.12 上编译 Android 5.1源码，导入源码到Android Studio中，把系统烧录到Nexus6手机中。</p>
<hr>
<h2 id="搭建编译环境"><a href="#搭建编译环境" class="headerlink" title="搭建编译环境"></a>搭建编译环境</h2><h3 id="创建分区"><a href="#创建分区" class="headerlink" title="创建分区"></a>创建分区</h3><p>AOSP源码需要一个支持大小写敏感的文件系统，100G是至少要的。<a href="https://source.android.com/source/initializing.html#setting-up-a-mac-os-x-build-environment" target="_blank" rel="external">官网</a>有详细的介绍，这里简单列一下。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hdiutil create -type SPARSE -fs <span class="string">'Case-sensitive Journaled HFS+'</span> -size 40g ~/android.dmg</div></pre></td></tr></table></figure></p>
<p>然后挂载这个分区：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hdiutil attach ~/android.dmg -mountpoint /Volumes/android;</div></pre></td></tr></table></figure></p>
<h3 id="切换shell"><a href="#切换shell" class="headerlink" title="切换shell"></a>切换shell</h3><p>Android的相关编译只能是使用bash.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ chsh -s /bin/bash</div></pre></td></tr></table></figure></p>
<p>重启终端。</p>
<h3 id="安装Xcode"><a href="#安装Xcode" class="headerlink" title="安装Xcode"></a>安装Xcode</h3><p>1、这里需要两个Xcode，可以用命令切换需要使用的Xcode，会有不同的用处。</p>
<ul>
<li>去AppStore下载最新的Xcode</li>
<li>到<a href="https://developer.apple.com/download/more/" target="_blank" rel="external">这里</a>下载5.1.1的Xcode</li>
</ul>
<p>2、创建一个<code>/Developer/SDK</code>文件夹，从Xcode5.1.1中把<code>MacOSX10.8.sdk</code>从<code>Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/</code>复制到 <code>/Developer/SDK</code>中。<br>3、从<code>Xcode5.1.1.dmg</code>复制Xcode.app 到  <code>/Developer</code>目录中。<br>4、从AppStore下载的最新版Xcode会默认放在<code>/Applications</code>目录中<br>5、给两个版本的Xcode都安装command line tools<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ sudo xcode-select -switch /Developer/Xcode.app</div><div class="line">$ xcode-select --install</div><div class="line">$ sudo xcode-select -switch /Applications/Xcode.app</div><div class="line">$ xcode-select --install</div></pre></td></tr></table></figure></p>
<h3 id="安装JDK"><a href="#安装JDK" class="headerlink" title="安装JDK"></a>安装JDK</h3><p>编译Android5.1需要jdk1.7，去<a href="http://www.oracle.com/technetwork/java/javase/downloads/jre7-downloads-1880261.html" target="_blank" rel="external">官网</a>下载.<br>如果有切换多个版本的jdk需求的话，可以使用<code>jenv</code>这个工具，参考<a href="http://boxingp.github.io/blog/2015/01/25/manage-multiple-versions-of-java-on-os-x/" target="_blank" rel="external">在OS X中使用jEnv管理多个Java版本</a></p>
<h3 id="安装其他软件"><a href="#安装其他软件" class="headerlink" title="安装其他软件"></a>安装其他软件</h3><p>1、安装MacPorts，需要去<a href="https://www.macports.org/install.php" target="_blank" rel="external">官网</a>下载对应版本的MacPorts<br>2、配置port命令环境变量<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">export</span> PATH=/opt/<span class="built_in">local</span>/bin:<span class="variable">$PATH</span></div></pre></td></tr></table></figure></p>
<p>3、下载依赖包<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ POSIXLY_CORRECT=1 sudo port install gmake libsdl git gnupg</div></pre></td></tr></table></figure></p>
<hr>
<h2 id="下载源码"><a href="#下载源码" class="headerlink" title="下载源码"></a>下载源码</h2><p>直接去google官方下载会很慢，这里推荐用<a href="https://lug.ustc.edu.cn/wiki/mirrors/help/aosp" target="_blank" rel="external">中科大镜像</a><br>1、首先下载 repo 工具。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ mkdir ~/bin</div><div class="line">$ PATH=~/bin:<span class="variable">$PATH</span></div><div class="line">$ curl https://storage.googleapis.com/git-repo-downloads/repo &gt; ~/bin/repo</div><div class="line"><span class="comment">## 如果上述 URL 不可访问，可以用下面的：</span></div><div class="line"><span class="comment">## curl https://storage-googleapis.proxy.ustclug.org/git-repo-downloads/repo &gt; ~/bin/repo</span></div><div class="line">$ chmod a+x ~/bin/repo</div></pre></td></tr></table></figure></p>
<p>2、在之前创建的大小写分区上建立一个工作目录，之后源码下载和编译都在这里进行。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ mkdir WORKING_DIRECTORY</div><div class="line">$ <span class="built_in">cd</span> WORKING_DIRECTORY</div></pre></td></tr></table></figure></p>
<p>3、初始化仓库<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ repo init -u git://mirrors.ustc.edu.cn/aosp/platform/manifest</div><div class="line"><span class="comment">## 如果提示无法连接到 gerrit.googlesource.com，可以编辑 ~/bin/repo，把 REPO_URL 一行替换成下面的：</span></div><div class="line"><span class="comment">## REPO_URL = 'https://gerrit-googlesource.proxy.ustclug.org/git-repo'</span></div></pre></td></tr></table></figure></p>
<p>4、选择某个特定的 Android 版本，具体查看<a href="https://source.android.com/source/build-numbers.html#source-code-tags-and-builds" target="_blank" rel="external">这里</a>,我选择的是android-5.1.1_r14，build号是LMY48M，等会用这个build号下载对应的驱动包，烧录到nexus真机时会用到。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ repo init -u git://mirrors.ustc.edu.cn/aosp/platform/manifest -b android-5.1.1_r14</div></pre></td></tr></table></figure></p>
<p>5、同步源码树<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ repo sync</div></pre></td></tr></table></figure></p>
<p>源码下载完后，如果没有同步的需求的话，就可以把<code>.repo</code>目录删掉了，防止编译时磁盘空间不够用。</p>
<h2 id="下载驱动"><a href="#下载驱动" class="headerlink" title="下载驱动"></a>下载驱动</h2><p>烧录到真机时需要用到，默认只是用模拟器的话，可以跳过这步。<br>在<a href="https://developers.google.com/android/nexus/drivers#hikey中找到对应设备与源码分支的硬件驱动。刚才选择的源码分支所对应的build码是LMY48M，因此，就下载此代号的驱动程序即可。" target="_blank" rel="external">https://developers.google.com/android/nexus/drivers#hikey中找到对应设备与源码分支的硬件驱动。刚才选择的源码分支所对应的build码是LMY48M，因此，就下载此代号的驱动程序即可。</a><br>下载得到的是三个tgz文件，我们只需依次解压三个文件，得到的是三个shell脚本文件，我们先将其置于源码根目录中。<br>依次执行这3个脚本将在源码根目录中生成一个vendor文件夹。</p>
<hr>
<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><h3 id="设置文件描述符限制"><a href="#设置文件描述符限制" class="headerlink" title="设置文件描述符限制"></a>设置文件描述符限制</h3><p>在macOS中，默认限制的同时打开的文件数量很少，不能满足编译过程中的高并发需要，因此需要在shell中运行命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">ulimit</span> -S -n 1024</div></pre></td></tr></table></figure></p>
<h3 id="环境设置"><a href="#环境设置" class="headerlink" title="环境设置"></a>环境设置</h3><p>在源码根目录下调用下面的命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">source</span> build/envsetup.sh</div></pre></td></tr></table></figure></p>
<h3 id="选择设备"><a href="#选择设备" class="headerlink" title="选择设备"></a>选择设备</h3><p>因为我编译后需要烧录到Nexus6上，所以选择<code>aosp_shamu-userdebug</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ lunch aosp_shamu-userdebug</div></pre></td></tr></table></figure></p>
<p>如果不需要烧录到真机上的话，用默认的<code>aosp_arm-eng</code>类型就可以了。</p>
<h3 id="开始编译"><a href="#开始编译" class="headerlink" title="开始编译"></a>开始编译</h3><p>因为本机CPU的内核是8核的，所以开16个线程加快编译。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ make -j16</div></pre></td></tr></table></figure></p>
<p>编译成功后，会有类似下面的日志：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#### make completed successfully (30:28:08 (hh:mm:ss)) ####</span></div></pre></td></tr></table></figure></p>
<p>编译成功的结果都在<code>out</code>目录中。<br>如果lunch的是<code>aosp_arm-eng</code>类型，就可以用<code>$ emulator</code>命令刷到模拟器了。</p>
<hr>
<h2 id="源码导入到Android-Studio中"><a href="#源码导入到Android-Studio中" class="headerlink" title="源码导入到Android Studio中"></a>源码导入到Android Studio中</h2><p>为了方便查看源码，可以把代码导入到AS中。目前看来，只能支持Java的跳转，对c++的支持不太好。<br>为了让AS理解代码的符号和源码树的结构，需要用如下命令生成一个<code>android.ipr</code>工程配置文件。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ mmm development/tools/idegen/</div><div class="line">$ development/tools/idegen/idegen.sh</div></pre></td></tr></table></figure></p>
<p>大约需要十几秒的时间，就能在源码根目录下生成android.ipr和android.iml了。<br>用AS打开android.ipr就能导入整个源码了。<br>如果要支持跳转的话，还需要做些配置，可以看这篇教程：<a href="http://blog.justain.net/index.php/import-aosp-into-android-studio/" target="_blank" rel="external">Import AOSP into Android Studio</a></p>
<hr>
<h2 id="刷机"><a href="#刷机" class="headerlink" title="刷机"></a>刷机</h2><p>Nexus6手机在打开USB调试，连接电脑后允许调试这台手机，并且在设置中打开“允许 OEM 解锁”。然后令手机进入recovery模式，在关机下，输入如下命令即可：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ adb reboot bootloader</div></pre></td></tr></table></figure></p>
<p>执行如下命令刷机：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ fastboot -w flashall</div></pre></td></tr></table></figure></p>
<p>刷机成功后，手机会自动重启，新鲜出炉的系统终于跑起来了。<br>刷机过程中也出现过变砖的情况，可以试一下<a href="http://www.shuame.com/faq/restore-tutorial/14679-google-nexus6.html" target="_blank" rel="external">这个教程</a>，亲测有效。</p>
<hr>
<h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><p><a href="https://medium.com/@raminmahmoodi/build-android-5-0-lollipop-on-osx-10-10-yosemite-441bd00ee77a" target="_blank" rel="external">Build Android 5.0 Lollipop on OSX 10.10 Yosemite</a><br><a href="http://blog.bihe0832.com/macOS-AOSP.html" target="_blank" rel="external">http://blog.bihe0832.com/macOS-AOSP.html</a><br><a href="http://boxingp.github.io/blog/2015/01/25/manage-multiple-versions-of-java-on-os-x/" target="_blank" rel="external">在OS X中使用jEnv管理多个Java版本</a><br><a href="http://blog.justain.net/index.php/import-aosp-into-android-studio/" target="_blank" rel="external">Import AOSP into Android Studio</a><br><a href="http://www.shuame.com/faq/restore-tutorial/14679-google-nexus6.html" target="_blank" rel="external">Nexus 6 恢复官方兼救砖</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;官方文档虽然也有介绍，但是macOS平台上的编译环境问题还存在很多坑。本文介绍下如何在在macOS 10.12 上编译 Android 5.1源码，导入源码到Android Studio中，把系统烧录到Nexus6手机中。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;搭建编
    
    </summary>
    
    
      <category term="Android" scheme="http://felixzhang00.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Docker简单使用</title>
    <link href="http://felixzhang00.github.io/2017/01/21/Docker%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
    <id>http://felixzhang00.github.io/2017/01/21/Docker简单使用/</id>
    <published>2017-01-21T07:06:30.000Z</published>
    <updated>2017-01-21T07:07:09.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/24633328" target="_blank" rel="external">史上最简单Android源码编译环境搭建方法</a>这篇分享介绍了借助Docker来编译Android源码，Docker可以直接把编译工具链和Ubuntu系统整体打包，保证了编译环境和官方的一致。<br>我用的macOS，之前尝试过编译AOSP，出现各种问题，采用虚拟机的方式也常常编译不过，看到可以用docker的新方式，打算尝试用一下。但是从我实际操作来看，docker在mac上是很慢的，并不比虚拟机快多少，在编译AOSP时也会造成卡死，因为在mac平台上docker是要运行在一个虚拟机上的。在尝试docker编译AOSP失败后，我最终还是用macOS编译了，最终成功烧录到nexus手机上。<br>虽然docker不适合我编译AOSP，但是作为一个操作系统级虚拟化实现方案，还是非常优秀滴。写一个编译器做成一个镜像，放在docker容器里运行还是绰绰有余的，比如《自制编译器》里的<code>cbc编译器</code>, 有人就做了一个镜像上传到<a href="https://hub.docker.com/r/leungwensen/cbc-ubuntu-64bit/" target="_blank" rel="external">DockerHub</a>上了，这样就避免了需要配置一堆环境依赖的麻烦了。<br>也算是对Docker研究了半天，简单记录下docker的用法吧。</p>
<hr>
<h2 id="Docker简介"><a href="#Docker简介" class="headerlink" title="Docker简介"></a>Docker简介</h2><h3 id="为什么说Docker比虚拟机快呢？"><a href="#为什么说Docker比虚拟机快呢？" class="headerlink" title="为什么说Docker比虚拟机快呢？"></a>为什么说Docker比虚拟机快呢？</h3><p>因为Docker容器需要的开销有限。和传统的虚拟化相比，容器运行不需要模拟层和管理层，而是使用操作系统的系统调用接口。这降低了运行单个容器所需的开销，也使得宿主机中可以运行更多容器。<br>但这个是对Host机为Linux而言的，macOS上运行docker容器本质上还是跑在linux虚拟机上的。</p>
<h3 id="什么是docker"><a href="#什么是docker" class="headerlink" title="什么是docker"></a>什么是docker</h3><p>镜像是Docker生命周期中的构建或打包阶段，而容器则是启动或执行阶段。<br>简单来说，Docker就是：</p>
<ul>
<li>一个镜像格式</li>
<li>一系列标准的操作</li>
<li>一个执行环境</li>
</ul>
<p>镜像是基于联合文件系统的一种层式的结构，由一系列指令一步一步构建出来，例如：添加一个文件；执行一个名人；打开一个端口。<br>当从一个镜像启动容器时，Docker会在该镜像的最底层加载一个读写文件系统，我们想在Docker中运行的程序就是在这个读写层中执行的。<br>下图是Docker的文件系统层。<br><img src="http://p1.bqimg.com/567571/d31fea71fb692f4d.png" alt="Docker文件系统层"></p>
<p>构建镜像最方便的做法是写一个Dockerfile文件，让docker自带的工具读它，然后生出一个镜像文件来。<br>Dockerfile使用基本的基于DSL语法的指令来构建一个Docker镜像，之后使用docker build命令基于该Dockerfile中的指令构建一个新的镜像。<br>每条指令都会创建一个新的镜像层并对镜像进行提交。Docker大体上按照如下的流程执行Dockerfile中的指令。</p>
<ul>
<li>Docker从基础镜像运行一个容器。</li>
<li>执行一条指令，对容器做出修改。</li>
<li>执行类似docker commit的操作，提交一个新的镜像层。</li>
<li>Docker再基于刚提交的镜像运行一个新容器。</li>
<li>执行Dockerfile中的下一条指令，直到所有指令都执行完毕。</li>
</ul>
<p>这里给两个简单的例子，可以自己研究下：</p>
<ul>
<li><a href="https://hub.docker.com/r/leungwensen/cbc-ubuntu-64bit/" target="_blank" rel="external">cbc-ubuntu-64bit</a></li>
<li><a href="https://hub.docker.com/r/kylemanna/aosp/" target="_blank" rel="external">aosp</a></li>
</ul>
<hr>
<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p>去<a href="https://www.docker.com/" target="_blank" rel="external">Docker官网</a>下载对应操作系统的安装包后，就可以使用了。<br>打开 Kitematic, 可以在这里下载镜像，dockerhub的形式跟github很像，可以commit、pull等。<br><img src="http://p1.bqimg.com/567571/9d49704a11c5ecad.jpg" alt=""></p>
<p>Docker是基于C/S架构的，它有一个docker程序，既能作为客户端，也可以作为服务端。作为客户端时，docker程序向Docker守护进程发送请求（如请求返回守护进程自身的信息），然后再对返回的请求结果进行处理。</p>
<h3 id="通过docker-info-可以得到的一些信息"><a href="#通过docker-info-可以得到的一些信息" class="headerlink" title="通过docker info 可以得到的一些信息"></a>通过docker info 可以得到的一些信息</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">$ docker info      </div><div class="line">Containers: 10</div><div class="line"> Running: 1</div><div class="line"> Paused: 0</div><div class="line"> Stopped: 9</div><div class="line">Images: 7</div><div class="line">Server Version: 1.12.6</div><div class="line">//...</div><div class="line">Registry: https://index.docker.io/v1/</div><div class="line">WARNING: No kernel memory <span class="built_in">limit</span> support</div><div class="line">Insecure Registries:</div><div class="line"> 127.0.0.0/8</div></pre></td></tr></table></figure>
<h3 id="创建交互式容器"><a href="#创建交互式容器" class="headerlink" title="创建交互式容器"></a>创建交互式容器</h3><p>我们告诉Docker执行<code>docker run</code>命令，我们告诉Docker基于<code>ubuntu</code>镜像来创建容器，如果本地没有该镜像的话，Docker会连接官方维护的Docker Hub Registry查找该镜像，下载并保存到本地宿主机中。 <code>-i</code>保证容器中STDIN是开启的，<code>-t</code>告诉Docker为要创建的容器分配一个伪tty终端。这样，新创建的容器才能提供一个交互式shell。最后的<code>/bin/bash</code>告诉Docker在新容器中要运行什么命令。其中<code>--name</code>参数告诉Docker创建一个名为<code>test_container</code>的容器。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ sudo docker --name test_container run -i -t ubuntu /bin/bash</div><div class="line">//...</div><div class="line">root@12345:/<span class="comment">#</span></div></pre></td></tr></table></figure></p>
<p>这样，我们就能看到容器内的shell了。容器的id是12345。容器的主机名就是该容器的ID。具体可以通过<code>cat /etc/hosts</code>查看。<br>输入<code>exit</code>,就可以返回宿主机的命令行了。一旦退出容器，<code>/bin/bash</code>命令也就结束了，容器也随之停止运行。但容器是仍然存在的。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">root@12345:/<span class="comment"># exit</span></div></pre></td></tr></table></figure></p>
<p>用<code>docker ps -a</code>命令查看当前系统中容器的列表</p>
<p>Docker容器重新启动的时候，会沿用docker run命令时指定的参数来运行。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo docker restart (container name or id)</div></pre></td></tr></table></figure></p>
<hr>
<h3 id="创建守护式容器"><a href="#创建守护式容器" class="headerlink" title="创建守护式容器"></a>创建守护式容器</h3><p><code>-d</code>参数告诉Docker把容器放到后台运行。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo docker run --name daemon_dave <span class="_">-d</span> ubuntu /bin/sh -c <span class="string">"while true; do echo hello world; sleep 1; done"</span></div></pre></td></tr></table></figure></p>
<h3 id="容器内部都在干些什么"><a href="#容器内部都在干些什么" class="headerlink" title="容器内部都在干些什么"></a>容器内部都在干些什么</h3><p>用<code>docker logs</code>命令来获取容器的日志。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo docker logs (container name or id)</div></pre></td></tr></table></figure></p>
<h3 id="查看容器内的进程"><a href="#查看容器内的进程" class="headerlink" title="查看容器内的进程"></a>查看容器内的进程</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo docker top (container name or id)</div></pre></td></tr></table></figure>
<h3 id="在容器内部运行进程"><a href="#在容器内部运行进程" class="headerlink" title="在容器内部运行进程"></a>在容器内部运行进程</h3><p>通过<code>docker exec</code>命令在容器内部额外启动新进程，<br>如下启动了新的后台任务和交互式任务。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo docker <span class="built_in">exec</span> <span class="_">-d</span> (container name or id) touch /etc/new_config_file</div></pre></td></tr></table></figure></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo docker <span class="built_in">exec</span> -t -i (container name or id) /bin/bash</div></pre></td></tr></table></figure>
<h3 id="停止守护式容器"><a href="#停止守护式容器" class="headerlink" title="停止守护式容器"></a>停止守护式容器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo docker stop (container name or id)</div></pre></td></tr></table></figure>
<h3 id="自动重启容器"><a href="#自动重启容器" class="headerlink" title="自动重启容器"></a>自动重启容器</h3><p><code>--restart</code>标志会检查容器的退出代码，并据此来决定是否重启容器。<br>比如<code>--restart=onfailure:5</code>表示Docker会尝试自动重启该容器，最多重启5次。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo docker run --restart=always --name daemon_dave <span class="_">-d</span> ubuntu /bin/sh -c <span class="string">"while true; do echo hello world; sleep 1; done"</span></div></pre></td></tr></table></figure></p>
<h3 id="深入容器"><a href="#深入容器" class="headerlink" title="深入容器"></a>深入容器</h3><p><code>docker inspect</code>命令会对容器进行详细的检查，然后返回其配置信息，包括名称、命令、网络配置等。这是一大串json数据，可以用<code>--format</code>标志来选定查看结果。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ sudo docker inspect --format=<span class="string">'&#123;&#123;.Args&#125;&#125;'</span> (container name or id)</div><div class="line">[run.sh docker]</div></pre></td></tr></table></figure></p>
<h3 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo docker rm (container name or id)</div></pre></td></tr></table></figure>
<p>一次删除所有容器<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo docker rm `docker ps <span class="_">-a</span> -q`</div></pre></td></tr></table></figure></p>
<h3 id="列出镜像"><a href="#列出镜像" class="headerlink" title="列出镜像"></a>列出镜像</h3><p>用<code>docker images</code>得到本地的镜像列表。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ sudo docker images</div><div class="line">REPOSITORY  TAG     IMAGE ID       CREATED    	SIZE</div><div class="line">ubuntu      latest  104bec311bcd   4 weeks ago  129 MB</div><div class="line">ubuntu      14.04   xxx   		   x weeks ago  xxx MB</div></pre></td></tr></table></figure></p>
<p>镜像保存在仓库中，而仓库在于Registry中，默认的Registry是Docker Hub。<br>每个镜像仓库都可以存放很多镜像（比如ubuntu仓库包含了ubuntu各个版本的镜像）。<br>执行<code>sudo docker pull ubuntu</code>命令来拉取ubuntu仓库中所有内容。<br>每个镜像在列出来时都带有一个标签，用于对组成特定镜像的一些镜像层镜像标记。<br>用如下的方式来指定该仓库的某一镜像<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo docker run -ti ubuntu:12.04 /bin/bash</div></pre></td></tr></table></figure></p>
<p>Docker Hub中有两种类型的仓库：用户仓库和顶层仓库。<br><code>用户名/仓库名</code>这种形式表示用户仓库，是由Docker用户创建的；<br>顶层仓库只包含仓库名部分，由Docker内部人来管理的。</p>
<hr>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>因为我只是想用docker来配一个编译aosp的环境，对于Docker的很多高级功能还没有接触，比如利用连接和卷之类的Docker特性来组合并管理运行与Docker中的应用、创建多容器的应用栈等。</p>
<hr>
<p> 相关链接<br><a href="https://zhuanlan.zhihu.com/p/24633328" target="_blank" rel="external">史上最简单Android源码编译环境搭建方法</a><br><a href="https://hub.docker.com/r/leungwensen/cbc-ubuntu-64bit/" target="_blank" rel="external">cbc-ubuntu-64bit</a><br><a href="http://numbbbbb.com/2016/09/26/20160926_%E7%94%A8%20Docker%20%E5%BF%AB%E9%80%9F%E9%85%8D%E7%BD%AE%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/" target="_blank" rel="external">用 Docker 快速配置前端开发环境</a><br><a href="https://book.douban.com/subject/26285268/" target="_blank" rel="external">《第一本Docker书》</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/24633328&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;史上最简单Android源码编译环境搭建方法&lt;/a&gt;这篇分享介绍了借助Docker来编译Android源码，Dock
    
    </summary>
    
    
      <category term="工具 docker" scheme="http://felixzhang00.github.io/tags/%E5%B7%A5%E5%85%B7-docker/"/>
    
  </entry>
  
  <entry>
    <title>xlog接入方案</title>
    <link href="http://felixzhang00.github.io/2017/01/12/xlog%E6%8E%A5%E5%85%A5%E6%96%B9%E6%A1%88/"/>
    <id>http://felixzhang00.github.io/2017/01/12/xlog接入方案/</id>
    <published>2017-01-12T15:15:34.000Z</published>
    <updated>2017-01-12T15:16:32.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/Tencent/mars" target="_blank" rel="external">mars</a> 是微信最近开源的终端基础组件，是一个使用 C++ 编写的基础组件。<br>xlog是其中一个可单独使用的高性能日志模块。<br>本文将简单介绍下xlog的特点，并给出一个自定义的输出到文件的策略。</p>
<hr>
<h2 id="xlog的特点"><a href="#xlog的特点" class="headerlink" title="xlog的特点"></a>xlog的特点</h2><p>使用流式压缩方式对单行日志进行压缩，压缩加密后写进作为 log 中间 buffer的 mmap 中，当 mmap 中的数据到达一定大小后再写进磁盘文件中。<br><img src="http://ww4.sinaimg.cn/large/8b331ee1gw1fbmxsvozhbj20jg08iglr.jpg" alt=""><br><img src="http://ww3.sinaimg.cn/large/8b331ee1gw1fbmxtm3kajj20kp04caa7.jpg" alt=""></p>
<p>输出到文件的主要实现是在 Appender 模块也是可插拔的，如果对默认的策略不满意可以自己实现一套。<br><img src="http://ww3.sinaimg.cn/large/8b331ee1gw1fblriu5wrqj20ci0630sv.jpg" alt=""></p>
<p>xlog还存在一些其他策略：</p>
<ul>
<li>每次启动的时候会清理日志，防止占用太多用户磁盘空间</li>
<li>为了防止 sdcard 被拔掉导致写不了日志，支持设置缓存目录，当 sdcard 插上时会把缓存目录里的日志写入到 sdcard 上</li>
</ul>
<p>从下面的log2file流程图中可以看出xlog是如何利用cahce目录解决插拔sdcard的问题的。<br><code>log2file流程图</code><br><img src="http://ww4.sinaimg.cn/large/8b331ee1gw1fbmlojbj7dj210i19648b.jpg" alt=""></p>
<h3 id="上一次没写完的日志，如何重新写到日志中"><a href="#上一次没写完的日志，如何重新写到日志中" class="headerlink" title="上一次没写完的日志，如何重新写到日志中"></a>上一次没写完的日志，如何重新写到日志中</h3><p>在日志模块初始化会执行如下的代码，sg_log_buff为与mmap文件映射的逻辑内存，这里会主动调用Flush，把mmap文件中的数据（即上一次没写到日志文件中的日志）fluse到buffer中，并调用__log2file写到日志文件中。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">char</span> mmap_file_path[<span class="number">512</span>] = &#123;<span class="number">0</span>&#125;;</div><div class="line"><span class="built_in">snprintf</span>(mmap_file_path, <span class="keyword">sizeof</span>(mmap_file_path), <span class="string">"%s/%s.mmap2"</span>, sg_cache_logdir.empty()?_dir:sg_cache_logdir.c_str(), _nameprefix);</div><div class="line"></div><div class="line">    <span class="keyword">bool</span> use_mmap = <span class="literal">false</span>;</div><div class="line">    <span class="keyword">if</span> (OpenMmapFile(mmap_file_path, kBufferBlockLength, sg_mmmap_file))  &#123;</div><div class="line">        sg_log_buff = <span class="keyword">new</span> LogBuffer(sg_mmmap_file.data(), kBufferBlockLength, <span class="literal">true</span>);</div><div class="line">        use_mmap = <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line">    AutoBuffer buffer;</div><div class="line">    sg_log_buff-&gt;Flush(buffer); <span class="comment">// 把mmap文件中日志信息flush到内存中，下面调用__log2file写到文件中。</span></div><div class="line">    <span class="keyword">if</span> (buffer.Ptr()) &#123;</div><div class="line">        __writetips2file(<span class="string">"~~~~~ begin of mmap ~~~~~\n"</span>);</div><div class="line">        __log2file(buffer.Ptr(), buffer.Length());</div><div class="line">        __writetips2file(<span class="string">"~~~~~ end of mmap ~~~~~%s\n"</span>, mark_info);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<hr>
<h2 id="修改xlog默认的输出到文件的策略"><a href="#修改xlog默认的输出到文件的策略" class="headerlink" title="修改xlog默认的输出到文件的策略"></a>修改xlog默认的输出到文件的策略</h2><h3 id="xlog默认的策略"><a href="#xlog默认的策略" class="headerlink" title="xlog默认的策略"></a>xlog默认的策略</h3><p>每次启动时会删除过期文件，只保留十天内的日志文件(该值定义在appender.cc中的 kMaxLogAliveTime )，所以给 Xlog 的目录请使用单独目录，防止误删其他文件。目前不会根据文件大小进行清理。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> __del_timeout_file(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; _log_path) &#123;</div><div class="line">    <span class="keyword">time_t</span> now_time = time(<span class="literal">NULL</span>);</div><div class="line">    </div><div class="line">    boost::filesystem::<span class="function">path <span class="title">path</span><span class="params">(_log_path)</span></span>;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (boost::filesystem::exists(path) &amp;&amp; boost::filesystem::is_directory(path))&#123;</div><div class="line">        boost::filesystem::directory_iterator end_iter;</div><div class="line">        <span class="keyword">for</span> (boost::filesystem::directory_iterator iter(path); iter != end_iter; ++iter) &#123;</div><div class="line">            <span class="keyword">time_t</span> fileModifyTime = boost::filesystem::last_write_time(iter-&gt;path());</div><div class="line">            </div><div class="line">            <span class="keyword">if</span> (now_time &gt; fileModifyTime &amp;&amp; now_time - fileModifyTime &gt; kMaxLogAliveTime) &#123;</div><div class="line">                <span class="keyword">if</span> (boost::filesystem::is_regular_file(iter-&gt;status())) &#123;</div><div class="line">                    boost::filesystem::remove(iter-&gt;path());</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (boost::filesystem::is_directory(iter-&gt;status())) &#123;</div><div class="line">                    __del_files(iter-&gt;path().<span class="built_in">string</span>());</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>日志文件是按天命名的，每天产生一个日志文件。<br>在<code>__openlogfile</code>、<code>__log2file</code>中会调用。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> __make_logfilename(<span class="keyword">const</span> timeval&amp; _tv, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; _logdir, <span class="keyword">const</span> <span class="keyword">char</span>* _prefix, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; _fileext, <span class="keyword">char</span>* _filepath, <span class="keyword">unsigned</span> <span class="keyword">int</span> _len) &#123;</div><div class="line">    <span class="keyword">time_t</span> sec = _tv.tv_sec;</div><div class="line">    tm tcur = *localtime((<span class="keyword">const</span> <span class="keyword">time_t</span>*)&amp;sec);</div><div class="line"></div><div class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> logfilepath = _logdir;</div><div class="line">    logfilepath += <span class="string">"/"</span>;</div><div class="line">    logfilepath += _prefix;</div><div class="line">    <span class="keyword">char</span> temp [<span class="number">64</span>] = &#123;<span class="number">0</span>&#125;;</div><div class="line">    <span class="built_in">snprintf</span>(temp, <span class="number">64</span>, <span class="string">"_%d%02d%02d"</span>, <span class="number">1900</span> + tcur.tm_year, <span class="number">1</span> + tcur.tm_mon, tcur.tm_mday);</div><div class="line">    logfilepath += temp;</div><div class="line">    logfilepath += <span class="string">"."</span>;</div><div class="line">    logfilepath += _fileext;</div><div class="line">    <span class="built_in">strncpy</span>(_filepath, logfilepath.c_str(), _len - <span class="number">1</span>);</div><div class="line">    _filepath[_len - <span class="number">1</span>] = <span class="string">'\0'</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>比如在2017年01月10号的日志会写到LOG_20170110.log文件中，到2017年01月11号时，日志写到LOG_20170111.log，依次类推。过期的日志文件会在日志模块初始化时被清理掉。</p>
<h3 id="改写输出到文件的策略"><a href="#改写输出到文件的策略" class="headerlink" title="改写输出到文件的策略"></a>改写输出到文件的策略</h3><p>xlog输出的文件的逻辑都在<code>appender.cc</code>中实现，可以修改这里的代码实现一套自己的策略。<br>比如想要控制日志文件的大小，即Rotating file based on size的策略。<br>这里的实现方案并不支持cachedir。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">bool</span> __writefile(<span class="keyword">const</span> <span class="keyword">void</span>* _data, <span class="keyword">size_t</span> _len) &#123;</div><div class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == sg_logfile) &#123;</div><div class="line">        assert(<span class="literal">false</span>);</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">long</span> before_len = ftell(sg_logfile);</div><div class="line">    <span class="keyword">if</span> (before_len &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 如果发生了__roate，需要reopen sg_logfile</span></div><div class="line">    <span class="keyword">if</span>(before_len+_len &gt; sg_max_size)&#123;</div><div class="line">        <span class="keyword">if</span>(!__roate())&#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (<span class="number">1</span> != fwrite(_data, _len, <span class="number">1</span>, sg_logfile)) &#123;</div><div class="line">        <span class="keyword">int</span> err = ferror(sg_logfile);</div><div class="line"></div><div class="line">        __writetips2console(<span class="string">"write file error:%d"</span>, err);</div><div class="line"></div><div class="line"></div><div class="line">        ftruncate(fileno(sg_logfile), before_len);</div><div class="line">        fseek(sg_logfile, <span class="number">0</span>, SEEK_END);</div><div class="line"></div><div class="line">        <span class="keyword">char</span> err_log[<span class="number">256</span>] = &#123;<span class="number">0</span>&#125;;</div><div class="line">        <span class="built_in">snprintf</span>(err_log, <span class="keyword">sizeof</span>(err_log), <span class="string">"\nwrite file error:%d\n"</span>, err);</div><div class="line"></div><div class="line">        <span class="keyword">char</span> tmp[<span class="number">256</span>] = &#123;<span class="number">0</span>&#125;;</div><div class="line">        <span class="keyword">size_t</span> len = <span class="keyword">sizeof</span>(tmp);</div><div class="line">        LogBuffer::Write(err_log, strnlen(err_log, <span class="keyword">sizeof</span>(err_log)), tmp, len);</div><div class="line"></div><div class="line">        fwrite(tmp, len, <span class="number">1</span>, sg_logfile);</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">NumberToString</span> <span class="params">( T Number )</span></span></div><div class="line">&#123;</div><div class="line">     <span class="built_in">std</span>::<span class="built_in">ostringstream</span> ss;</div><div class="line">     ss &lt;&lt; Number;</div><div class="line">     <span class="keyword">return</span> ss.str();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">string</span> __calc_filename(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; _logdir, <span class="keyword">const</span> <span class="keyword">char</span>* _prefix, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; _fileext,<span class="keyword">unsigned</span> <span class="keyword">int</span> index)&#123;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> logfilepath = _logdir;</div><div class="line">    logfilepath += <span class="string">"/"</span>;</div><div class="line">    logfilepath += _prefix;</div><div class="line">    <span class="keyword">if</span>(index)&#123;</div><div class="line">        logfilepath += <span class="string">"."</span>;</div><div class="line">        logfilepath += NumberToString(index);</div><div class="line">    &#125;</div><div class="line">    logfilepath += <span class="string">"."</span>;</div><div class="line">    logfilepath += _fileext;</div><div class="line">    <span class="keyword">return</span> logfilepath;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">// Rotate files:</span></div><div class="line">    <span class="comment">// log.txt -&gt; log.1.txt</span></div><div class="line">    <span class="comment">// log.1.txt -&gt; log2.txt</span></div><div class="line">    <span class="comment">// log.2.txt -&gt; log3.txt</span></div><div class="line">    <span class="comment">// log.3.txt -&gt; delete</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">bool</span> __roate()&#123;</div><div class="line">    <span class="keyword">if</span>(sg_logfilename.empty() || sg_logdir.empty() || sg_logfileprefix.empty())&#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    fclose(sg_logfile);</div><div class="line">    sg_logfile = <span class="literal">NULL</span>;</div><div class="line"></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i = sg_max_files; i &gt; <span class="number">0</span>; --i)&#123;</div><div class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> src = __calc_filename(sg_logdir,sg_logfileprefix.c_str(),LOG_EXT,i<span class="number">-1</span>);</div><div class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> target = __calc_filename(sg_logdir,sg_logfileprefix.c_str(),LOG_EXT,i);</div><div class="line">        boost::filesystem::<span class="function">path <span class="title">src_path</span><span class="params">(src)</span></span>;</div><div class="line">        boost::filesystem::<span class="function">path <span class="title">target_path</span><span class="params">(target)</span></span>;</div><div class="line"></div><div class="line">        <span class="keyword">if</span>(boost::filesystem::exists(target_path))&#123;</div><div class="line">            boost::filesystem::remove(target_path);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(boost::filesystem::exists(src_path))&#123;</div><div class="line">            boost::filesystem::rename(src_path,target_path);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//reopen</span></div><div class="line">    sg_logfile = fopen(sg_logfilename.c_str(), <span class="string">"wb"</span>);</div><div class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == sg_logfile) &#123;</div><div class="line">        __writetips2console(<span class="string">"open file error:%d %s, path:%s"</span>, errno, strerror(errno), sg_logfilename.c_str());</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">bool</span> __openlogfile(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; _log_dir)&#123;</div><div class="line">    <span class="keyword">if</span> (sg_logdir.empty()) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line"></div><div class="line">    <span class="comment">// 如果sg_logfile已经打开了，则直接返回。</span></div><div class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> != sg_logfile) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    sg_current_dir = _log_dir;</div><div class="line">    sg_logfilename = __calc_filename(_log_dir, sg_logfileprefix.c_str(), LOG_EXT,<span class="number">0</span>);</div><div class="line"></div><div class="line">    sg_logfile = fopen(sg_logfilename.c_str(), <span class="string">"ab"</span>);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == sg_logfile) &#123;</div><div class="line">        __writetips2console(<span class="string">"open file error:%d %s, path:%s"</span>, errno, strerror(errno), sg_logfilename.c_str());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="literal">NULL</span> != sg_logfile;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> __log2file(<span class="keyword">const</span> <span class="keyword">void</span>* _data, <span class="keyword">size_t</span> _len) &#123;</div><div class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == _data || <span class="number">0</span> == _len || sg_logdir.empty()) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">	    <span class="function">ScopedLock <span class="title">lock_file</span><span class="params">(sg_mutex_log_file)</span></span>;</div><div class="line">        <span class="keyword">if</span> (__openlogfile(sg_logdir)) &#123;</div><div class="line">            __writefile(_data, _len);</div><div class="line">            <span class="keyword">if</span> (kAppednerAsync == sg_mode) &#123;</div><div class="line">                __closelogfile();</div><div class="line">            &#125;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>代码详见：<a href="https://github.com/FelixZhang00/xlog-rotating-base-size" target="_blank" rel="external">github</a></p>
<hr>
<h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><p><a href="http://dev.qq.com/topic/581c2c46bef1702a2db3ae53" target="_blank" rel="external">http://dev.qq.com/topic/581c2c46bef1702a2db3ae53</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/Tencent/mars&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;mars&lt;/a&gt; 是微信最近开源的终端基础组件，是一个使用 C++ 编写的基础组件。&lt;br&gt;xlog是其中一个可单独使用的高性能
    
    </summary>
    
    
      <category term="c++ 开源代码" scheme="http://felixzhang00.github.io/tags/c-%E5%BC%80%E6%BA%90%E4%BB%A3%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>spdlog源码学习</title>
    <link href="http://felixzhang00.github.io/2017/01/12/spdlog%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
    <id>http://felixzhang00.github.io/2017/01/12/spdlog源码学习/</id>
    <published>2017-01-12T09:35:42.000Z</published>
    <updated>2017-01-12T09:40:41.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/gabime/spdlog" target="_blank" rel="external">spdlog</a>是一个用c++11实现的高性能日志库。<br>接入方便，功能丰富，代码可读性较高。</p>
<hr>
<h2 id="Features"><a href="#Features" class="headerlink" title="Features"></a>Features</h2><ul>
<li>Very fast - performance is the primary goal </li>
<li>Headers only, just copy and use.</li>
<li>Feature rich  using the excellent <a href="https://github.com/fmtlib/fmt" target="_blank" rel="external">fmt</a> library.</li>
<li>Extremely fast asynchronous mode (optional) - using lockfree queues and other tricks to reach millions of calls/sec.</li>
<li><a href="https://github.com/gabime/spdlog/wiki/3.-Custom-formatting" target="_blank" rel="external">Custom</a> formatting.</li>
<li>Multi/Single threaded loggers.</li>
<li>Various log targets:<ul>
<li>Rotating log files.</li>
<li>Daily log files.</li>
<li>Console logging (colors supported).</li>
<li>syslog.</li>
<li>Windows debugger </li>
<li>Easily extendable with custom log targets  (just implement a single function in the sink interface).</li>
</ul>
</li>
<li>Severity based filtering - threshold levels can be modified in runtime as well as in compile time.</li>
</ul>
<hr>
<h2 id="核心设计"><a href="#核心设计" class="headerlink" title="核心设计"></a>核心设计</h2><p>spdlog中定义了一系列Sink类，作为实际上把log输出到指定目标的对象，每一个Sink唯一对应一个log的输出目标（如console、文件、db）.<br>每一个logger包含一个sink列表，每当上层调用logger的log方法写日志时，logger就会调用sink列表中的每一个sink的 <code>sink(log_msg)</code> 函数，真正往目标中写日志。</p>
<h3 id="实现Rotating-file写日志"><a href="#实现Rotating-file写日志" class="headerlink" title="实现Rotating file写日志"></a>实现Rotating file写日志</h3><p>当前正在写日志的文件名一直都是log.txt。<br>当log.txt写不下时，把它重命名为log1.txt,再重新打开一个log.txt文件。<br>多个文件循环也依次类推。</p>
<pre><code>// Rotate files:
// log.txt -&gt; log.1.txt
// log.1.txt -&gt; log2.txt
// log.2.txt -&gt; log3.txt
// log.3.txt -&gt; delete
</code></pre><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * Rotating file sink based on size</div><div class="line"> */</div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Mutex&gt;</div><div class="line"><span class="keyword">class</span> rotating_file_sink : <span class="keyword">public</span> base_sink &lt; Mutex &gt;</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    rotating_file_sink(<span class="keyword">const</span> <span class="keyword">filename_t</span> &amp;base_filename, <span class="keyword">const</span> <span class="keyword">filename_t</span> &amp;extension,</div><div class="line">                       <span class="built_in">std</span>::<span class="keyword">size_t</span> max_size, <span class="built_in">std</span>::<span class="keyword">size_t</span> max_files                       ) :</div><div class="line">    &#123;</div><div class="line">        _file_helper.open(calc_filename(_base_filename, <span class="number">0</span>, _extension));</div><div class="line">        _current_size = _file_helper.size(); <span class="comment">//expensive. called only once</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="keyword">protected</span>:</div><div class="line">    <span class="keyword">void</span> _sink_it(<span class="keyword">const</span> details::log_msg&amp; msg) override</div><div class="line">    &#123;</div><div class="line">        _current_size += msg.formatted.size();</div><div class="line">        <span class="keyword">if</span> (_current_size &gt; _max_size)</div><div class="line">        &#123;</div><div class="line">            _rotate();</div><div class="line">            _current_size = msg.formatted.size();</div><div class="line">        &#125;</div><div class="line">        _file_helper.write(msg);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="function"><span class="keyword">static</span> filename_t <span class="title">calc_filename</span><span class="params">(<span class="keyword">const</span> <span class="keyword">filename_t</span>&amp; filename, <span class="built_in">std</span>::<span class="keyword">size_t</span> index, <span class="keyword">const</span> <span class="keyword">filename_t</span>&amp; extension)</span></span></div><div class="line">    &#123;</div><div class="line">    <span class="comment">//...</span></div><div class="line">        <span class="keyword">return</span> w.str();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">void</span> _rotate()</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">using</span> details::os::filename_to_str;</div><div class="line">        _file_helper.close();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = _max_files; i &gt; <span class="number">0</span>; --i)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">filename_t</span> src = calc_filename(_base_filename, i - <span class="number">1</span>, _extension);</div><div class="line">            <span class="keyword">filename_t</span> target = calc_filename(_base_filename, i, _extension);</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (details::file_helper::file_exists(target))</div><div class="line">            &#123;</div><div class="line">                details::os::remove(target);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (details::file_helper::file_exists(src) &amp;&amp; details::os::rename(src, target))</div><div class="line">            &#123;</div><div class="line">				<span class="comment">//...</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        _file_helper.reopen(<span class="literal">true</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">filename_t</span> _base_filename;</div><div class="line">    <span class="keyword">filename_t</span> _extension;</div><div class="line">    <span class="built_in">std</span>::<span class="keyword">size_t</span> _max_size;</div><div class="line">    <span class="built_in">std</span>::<span class="keyword">size_t</span> _max_files;</div><div class="line">    <span class="built_in">std</span>::<span class="keyword">size_t</span> _current_size;</div><div class="line">    details::file_helper _file_helper;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<hr>
<h3 id="实现异步写日志"><a href="#实现异步写日志" class="headerlink" title="实现异步写日志"></a>实现异步写日志</h3><p>所有异步写日志的请求都会被push到一个固定大小的队列中。<br>有一个工作线程会不停的从队列中pop一条日志消息，并最终写到日志中。</p>
<p>调用方：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">async_example</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">size_t</span> q_size = <span class="number">4096</span>; <span class="comment">//queue size must be power of 2</span></div><div class="line">    spdlog::set_async_mode(q_size);</div><div class="line">    <span class="keyword">auto</span> async_file = spd::daily_logger_st(<span class="string">"async_file_logger"</span>, <span class="string">"logs/async_log.txt"</span>);</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i)</div><div class="line">        async_file-&gt;info(<span class="string">"Async message #&#123;&#125;"</span>, i);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>具体实现：<br>开启一个工作线程，在async_log初始时就开始工作了。并且在析构是被关闭<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Async Logger implementation</span></div><div class="line"><span class="comment">// Use an async_sink (queue per logger) to perform the logging in a worker thread</span></div><div class="line"></div><div class="line"><span class="comment">//一个工作线程，在async_log初始时就开始工作了。并且在析构是被关闭</span></div><div class="line"><span class="comment">// worker thread</span></div><div class="line"><span class="built_in">std</span>::thread _worker_thread;</div><div class="line">_worker_thread(&amp;async_log_helper::worker_loop, <span class="keyword">this</span>)</div><div class="line"><span class="keyword">inline</span> <span class="keyword">void</span> spdlog::details::async_log_helper::worker_loop()</div><div class="line">&#123;</div><div class="line">    <span class="keyword">try</span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> (_worker_warmup_cb) _worker_warmup_cb();</div><div class="line">        <span class="keyword">auto</span> last_pop = details::os::now();</div><div class="line">        <span class="keyword">auto</span> last_flush = last_pop;</div><div class="line">        <span class="keyword">while</span>(process_next_msg(last_pop, last_flush));</div><div class="line">        <span class="keyword">if</span> (_worker_teardown_cb) _worker_teardown_cb();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">catch</span> (<span class="keyword">const</span> <span class="built_in">std</span>::exception &amp;ex)</div><div class="line">    &#123;</div><div class="line">        _err_handler(ex.what());</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">catch</span> (...)</div><div class="line">    &#123;</div><div class="line">        _err_handler(<span class="string">"Unknown exception"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// Send to the worker thread termination message(level=off)</span></div><div class="line"><span class="comment">// and wait for it to finish gracefully</span></div><div class="line"><span class="keyword">inline</span> spdlog::details::async_log_helper::~async_log_helper()</div><div class="line">&#123;</div><div class="line">    <span class="keyword">try</span></div><div class="line">    &#123;</div><div class="line">        push_msg(async_msg(async_msg_type::terminate));</div><div class="line">        _worker_thread.join();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">catch</span> (...) <span class="comment">// don't crash in destructor</span></div><div class="line">    &#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>从队列中取消息，如果是写日志的消息，则调用sink写日志。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//从队列中取消息，如果是写日志的消息，则调用sink写日志。</span></div><div class="line"><span class="comment">// process next message in the queue</span></div><div class="line"><span class="comment">// return true if this thread should still be active (while no terminate msg was received)</span></div><div class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> spdlog::details::async_log_helper::process_next_msg(log_clock::time_point&amp; last_pop, log_clock::time_point&amp; last_flush)</div><div class="line">&#123;</div><div class="line">    async_msg incoming_async_msg;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (_q.dequeue(incoming_async_msg))</div><div class="line">    &#123;</div><div class="line">        last_pop = details::os::now();</div><div class="line">        <span class="keyword">switch</span> (incoming_async_msg.msg_type)</div><div class="line">        &#123;</div><div class="line">        <span class="keyword">case</span> async_msg_type::flush:</div><div class="line">            _flush_requested = <span class="literal">true</span>;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line"></div><div class="line">        <span class="keyword">case</span> async_msg_type::terminate:</div><div class="line">            _flush_requested = <span class="literal">true</span>;</div><div class="line">            _terminate_requested = <span class="literal">true</span>;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line"></div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            log_msg incoming_log_msg;</div><div class="line">            incoming_async_msg.fill_log_msg(incoming_log_msg);</div><div class="line">            _formatter-&gt;format(incoming_log_msg);</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;s : _sinks)</div><div class="line">            &#123;</div><div class="line">                <span class="keyword">if</span>(s-&gt;should_log( incoming_log_msg.level))</div><div class="line">                &#123;</div><div class="line">                    s-&gt;<span class="built_in">log</span>(incoming_log_msg);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Handle empty queue..</span></div><div class="line">    <span class="comment">// This is the only place where the queue can terminate or flush to avoid losing messages already in the queue</span></div><div class="line">    <span class="keyword">else</span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">auto</span> now = details::os::now();</div><div class="line">        handle_flush_interval(now, last_flush);</div><div class="line">        sleep_or_yield(now, last_pop);</div><div class="line">        <span class="keyword">return</span> !_terminate_requested;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>调用写日志，往队列里塞一条写日志消息。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">inline</span> <span class="keyword">void</span> spdlog::logger::<span class="built_in">log</span>(level::level_enum lvl, <span class="keyword">const</span> T&amp; msg)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (!should_log(lvl)) <span class="keyword">return</span>;</div><div class="line">    <span class="keyword">try</span></div><div class="line">    &#123;</div><div class="line">        details::<span class="function">log_msg <span class="title">log_msg</span><span class="params">(&amp;_name, lvl)</span></span>;</div><div class="line">        log_msg.raw &lt;&lt; msg;</div><div class="line">        _sink_it(log_msg);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">catch</span> (<span class="keyword">const</span> <span class="built_in">std</span>::exception &amp;ex)</div><div class="line">    &#123;</div><div class="line">        _err_handler(ex.what());</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">catch</span> (...)</div><div class="line">    &#123;</div><div class="line">        _err_handler(<span class="string">"Unknown exception"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">inline</span> <span class="keyword">void</span> spdlog::async_logger::_sink_it(details::log_msg&amp; msg)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">try</span></div><div class="line">    &#123;</div><div class="line">        _async_log_helper-&gt;<span class="built_in">log</span>(msg);</div><div class="line">        <span class="keyword">if</span> (_should_flush_on(msg))</div><div class="line">            _async_log_helper-&gt;flush(<span class="literal">false</span>); <span class="comment">// do async flush</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">catch</span> (<span class="keyword">const</span> <span class="built_in">std</span>::exception &amp;ex)</div><div class="line">    &#123;</div><div class="line">        _err_handler(ex.what());</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">catch</span> (...)</div><div class="line">    &#123;</div><div class="line">        _err_handler(<span class="string">"Unknown exception"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 往队列里塞一条日志进去，准备被写</span></div><div class="line"><span class="comment">//Try to push and block until succeeded (if the policy is not to discard when the queue is full)</span></div><div class="line"><span class="keyword">inline</span> <span class="keyword">void</span> spdlog::details::async_log_helper::<span class="built_in">log</span>(<span class="keyword">const</span> details::log_msg&amp; msg)</div><div class="line">&#123;</div><div class="line">    push_msg(async_msg(msg));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">inline</span> <span class="keyword">void</span> spdlog::details::async_log_helper::push_msg(details::async_log_helper::async_msg&amp;&amp; new_msg)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (!_q.enqueue(<span class="built_in">std</span>::move(new_msg)) &amp;&amp; _overflow_policy != async_overflow_policy::discard_log_msg)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">auto</span> last_op_time = details::os::now();</div><div class="line">        <span class="keyword">auto</span> now = last_op_time;</div><div class="line">        <span class="keyword">do</span></div><div class="line">        &#123;</div><div class="line">            now = details::os::now();</div><div class="line">            sleep_or_yield(now, last_op_time);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">while</span> (!_q.enqueue(<span class="built_in">std</span>::move(new_msg)));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>根据时间间隔让线程等待<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// spin, yield or sleep. use the time passed since last message as a hint</span></div><div class="line"><span class="keyword">inline</span> <span class="keyword">void</span> spdlog::details::async_log_helper::sleep_or_yield(<span class="keyword">const</span> spdlog::log_clock::time_point&amp; now, <span class="keyword">const</span> spdlog::log_clock::time_point&amp; last_op_time)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>::this_thread;</div><div class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::chrono::milliseconds;</div><div class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::chrono::microseconds;</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> time_since_op = now - last_op_time;</div><div class="line"></div><div class="line">    <span class="comment">// spin upto 50 micros</span></div><div class="line">    <span class="keyword">if</span> (time_since_op &lt;= microseconds(<span class="number">50</span>))</div><div class="line">        <span class="keyword">return</span>;</div><div class="line"></div><div class="line">    <span class="comment">// yield upto 150 micros</span></div><div class="line">    <span class="keyword">if</span> (time_since_op &lt;= microseconds(<span class="number">100</span>))</div><div class="line">        <span class="keyword">return</span> <span class="built_in">std</span>::this_thread::yield();</div><div class="line"></div><div class="line">    <span class="comment">// sleep for 20 ms upto 200 ms</span></div><div class="line">    <span class="keyword">if</span> (time_since_op &lt;= milliseconds(<span class="number">200</span>))</div><div class="line">        <span class="keyword">return</span> sleep_for(milliseconds(<span class="number">20</span>));</div><div class="line"></div><div class="line">    <span class="comment">// sleep for 200 ms</span></div><div class="line">    <span class="keyword">return</span> sleep_for(milliseconds(<span class="number">200</span>));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/gabime/spdlog&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;spdlog&lt;/a&gt;是一个用c++11实现的高性能日志库。&lt;br&gt;接入方便，功能丰富，代码可读性较高。&lt;/p&gt;
&lt;hr&gt;
&lt;h
    
    </summary>
    
    
      <category term="c++ 开源代码" scheme="http://felixzhang00.github.io/tags/c-%E5%BC%80%E6%BA%90%E4%BB%A3%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Python断点调试</title>
    <link href="http://felixzhang00.github.io/2017/01/07/Python%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95/"/>
    <id>http://felixzhang00.github.io/2017/01/07/Python断点调试/</id>
    <published>2017-01-07T14:31:10.000Z</published>
    <updated>2017-01-07T14:34:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>很多项目是用python写构建脚本的，比如微信最近开源的终端跨平台组件 <a href="https://github.com/Tencent/mars" target="_blank" rel="external">Mars</a><br>本文将以mars为例简单介绍下如何用<a href="https://www.jetbrains.com/pycharm/" target="_blank" rel="external">PyCharm</a>对python进行断点调试。</p>
<hr>
<h3 id="导入代码"><a href="#导入代码" class="headerlink" title="导入代码"></a>导入代码</h3><p>open整个mars项目，切换合适的python版本，mars需要python2.7版本。<br><img src="http://ww1.sinaimg.cn/large/8b331ee1gw1fbifkuh496j20h81f0q9j.jpg" alt=""><br><img src="http://ww2.sinaimg.cn/large/8b331ee1gw1fbifke5anpj20xm0du0xi.jpg" alt=""></p>
<h3 id="打断点"><a href="#打断点" class="headerlink" title="打断点"></a>打断点</h3><p><img src="http://ww3.sinaimg.cn/large/8b331ee1gw1fbifnm18q9j20gk04gt94.jpg" alt=""></p>
<h3 id="Debug-it"><a href="#Debug-it" class="headerlink" title="Debug it"></a>Debug it</h3><p><img src="http://ww1.sinaimg.cn/large/8b331ee1gw1fbifo65ncyj20po0v6wm7.jpg" alt=""></p>
<p>当代码中需要input时，切换到Console窗口输入<br><img src="http://ww3.sinaimg.cn/large/8b331ee1gw1fbifq7bsxlj20nm0e4jvb.jpg" alt=""></p>
<p><img src="http://ww3.sinaimg.cn/large/8b331ee1gw1fbifqp5rcaj211q0lutf5.jpg" alt=""></p>
<p>用PyCharm调试跟Android Studio一样，毕竟都是一家公司的产品。</p>
<hr>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;很多项目是用python写构建脚本的，比如微信最近开源的终端跨平台组件 &lt;a href=&quot;https://github.com/Tencent/mars&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Mars&lt;/a&gt;&lt;br&gt;本文将以mars为例简单介绍下如
    
    </summary>
    
    
      <category term="工具 python" scheme="http://felixzhang00.github.io/tags/%E5%B7%A5%E5%85%B7-python/"/>
    
  </entry>
  
  <entry>
    <title>快速清除Android项目中的无用资源</title>
    <link href="http://felixzhang00.github.io/2017/01/05/%E6%B8%85%E9%99%A4Android%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E6%97%A0%E7%94%A8%E8%B5%84%E6%BA%90/"/>
    <id>http://felixzhang00.github.io/2017/01/05/清除Android项目中的无用资源/</id>
    <published>2017-01-05T14:45:58.000Z</published>
    <updated>2019-10-02T12:11:16.566Z</updated>
    
    <content type="html"><![CDATA[<p>随着业务的野蛮生长，快速迭代，然而应用apk的包体积也越来越大，作为一款有追求的产品，包体积的优化势在必行。apk包体积中有一部分属于经年累月遗留下来的无用资源，本文将介绍一种快速清空Android项目中无用资源的方法。</p>
<h2 id="检测无用资源"><a href="#检测无用资源" class="headerlink" title="检测无用资源"></a>检测无用资源</h2><p>在接入微信的android安装包分析检测工具Matrix-ApkChecker后，我们发现检测结果中无用资源unused-resources这一项多达上千个。</p>
<h2 id="批量删除"><a href="#批量删除" class="headerlink" title="批量删除"></a>批量删除</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;随着业务的野蛮生长，快速迭代，然而应用apk的包体积也越来越大，作为一款有追求的产品，包体积的优化势在必行。apk包体积中有一部分属于经年累月遗留下来的无用资源，本文将介绍一种快速清空Android项目中无用资源的方法。&lt;/p&gt;
&lt;h2 id=&quot;检测无用资源&quot;&gt;&lt;a hre
    
    </summary>
    
    
      <category term="工具" scheme="http://felixzhang00.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Stetho工具介绍</title>
    <link href="http://felixzhang00.github.io/2017/01/05/Stetho%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D/"/>
    <id>http://felixzhang00.github.io/2017/01/05/Stetho工具介绍/</id>
    <published>2017-01-05T14:45:58.000Z</published>
    <updated>2017-01-05T14:52:47.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://facebook.github.io/stetho/" target="_blank" rel="external">stetho</a>是Facebook推出的安卓APP网络诊断和数据监控的工具，接入方便，功能强大，是开发者必备的好工具。</p>
<p>主要功能包括：</p>
<ul>
<li>查看App的布局</li>
<li>网络请求抓包</li>
<li>数据库、sp文件查看</li>
<li>自定义dumpapp插件</li>
<li>对于JavaScript的支持</li>
</ul>
<p>无需root，只要能通过adb连接设备，操作方便。</p>
<h2 id="接入方法"><a href="#接入方法" class="headerlink" title="接入方法"></a>接入方法</h2><h3 id="gradle配置"><a href="#gradle配置" class="headerlink" title="gradle配置"></a>gradle配置</h3><p>因为目前我们的项目中已经集成了okhttp，只需要在build.gradle添加如下两行配置</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">dependencies &#123;</div><div class="line">   <span class="comment">//...</span></div><div class="line"></div><div class="line">   compile <span class="string">'com.facebook.stetho:stetho-js-rhino:1.3.1'</span></div><div class="line">   compile <span class="string">'com.facebook.stetho:stetho-okhttp3:1.4.2'</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>在Application类中完成初始化<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">MyApplicationCreate</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="comment">// ...</span></div><div class="line">     Stetho.initializeWithDefaults(mContext);</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<h2 id="使用功能"><a href="#使用功能" class="headerlink" title="使用功能"></a>使用功能</h2><ol>
<li>adb方式连接到设备</li>
<li>运行debug模式的app</li>
<li>在Chrome浏览器地址栏中输入chrome://inspect</li>
<li>选择需要inspect的应用进程<br><img src="http://ww1.sinaimg.cn/large/8b331ee1gw1fbg4wwn5ftj21aw0qo7az.jpg" alt=""></li>
</ol>
<h3 id="查看App的布局"><a href="#查看App的布局" class="headerlink" title="查看App的布局"></a>查看App的布局</h3><p><img src="http://ww1.sinaimg.cn/large/8b331ee1gw1fbfhku1ltsj21kw0s5tt8.jpg" alt=""></p>
<h3 id="网络诊断"><a href="#网络诊断" class="headerlink" title="网络诊断"></a>网络诊断</h3><p>给OkHttpClient添加拦截器。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> OkHttpClient.Builder()</div><div class="line">    .addNetworkInterceptor(<span class="keyword">new</span> StethoInterceptor())</div><div class="line">    .build();</div></pre></td></tr></table></figure></p>
<p>主要功能有包括下载图片的预览，JSON数据查看，网络请求内容和返回内容<br><img src="http://ww3.sinaimg.cn/large/8b331ee1gw1fbfhpn53jjj21kw0rjk3j.jpg" alt=""></p>
<h3 id="数据库、sp文件查看"><a href="#数据库、sp文件查看" class="headerlink" title="数据库、sp文件查看"></a>数据库、sp文件查看</h3><p><img src="http://ww4.sinaimg.cn/large/8b331ee1gw1fbfhrmo7blj21kw0rvgx0.jpg" alt=""></p>
<p><img src="http://ww3.sinaimg.cn/large/8b331ee1gw1fbfhsqtl35j21kw0rq7fi.jpg" alt=""></p>
<h3 id="自定义dumpapp插件"><a href="#自定义dumpapp插件" class="headerlink" title="自定义dumpapp插件"></a>自定义dumpapp插件</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">Stetho.initialize(Stetho.newInitializerBuilder(context)</div><div class="line">        .enableDumpapp(<span class="keyword">new</span> DumperPluginsProvider() &#123;</div><div class="line">          <span class="meta">@Override</span></div><div class="line">          <span class="function"><span class="keyword">public</span> Iterable&lt;DumperPlugin&gt; <span class="title">get</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Stetho.DefaultDumperPluginsBuilder(context)</div><div class="line">                .provide(<span class="keyword">new</span> HelloWorldDumperPlugin())</div><div class="line">                .provide(<span class="keyword">new</span> APODDumperPlugin(context.getContentResolver()))</div><div class="line">                .finish();</div><div class="line">          &#125;</div><div class="line">        &#125;)</div><div class="line">        .enableWebKitInspector(<span class="keyword">new</span> ExtInspectorModulesProvider(context))</div><div class="line">        .build());</div></pre></td></tr></table></figure>
<p>其中HelloWorldDumperPlugin和APODDumperPlugin是自定义的插件，具体内容可以参考<a href="https://github.com/facebook/stetho/tree/master/stetho-sample" target="_blank" rel="external">Stetho提供的sample程序</a><br>运行dumpapp脚本后以达到与app交互通信的效果。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ ./dumpapp <span class="_">-l</span></div><div class="line">apod</div><div class="line">crash</div><div class="line">files</div><div class="line">hello</div><div class="line">hprof</div><div class="line">prefs</div></pre></td></tr></table></figure></p>
<h4 id="原理简介"><a href="#原理简介" class="headerlink" title="原理简介"></a>原理简介</h4><p>其中dumpapp是一个python脚本，通信的方式使用的是android提供的<a href="https://android.googlesource.com/platform/system/core/+/master/adb/protocol.txt" target="_blank" rel="external">smartsocket接口</a><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">--- smartsockets -------------------------------------------------------</div><div class="line">Port <span class="number">5037</span> is used <span class="keyword">for</span> smart sockets which allow a client on the host</div><div class="line">side to request access to a service <span class="keyword">in</span> the host adb daemon or <span class="keyword">in</span> the</div><div class="line">remote (device) daemon.  The service is requested by ascii name,</div><div class="line">preceeded by a <span class="number">4</span> digit hex length.  Upon successful connection an</div><div class="line"><span class="string">"OKAY"</span> response is sent, otherwise a <span class="string">"FAIL"</span> message is returned.  Once</div><div class="line">connected the client is talking to that (remote or local) service.</div><div class="line">client: &lt;hex4&gt; &lt;service-name&gt;</div><div class="line">server: "OKAY"</div><div class="line">client: &lt;hex4&gt; &lt;service-name&gt;</div><div class="line">server: "FAIL" &lt;hex4&gt; &lt;reason&gt;</div></pre></td></tr></table></figure></p>
<p>使用PyCharm<a href="http://stackoverflow.com/questions/27952331/debugging-with-pycharm-terminal-arguments" target="_blank" rel="external">对Python进行断点调试</a>：<br><img src="http://ww3.sinaimg.cn/large/8b331ee1gw1fbfian208yj21kw0arwia.jpg" alt=""><br>这段脚本的功能就是通过读取<code>/proc/net/unix</code>文件去找app设置的socket<br><img src="http://ww2.sinaimg.cn/large/8b331ee1gw1fbfid70oipj21gs044t9m.jpg" alt=""></p>
<ol>
<li>扫描android所有提供socket功能的设备，找到steho的devtools_remote</li>
<li>建立与第一步找到的进程socket，然后通过smartsocket进行通信。</li>
<li>设备上的app相当于一个服务器，脚本是客户端对它进行访问</li>
</ol>
<p>后缀为_devtools_remote的socket是android留给chrome的后门。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Note that _devtools_remote is a magic suffix understood by Chrome which //causes the discovery process to begin.</span></div></pre></td></tr></table></figure></p>
<p>详细内容可以看这篇<a href="https://developer.chrome.com/devtools/docs/remote-debugging-legacy" target="_blank" rel="external">官方文档</a><br>这篇文档提供的例子是在命令行中输入下面的命令，就能在电脑上看到手机chrome中的内容了：<br><code>adb forward tcp:9222 localabstract:chrome_devtools_remote</code></p>
<p><img src="http://ww2.sinaimg.cn/large/8b331ee1gw1fbfijp8jqfj21320lo0tp.jpg" alt=""></p>
<p>打开的chrome-devtool其实是一个websocket连接。<br><img src="http://ww4.sinaimg.cn/large/8b331ee1gw1fbfipebrd2j21kw069766.jpg" alt=""><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handlePageList</span><span class="params">(LightHttpResponse response)</span></span></div><div class="line">    <span class="keyword">throws</span> JSONException &#123;</div><div class="line">  <span class="keyword">if</span> (mPageListResponse == <span class="keyword">null</span>) &#123;</div><div class="line">    JSONArray reply = <span class="keyword">new</span> JSONArray();</div><div class="line">    JSONObject page = <span class="keyword">new</span> JSONObject();</div><div class="line">    page.put(<span class="string">"type"</span>, <span class="string">"app"</span>);</div><div class="line">    page.put(<span class="string">"title"</span>, makeTitle());</div><div class="line">    page.put(<span class="string">"id"</span>, PAGE_ID);</div><div class="line">    page.put(<span class="string">"description"</span>, <span class="string">""</span>);</div><div class="line"></div><div class="line">    page.put(<span class="string">"webSocketDebuggerUrl"</span>, <span class="string">"ws://"</span> + mInspectorPath);</div><div class="line">    Uri chromeFrontendUrl = <span class="keyword">new</span> Uri.Builder()</div><div class="line">        .scheme(<span class="string">"http"</span>)</div><div class="line">        .authority(<span class="string">"chrome-devtools-frontend.appspot.com"</span>)</div><div class="line">        .appendEncodedPath(<span class="string">"serve_rev"</span>)</div><div class="line">        .appendEncodedPath(WEBKIT_REV)</div><div class="line">        .appendEncodedPath(<span class="string">"devtools.html"</span>)</div><div class="line">        .appendQueryParameter(<span class="string">"ws"</span>, mInspectorPath)</div><div class="line">        .build();</div><div class="line">    page.put(<span class="string">"devtoolsFrontendUrl"</span>, chromeFrontendUrl.toString());</div><div class="line"></div><div class="line">    reply.put(page);</div><div class="line">    mPageListResponse = LightHttpBody.create(reply.toString(), <span class="string">"application/json"</span>);</div><div class="line">  &#125;</div><div class="line">  setSuccessfulResponse(response, mPageListResponse);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在android上的服务端socket写法,<br>详见LocalSocketServer类的listenOnAddress方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">listenOnAddress</span><span class="params">(String address)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">  mServerSocket = bindToSocket(address);</div><div class="line">  LogUtil.i(<span class="string">"Listening on @"</span> + address);</div><div class="line"></div><div class="line">  <span class="keyword">while</span> (!Thread.interrupted()) &#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      <span class="comment">// Use previously accepted socket the first time around, otherwise wait to accept another.</span></div><div class="line">      LocalSocket socket = mServerSocket.accept();</div><div class="line"></div><div class="line">      <span class="comment">// Start worker thread</span></div><div class="line">      Thread t = <span class="keyword">new</span> WorkerThread(socket, mSocketHandler);</div><div class="line">      t.setName(</div><div class="line">          WORKER_THREAD_NAME_PREFIX +</div><div class="line">          <span class="string">"-"</span> + mFriendlyName +</div><div class="line">          <span class="string">"-"</span> + mThreadId.incrementAndGet());</div><div class="line">      t.setDaemon(<span class="keyword">true</span>);</div><div class="line">      t.start();</div><div class="line">    &#125; <span class="keyword">catch</span> (SocketException se) &#123;</div><div class="line">      <span class="comment">// ignore exception if interrupting the thread</span></div><div class="line">      <span class="keyword">if</span> (Thread.interrupted()) &#123;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">      &#125;</div><div class="line">      LogUtil.w(se, <span class="string">"I/O error"</span>);</div><div class="line">    &#125; <span class="keyword">catch</span> (InterruptedIOException ex) &#123;</div><div class="line">      <span class="keyword">break</span>;</div><div class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">      LogUtil.w(e, <span class="string">"I/O error initialising connection thread"</span>);</div><div class="line">      <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  LogUtil.i(<span class="string">"Server shutdown on @"</span> + address);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="对于JavaScript的支持"><a href="#对于JavaScript的支持" class="headerlink" title="对于JavaScript的支持"></a>对于JavaScript的支持</h3><p>Chrome开发者工具原生支持JavaScript，所以Stetho也提供了JavaScript的支持。<br>通过在console中输入如下代码可以让设备app弹出一个toast<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">importPackage(android.widget);</div><div class="line">importPackage(android.os);</div><div class="line"><span class="keyword">var</span> handler = <span class="keyword">new</span> Handler(Looper.getMainLooper());</div><div class="line">handler.post(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; Toast.makeText(context, <span class="string">"Hello from JavaScript"</span>, Toast.LENGTH_LONG).show() &#125;);</div></pre></td></tr></table></figure></p>
<p><img src="http://ww3.sinaimg.cn/large/8b331ee1gw1fbfixpdt6hj21kw0rmgv8.jpg" alt=""><br>更多玩法见<a href="https://github.com/facebook/stetho/tree/master/stetho-js-rhino" target="_blank" rel="external">Rhino on Stetho
</a></p>
<hr>
<h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><p><a href="http://facebook.github.io/stetho/" target="_blank" rel="external">http://facebook.github.io/stetho/</a><br><a href="https://github.com/facebook/stetho/tree/master/stetho-js-rhino" target="_blank" rel="external">https://github.com/facebook/stetho/tree/master/stetho-js-rhino</a><br><a href="https://www.figotan.org/2016/04/18/using-stetho-to-diagnose-data-on-android/" target="_blank" rel="external">https://www.figotan.org/2016/04/18/using-stetho-to-diagnose-data-on-android/</a><br><a href="https://developer.chrome.com/devtools/docs/remote-debugging-legacy" target="_blank" rel="external">https://developer.chrome.com/devtools/docs/remote-debugging-legacy</a><br><a href="https://android.googlesource.com/platform/system/core/+/master/adb/protocol.txt" target="_blank" rel="external">https://android.googlesource.com/platform/system/core/+/master/adb/protocol.txt</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://facebook.github.io/stetho/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;stetho&lt;/a&gt;是Facebook推出的安卓APP网络诊断和数据监控的工具，接入方便，功能强大，是开发者必备的好工具。&lt;
    
    </summary>
    
    
      <category term="工具" scheme="http://felixzhang00.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>simple-mock-api</title>
    <link href="http://felixzhang00.github.io/2017/01/01/simple-mock-api/"/>
    <id>http://felixzhang00.github.io/2017/01/01/simple-mock-api/</id>
    <published>2017-01-01T01:58:49.000Z</published>
    <updated>2017-01-01T02:26:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>项目中有一个Activiy需要轮询多个接口，实时刷新数据。这里很多业务逻辑都需要依赖当前的状态，所以简单写了一个服务端，用于生成一些mock data，并且支持数据实时刷新。</p>
<p>项目地址：<a href="https://github.com/FelixZhang00/simple-mock-api" target="_blank" rel="external">simple-mock-api</a></p>
<p>挂到<a href="https://www.qcloud.com/" target="_blank" rel="external">腾讯云</a>上就可以公网访问了。</p>
<hr>
<h1 id="simple-mock-api"><a href="#simple-mock-api" class="headerlink" title="simple-mock-api"></a>simple-mock-api</h1><p>Use <a href="https://github.com/typicode/json-server" target="_blank" rel="external">json-server</a> make this simple mock api server.</p>
<h2 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h2><ol>
<li>checkout this project,and cd</li>
<li>type <code>npm install</code> in terminal to install dependences</li>
<li>run <code>node app.js</code></li>
<li>get result via your configed cgi，like <a href="http://localhost:3000/get_match_players" target="_blank" rel="external">http://localhost:3000/get_match_players</a></li>
</ol>
<h2 id="Config"><a href="#Config" class="headerlink" title="Config"></a>Config</h2><p>You can config </p>
<pre><code>cgi，
default json file,
custom handle the request, modify json response
</code></pre><h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><p>Create a <code>get_match_detail.json</code> file in <code>data</code> folder.</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">"state"</span>: <span class="number">1</span>,</div><div class="line">  <span class="attr">"title"</span>:<span class="string">"NBA"</span>,</div><div class="line">  <span class="attr">"time"</span>:<span class="string">"2017-01-01"</span>,</div><div class="line">  <span class="attr">"homescore"</span>: <span class="string">"101"</span>,</div><div class="line">  <span class="attr">"guestscore"</span>: <span class="string">"115"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>In <code>config.js</code> config you mock api</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">var config = [</div><div class="line">&#123;</div><div class="line">	"cgi":"/get_match_detail",</div><div class="line">	"filepath":"data/get_match_detail.json",</div><div class="line">	"need_cache":true,</div><div class="line">	"hookfunc":func_get_match_detail</div><div class="line">&#125;,</div><div class="line">&#123;</div><div class="line">	"cgi":"/get_match_players",</div><div class="line">	"filepath":"data/get_match_players.json",</div><div class="line">	"need_cache":false,</div><div class="line">	"hookfunc":func_get_match_players</div><div class="line">&#125;,</div><div class="line"></div><div class="line">];</div></pre></td></tr></table></figure>
<p>You can custom handle the request by define your custom “hookfunc”, like this:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> func_get_match_detail = <span class="function"><span class="keyword">function</span>(<span class="params">defaultObj,req</span>) </span>&#123;</div><div class="line">	<span class="comment">//increase homescore every time</span></div><div class="line">	<span class="keyword">var</span> homescore = <span class="built_in">parseInt</span>(defaultObj.homescore)+<span class="number">1</span>+<span class="string">""</span>;</div><div class="line">	defaultObj.homescore = homescore;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>The param <code>defaultObj</code> means the parsed json object you defined in the key “filepath”. </p>
<p>If the key “need_cache” seted true, than your hookfunc can change the defaultObj in the cache forever.</p>
<h3 id="Start-JSON-Server"><a href="#Start-JSON-Server" class="headerlink" title="Start JSON Server"></a>Start JSON Server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ node app.js</div></pre></td></tr></table></figure>
<p>Now if you go to <a href="http://localhost:3000/get_match_detail" target="_blank" rel="external">http://localhost:3000/get_match_detail</a>, you’ll get</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">"state"</span>: <span class="number">1</span>,</div><div class="line">  <span class="attr">"title"</span>:<span class="string">"NBA"</span>,</div><div class="line">  <span class="attr">"time"</span>:<span class="string">"2017-01-01"</span>,</div><div class="line">  <span class="attr">"homescore"</span>: <span class="string">"102"</span>,</div><div class="line">  <span class="attr">"guestscore"</span>: <span class="string">"115"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>and the homescore’s value changed every time when you go to the same link.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;项目中有一个Activiy需要轮询多个接口，实时刷新数据。这里很多业务逻辑都需要依赖当前的状态，所以简单写了一个服务端，用于生成一些mock data，并且支持数据实时刷新。&lt;/p&gt;
&lt;p&gt;项目地址：&lt;a href=&quot;https://github.com/FelixZhan
    
    </summary>
    
      <category term="工具 nodejs" scheme="http://felixzhang00.github.io/categories/%E5%B7%A5%E5%85%B7-nodejs/"/>
    
    
      <category term="工具 nodejs" scheme="http://felixzhang00.github.io/tags/%E5%B7%A5%E5%85%B7-nodejs/"/>
    
  </entry>
  
  <entry>
    <title>使用TraceView工具定位耗时操作</title>
    <link href="http://felixzhang00.github.io/2016/12/27/2016-12-27-%E9%80%9A%E8%BF%87trace%E6%96%87%E4%BB%B6%E5%AE%9A%E4%BD%8D%E8%80%97%E6%97%B6%E6%93%8D%E4%BD%9C/"/>
    <id>http://felixzhang00.github.io/2016/12/27/2016-12-27-通过trace文件定位耗时操作/</id>
    <published>2016-12-27T12:29:25.000Z</published>
    <updated>2016-12-30T09:51:06.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://developer.android.com/studio/profile/traceview.html" target="_blank" rel="external">TraceView</a>是DDMS中的工具，可以用来定位Android app中java方法的耗时操作。</p>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><h3 id="1-生成trace文件"><a href="#1-生成trace文件" class="headerlink" title="1.生成trace文件"></a>1.生成trace文件</h3><p>Eclipse中生成trace文件的方法：<br><img src="http://ww4.sinaimg.cn/mw690/8b331ee1gw1fb5lfcb484j20zg0pmtf7.jpg" alt=""></p>
<p><br><br>Android Studio生成trace文件的方法:</p>
<p><img src="http://ww2.sinaimg.cn/large/8b331ee1gw1fb5lgu5dsmj21kw0fmgpk.jpg" alt=""></p>
<p>生成的trace文件将显示在Captures窗口</p>
<p><img src="http://ww2.sinaimg.cn/large/8b331ee1gw1fb5lx8hffej20a707jmxe.jpg" alt=""><br>直接把trace文件拖到安装了ADT插件的Eclipse就能打开。</p>
<h3 id="2-Timeline-Panel"><a href="#2-Timeline-Panel" class="headerlink" title="2.Timeline Panel"></a>2.Timeline Panel</h3><p>Timeline展示各个线程占用CPU的情况。<br>横轴为从开始到结束trace的CPU时间，右边纵轴表示各个线程，每一横排表示线程占用CPU的情况。这里主要看主线程main</p>
<p><img src="http://ww1.sinaimg.cn/large/8b331ee1gw1fb5lrgshrqj21kw07jtbu.jpg" alt=""></p>
<p>放大后的效果如图，每个method用不同的颜色表示，展示CPU调用该方法到结束调用的时间。</p>
<p><img src="http://ww1.sinaimg.cn/large/8b331ee1gw1fb5m32u3j6j21am0bcn0k.jpg" alt=""></p>
<h3 id="3-Profile-Panel"><a href="#3-Profile-Panel" class="headerlink" title="3.Profile Panel"></a>3.Profile Panel</h3><p>Profile Panel展示了方法全名，方法耗时，调用次数，及方法的调用链关系。<br>在这里调用方法称为”parent”,被调方法称为”children”.</p>
<p><img src="http://ww3.sinaimg.cn/large/8b331ee1gw1fb5mewco9uj21kw0ngtsb.jpg" alt=""></p>
<hr>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《High Performance Android Apps》</p>
<p><a href="https://developer.android.com/studio/profile/traceview.html" target="_blank" rel="external">https://developer.android.com/studio/profile/traceview.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://developer.android.com/studio/profile/traceview.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;TraceView&lt;/a&gt;是DDMS中的工具，可以用来定位Android
    
    </summary>
    
      <category term="工具 Android" scheme="http://felixzhang00.github.io/categories/%E5%B7%A5%E5%85%B7-Android/"/>
    
    
      <category term="工具 Android" scheme="http://felixzhang00.github.io/tags/%E5%B7%A5%E5%85%B7-Android/"/>
    
  </entry>
  
  <entry>
    <title>代码浏览工具OpenGrok</title>
    <link href="http://felixzhang00.github.io/2016/12/25/2016-12-25-%E4%BB%A3%E7%A0%81%E6%B5%8F%E8%A7%88%E5%B7%A5%E5%85%B7OpenGrok/"/>
    <id>http://felixzhang00.github.io/2016/12/25/2016-12-25-代码浏览工具OpenGrok/</id>
    <published>2016-12-25T03:38:22.000Z</published>
    <updated>2016-12-30T09:52:06.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://opengrok.github.io/OpenGrok/" target="_blank" rel="external">OpenGrok</a>是一款强大的跨平台代码阅读工具，许多在线源码查看网站都是使用它来搭建的，比如著名的Android在线源码查看网站<a href="http://androidxref.com/" target="_blank" rel="external">androidxref</a>.</p>
<p><br><br><br><br><br></p>
<h2 id="OpenGrok特性"><a href="#OpenGrok特性" class="headerlink" title="OpenGrok特性"></a>OpenGrok特性</h2><p>OpenGrok 提供如下特性：</p>
<ul>
<li><p>1.快速搜索代码的引擎</p>
<p>  搜索全文、定义、符号、文件路径和修改历史</p>
<p>  搜索任意指定子目录（分层搜索）</p>
<p>  增量更新索引文件</p>
</li>
<li><p>2.支持类似 Google 的查询语法，比如 path:Makefile defs:target</p>
<p>  搜索日期范围内修改的文件</p>
<p>  支持使用通配符搜索，如 * 表示多个字符，? 表示单个字符</p>
<p>  在搜索结果中展示匹配行</p>
</li>
<li><p>3.一个 Web 只读版的版本历史查看界面</p>
<p>  文件的修改日志</p>
<p>  文件在两个版本间的 diff</p>
<p>  文件夹的历史记录</p>
</li>
<li><p>4.带语法高亮的交叉引用显示，可以使用 CSS 自定义样式</p>
<p>  可以开发插件支持新的语言和版本控制系统</p>
<p>  已经支持的语言： <a href="https://link.zhihu.com/?target=https%3A//github.com/OpenGrok/OpenGrok/wiki/Supported-Languages-and-Formats" target="_blank" rel="external">Supported Languages and Formats</a></p>
<p>  已经支持的版本控制系统：<a href="https://link.zhihu.com/?target=https%3A//github.com/OpenGrok/OpenGrok/wiki/Supported-Revision-Control-Systems" target="_blank" rel="external">Supported Revision Control Systems</a></p>
</li>
</ul>
<p><br><br><br><br><br></p>
<h2 id="在macOS平台搭建OpenGrok"><a href="#在macOS平台搭建OpenGrok" class="headerlink" title="在macOS平台搭建OpenGrok"></a>在macOS平台搭建OpenGrok</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>1.安装tomcat</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ brew install tomcat</div></pre></td></tr></table></figure>
<p>2.安装ctags</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ brew install ctags</div></pre></td></tr></table></figure>
<p>3.安装OpenGrok</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ wget -O - http://java.net/projects/opengrok/downloads/download/opengrok-0.12.1.tar.gz | tar xvz</div></pre></td></tr></table></figure>
<h3 id="开启tomcat"><a href="#开启tomcat" class="headerlink" title="开启tomcat"></a>开启tomcat</h3><p>方法1：cd到tomcat所在目录，然后执行命令，<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ catalina start </div><div class="line">$ open http://localhost:8080/<span class="built_in">source</span></div></pre></td></tr></table></figure></p>
<p>方法2：下载macOS下的GUI程序<a href="https://www.macupdate.com/app/mac/18706/tomcat-controller" target="_blank" rel="external">TomcatController</a><br>配置tomcat所在目录。<br><img src="http://ww3.sinaimg.cn/large/8b331ee1gw1fb2vmdecmpj217c0i6gpb.jpg" alt=""></p>
<h3 id="开启openGrok项目"><a href="#开启openGrok项目" class="headerlink" title="开启openGrok项目"></a>开启openGrok项目</h3><p>openGrok其实就是一个webapp<br><img src="http://ww3.sinaimg.cn/large/8b331ee1gw1fb2vobc954j21kw09saf1.jpg" alt=""></p>
<h3 id="导入项目"><a href="#导入项目" class="headerlink" title="导入项目"></a>导入项目</h3><p>比如导入ffmpeg，在opengrok目录下创建一个local_src文件夹，把ffmpeg文件夹通过软引用的方式链到local_src下的src目录，这样就能让opengrok找到ffmpeg的代码了。<br><img src="http://ww2.sinaimg.cn/large/8b331ee1gw1fb2vt7txidj21kw0cx42c.jpg" alt=""></p>
<h3 id="建立索引"><a href="#建立索引" class="headerlink" title="建立索引"></a>建立索引</h3><p><img src="http://ww2.sinaimg.cn/large/8b331ee1gw1fb2vtrtcuwj216g03476a.jpg" alt=""></p>
<h3 id="打开浏览器"><a href="#打开浏览器" class="headerlink" title="打开浏览器"></a>打开浏览器</h3><p>访问 <a href="http://localhost:8080/source" target="_blank" rel="external">http://localhost:8080/source</a> 就能看到代码了。<br><img src="http://ww1.sinaimg.cn/large/8b331ee1gw1fb2vuwcxfej21gc0aw3zw.jpg" alt=""></p>
<p><img src="http://ww2.sinaimg.cn/large/8b331ee1gw1fb2vv6s7voj21kw1d3aoa.jpg" alt=""></p>
<hr>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://blog.simplypatrick.com/2015/01/16/opengrok-on-mac-osx/" target="_blank" rel="external">http://blog.simplypatrick.com/2015/01/16/opengrok-on-mac-osx/</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/24369747" target="_blank" rel="external">https://zhuanlan.zhihu.com/p/24369747</a></p>
<p><a href="https://github.com/OpenGrok/OpenGrok/wiki/Features" target="_blank" rel="external">https://github.com/OpenGrok/OpenGrok/wiki/Features</a></p>
<p><a href="http://bytesthink.com/blog/?p=184" target="_blank" rel="external">http://bytesthink.com/blog/?p=184</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://opengrok.github.io/OpenGrok/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;OpenGrok&lt;/a&gt;是一款强大的跨平台代码阅读工具，许多在线源码查看网站都是使用它来搭建的，比如著名的Androi
    
    </summary>
    
      <category term="工具" scheme="http://felixzhang00.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="http://felixzhang00.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>ELF文件装载链接过程及hook原理</title>
    <link href="http://felixzhang00.github.io/2016/12/24/2016-12-24-ELF%E6%96%87%E4%BB%B6%E8%A3%85%E8%BD%BD%E9%93%BE%E6%8E%A5%E8%BF%87%E7%A8%8B%E5%8F%8Ahook%E5%8E%9F%E7%90%86/"/>
    <id>http://felixzhang00.github.io/2016/12/24/2016-12-24-ELF文件装载链接过程及hook原理/</id>
    <published>2016-12-24T14:35:04.000Z</published>
    <updated>2017-09-13T11:42:07.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ELF文件格式解析"><a href="#ELF文件格式解析" class="headerlink" title="ELF文件格式解析"></a>ELF文件格式解析</h2><p>可执行和可链接格式(Executable and Linkable Format，缩写为ELF)，常被称为ELF格式，在计算机科学中，是一种用于执行档、目的档、共享库和核心转储的标准文件格式。</p>
<p>ELF文件主要有四种类型：</p>
<ul>
<li>可重定位文件（Relocatable File） 包含适合于与其他目标文件链接来创建可执行文件或者共享目标文件的代码和数据。</li>
<li>可执行文件（Executable File） 包含适合于执行的一个程序，此文件规定了 exec() 如何创建一个程序的进程映像。</li>
<li>共享目标文件（Shared Object File） 包含可在两种上下文中链接的代码和数据。首先链接编辑器可以将它和其它可重定位文件和共享目标文件一起处理，生成另外一个目标文件。其次，动态链接器（Dynamic Linker）可能将它与某个可执行文件以及其它共享目标一起组合，创建进程映像。</li>
</ul>
<p>以一个简单的目标文件为例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">int global_init_var = 84;</div><div class="line">int global_uninit_var;</div><div class="line">void func1(int i)</div><div class="line">&#123;</div><div class="line">    printf(&quot;%d\n&quot;,i);</div><div class="line">&#125;</div><div class="line">int main(void)</div><div class="line">&#123;</div><div class="line">    char *str = &quot;hello&quot;;</div><div class="line">    static int static_var = 85;</div><div class="line">    static int static_var2;</div><div class="line">    int a = 1;</div><div class="line">    int b;</div><div class="line">    func1(static_var + static_var2 + a + b);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gcc -c SimpleSection.c</div></pre></td></tr></table></figure>
<h3 id="ELF文件结构"><a href="#ELF文件结构" class="headerlink" title="ELF文件结构"></a>ELF文件结构</h3><p><img src="http://ww2.sinaimg.cn/mw690/8b331ee1gw1f92kqr2mfoj20ty14k76x.jpg" alt="ELF文件结构"></p>
<h3 id="链接视图和执行视图"><a href="#链接视图和执行视图" class="headerlink" title="链接视图和执行视图"></a>链接视图和执行视图</h3><p>ELF文件在磁盘中和被加载到内存中并不是完全一样的，ELF文件提供了两种视图来反映这两种情况:链接视图和执行视图。顾名思义，链接视图就是在链接时用到的视图，而执行视图则是在执行时用到的视图。<br><img src="http://ww4.sinaimg.cn/mw690/8b331ee1gw1f92kvnpkstj20bz06fwf8.jpg" alt="链接视图和执行视图"></p>
<p>程序头部表(Program Header Table)，如果存在的话，告诉系统如何创建进程映像。<br>节区头部表(Section Header Table)包含了描述文件节区的信息，比如大小，偏移等。</p>
<h3 id="ELF文件头（ELF-Header）"><a href="#ELF文件头（ELF-Header）" class="headerlink" title="ELF文件头（ELF Header）"></a>ELF文件头（ELF Header）</h3><p>定义了ELF魔数、硬件平台等、<br>入口地址、程序头入口和长度、<br>段表的位置和长度及段的数量、<br>段表字符串表（.shstrtab）所在的段在段表中的下标。</p>
<p>可以在”/usr/include/elf.h”中找到它的定义（Elf32_Ehdr）。<br>ELF各个字段的说明:</p>
<p><img src="http://ww2.sinaimg.cn/mw690/8b331ee1gw1f92kwlnz2ej20ht0snqbv.jpg" alt=""></p>
<h3 id="段表-Section-Header-Table"><a href="#段表-Section-Header-Table" class="headerlink" title="段表(Section Header Table)"></a>段表(Section Header Table)</h3><p>描述了各个段的信息，比如每个段的段名、段的长度、在文件中的偏移、读写权限及段的其它属性。<br>段表的结构是一个以Elf32_Shdr结构体（段描述符）为元素的数组。<br>每个Elf32_Shdr结构体对应一个段。<br>使用readelf工具查看ELF文件的段:<br><img src="http://ww4.sinaimg.cn/mw690/8b331ee1gw1f92kx9tdv3j21kw0sfak2.jpg" alt=""></p>
<p><strong>段描述符（Elf32_Shdr）</strong>的各个成员及含义：<br><img src="http://ww4.sinaimg.cn/large/8b331ee1gw1f92kyt2f0gj21kw1oq4j0.jpg" alt=""></p>
<p><strong>段的类型(sh_type)</strong><br>对于编译器和链接器，主要决定段的属性的是段的类型(sh_type)和段的标志位(shflags)。段的类型相关常量以SHT开头，列举如下表。<br><img src="http://ww3.sinaimg.cn/large/8b331ee1gw1f92l0g93grj20k80bg0vq.jpg" alt=""></p>
<p><strong>段的标志位(sh<em>flag)</em></strong>表示该节在进程虚拟地址空间中的属性，比如是否可写，是否可执行等。相关常量以SHF开头，如下表：<br><img src="http://ww1.sinaimg.cn/large/8b331ee1gw1f92l38ufjqj20k504sjsn.jpg" alt=""></p>
<p><strong>段的链接信息(sh_link、sh_info)</strong> 如果节的类型是和链接相关的，比如重定位表、符号表等，那么sh_link和sh_info两个成员包含的意义如下。对于其他段，这两个成员没有意义。<br><img src="http://ww4.sinaimg.cn/large/8b331ee1gw1f92l3seot7j20kd06babi.jpg" alt=""></p>
<h3 id="代码段-text"><a href="#代码段-text" class="headerlink" title="代码段(.text)"></a>代码段(.text)</h3><p>使用objdump工具查看代码段的内容，”-d”参数将所有包含指令的段反汇编。<br><img src="http://ww1.sinaimg.cn/mw690/8b331ee1gw1f92l64fa4ej21b41q2114.jpg" alt=""></p>
<h3 id="数据段-data-和只读数据段-rodata"><a href="#数据段-data-和只读数据段-rodata" class="headerlink" title="数据段(.data)和只读数据段(.rodata)"></a>数据段(.data)和只读数据段(.rodata)</h3><p>.data段保存的是那些已经初始化了的全局静态变量和局部静态变量。前面SimpleSection.c代码里面一共有两个这样的变量，都是int类型的，一共刚好8字节。<br>在SimpleSection.c里在调用”printf”的时候，用到了一个字符串常量”%d\n”,它是一种只读数据，所以被放到了”.rodata”段。<br><img src="http://ww2.sinaimg.cn/mw690/8b331ee1gw1f92l6sfdb3j21ei0kmmzk.jpg" alt=""></p>
<h3 id="BSS段-bss"><a href="#BSS段-bss" class="headerlink" title="BSS段(.bss)"></a>BSS段(.bss)</h3><p>.bss段存放的未初始化的全局变量和局部静态变量。.bss段不占磁盘空间。<br><img src="http://ww4.sinaimg.cn/mw690/8b331ee1gw1f92l7ea9guj21eo0ao0ti.jpg" alt=""></p>
<h3 id="字符串表（-strtab）"><a href="#字符串表（-strtab）" class="headerlink" title="字符串表（.strtab）"></a>字符串表（.strtab）</h3><p>在ELF文件中，会用到很多字符串，比如节名，变量名等。所以ELF将所有的字符串集中放到一个表里，每一个字符串以’\0’分隔，然后使用字符串在表中的偏移来引用字符串。<br>比如下面这样：<br><img src="http://ww2.sinaimg.cn/mw690/8b331ee1gw1f92l7t2tyrj20k903fgm5.jpg" alt=""><br>那么偏移与他们对用的字符串如下表:<br><img src="http://ww2.sinaimg.cn/mw690/8b331ee1gw1f92l81n2y1j20k7043jrs.jpg" alt=""><br>这样在ELF中引用字符串只需要给出一个数组下标即可。字符串表在ELF也以段的形式保存，常见的段名为”.strtab”或”.shstrtab”。这两个字符串表分别为字符串表(String Table)和段表字符串表(Header String Table)，字符串表保存的是普通的字符串，而段表字符串表用来保存段表中用到的字符串，比如段名。</p>
<h3 id="符号表（-symtab）"><a href="#符号表（-symtab）" class="headerlink" title="符号表（.symtab）"></a>符号表（.symtab）</h3><p>在链接的过程中需要把多个不同的目标文件合并在一起，不同的目标文件相互之间会引用变量和函数。在链接过程中，我们将函数和变量统称为符号，函数名和变量名就是符号名。<br>每一个目标文件中都有一个相应的符号表(System Table)，这个表里纪录了目标文件所用到的所有符号。每个定义的符号都有一个相应的值，叫做符号值(Symbol Value)，对于变量和函数，符号值就是它们的地址。<br>符号表是一个Elf32_Sym(32位)的数组，每个Elf32_Sym对应一个符号。这个数组的第一个元素，也就是下标为0的元素为无效的”未定义”符号。<br>他们的定义如下：<br><img src="http://ww1.sinaimg.cn/mw690/8b331ee1gw1f92l8p5639j20ku06t768.jpg" alt=""></p>
<p><strong>符号类型和绑定信息(st_info)</strong><br>该成员的低4位标识符号的类型(Symbol Type)，高28位标识符号绑定信息(Symbol Binding)，如下表所示。<br><img src="http://ww2.sinaimg.cn/mw690/8b331ee1gw1f92l9hsyp1j20kf04rwf9.jpg" alt=""><br><img src="http://ww2.sinaimg.cn/mw690/8b331ee1gw1f92l9o0v6dj20k907575x.jpg" alt=""><br><strong>符号所在段(st_shndx)</strong><br>如果符号定义在本目标文件中，那么这个成员表示符号所在段在段表中的下表，但是如果符号不是定义在本目标文件中，或者对于有些特殊符号，sh_shndx的值有些特殊。如下：<br><img src="http://ww3.sinaimg.cn/mw690/8b331ee1gw1f92la2n675j20kk07dq4r.jpg" alt=""></p>
<p><strong>符号值(st_value)</strong><br>每个符号都有一个对应的值。主要分下面几种情况：</p>
<ul>
<li>如果符号不是”COMMON”类型的(即st_shndx不为SHN_COMMON)，则st_value表示该符号在段中的偏移，即符号所对应的函数或变量位于由st_shndx指定的段，偏移st_value的位置。比如SimpleSection中的”func1”，”main”和”global_init_var”。</li>
<li>在目标文件中，如果符号是”COMMON”类型(即st_shndx为SHN_COMMON)，则st_value表示该符号的对齐属性。比如SimleSection中的”global_uninit_var”。</li>
<li>在可执行文件中，st_value表示符号的虚拟地址。</li>
</ul>
<p>下图为使用readelf工具来查看ELF文件的符号:<br><img src="http://ww3.sinaimg.cn/mw690/8b331ee1gw1f92lb4pncvj21jm0rgtea.jpg" alt=""><br>比如，Num13行指的是符号表中的第13个元素，符号名为main，它是函数类型，定义在第一个段（即.text段）的第001b偏移处，大小为64字节。</p>
<h3 id="重定位表-rel-text"><a href="#重定位表-rel-text" class="headerlink" title="重定位表(.rel.text)"></a>重定位表(.rel.text)</h3><p>SimpleSection.o中有一个叫”.rel.text”的段，它的类型(sh_type)为”SHT_REL”，也就是说它是一个重定位表。链接器在处理目标文件时，需要对目标文件中的某些部位进行重定位，即代码段和数据中中那些绝对地址引用的位置。对于每个需要重定位的代码段或数据段，都会有一个相应的重定位表。比如”.rel.text”就是针对”.text”的重定位表，”.rel.data”就是针对”.data”的重定位表。</p>
<hr>
<h2 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h2><p>这节以下面两个文件为例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">/* a.c */</div><div class="line">extern int shared;</div><div class="line">int main()&#123;</div><div class="line">    int a = 100;</div><div class="line">    swap(&amp;a,&amp;shared);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">/* b.c */</div><div class="line">int shared = 1;</div><div class="line">void swap(int* a, int* b)&#123;</div><div class="line">    *a ^= *b ^= *a ^= *b;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当我们有两个目标文件时，如何将他们链接起来形成一个可执行文件？<br>对于多个输入目标文件，链接器如何将它们的各个段合并到输出文件？输出文件中的空间如何更配给输入文件？<br>下图为现在链接器采用的空间分配策略。<br><img src="http://ww1.sinaimg.cn/mw690/8b331ee1gw1f92lhyc2ugj2124138dkb.jpg" alt=""></p>
<p>整个链接过程分两步：</p>
<ul>
<li>第一步 空间与地址分配 扫描所有的输入目标文件，并且获得它们的各个段的长度、属性和位置，并且将输入目标文件中的符号表中所有的符号定义和符号引用收集起来，统一放到一个全局符号表中。</li>
<li>第二步 符号解析与重定位 使用第一步中收集到的信息，读取输入文件中段的数据、重定位信息，并且进行符号解析与重定位、调整代码中的地址等</li>
</ul>
<p>使用ld链接器将”a.o”和”b.o”链接起来：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ld a.o b.o -e main -o ab</div></pre></td></tr></table></figure></p>
<p>查看链接前后各个段的属性<br><img src="http://ww4.sinaimg.cn/mw690/8b331ee1gw1f92ljdpqkgj21b418244f.jpg" alt=""><br>VMA表示虚拟地址，LMA表示加载地址，正常情况下这两个值应该一样。</p>
<p>整个链接过程前后，目标文件各段的分配、程序虚拟地址:<br><img src="http://ww1.sinaimg.cn/mw690/8b331ee1gw1f92ljxvmqmj21hq10ygo3.jpg" alt=""><br>在Linux下，ELF可执行未见默认从地址0x08048000开始分配。</p>
<h3 id="符号解析与重定位"><a href="#符号解析与重定位" class="headerlink" title="符号解析与重定位"></a>符号解析与重定位</h3><p>编译器在将”a.c”编译成指令时，它如何访问”shared”变量？如何调用”swap”函数？<br><strong>重定位表(Relocation Tabel)</strong>专门用来保存与重定位相关的信息，链接器根据它知道哪些指令时要被调整的，以及如何调整。<br>对于32位的Intel x86系列处理器来说，重定位表的结构是一个Elf_32Rel结构的数组，每个数组元素对应一个重定位入口。定义如下：<br><img src="http://ww4.sinaimg.cn/mw690/8b331ee1gw1f92lm64qwqj21j00kwtec.jpg" alt=""></p>
<p>可以使用objdump来查看目标文件的重定位表：<br><img src="http://ww4.sinaimg.cn/mw690/8b331ee1gw1f92lmerm9rj20oa0bu3za.jpg" alt=""></p>
<p>将”a.o”的代码段反汇编可以看到，此时编译器并不知道“shared”的地址，暂时把地址0看做”shared”的地址。<br>0xE8是一条近址相对位移调用指令，后面4个字节就是被调用函数的相对于调用指令的下一条指令的偏移量。<br>此处”swap”函数的地址是0x2b-4=0x27,可以看出0xfffffffc也是一个临时地址。<br><img src="http://ww2.sinaimg.cn/mw690/8b331ee1gw1f92lmrq7o2j21900yagpl.jpg" alt=""></p>
<p><strong>指令修正方式</strong><br><img src="http://ww3.sinaimg.cn/mw690/8b331ee1gw1f92lngo4gzj21iu0fsjuq.jpg" alt=""></p>
<p>指令修复的结果<br><img src="http://ww2.sinaimg.cn/mw690/8b331ee1gw1f92lnnaqsej21d411ydlb.jpg" alt=""></p>
<hr>
<h2 id="可执行文件的装载与进程"><a href="#可执行文件的装载与进程" class="headerlink" title="可执行文件的装载与进程"></a>可执行文件的装载与进程</h2><p>程序执行时所需要的指令和数据必需在内存中才能够正常运行。<br>页映射将内存和所有磁盘中的数据和指令按照“页（Page）”为单位划分成若干个页，以后所有的装载和操作的单位就是页。</p>
<p>进程的建立需要做下面三件事情：</p>
<ul>
<li>创建一个独立的虚拟地址空间</li>
<li>读取可执行文件头，并且建立虚拟空间与可执行文件的映射关系。</li>
<li>将CPU的指令寄存器设置成可执行文件的入口地址，启动运行。</li>
</ul>
<p>对于第2步，当操作系统捕获到缺页错误时，它应该知道程序当前所需的页在可执行文件中的哪一个位置。<br>这种映射关系是保存在操作系统内部的一个数据结构<strong>VMA</strong>。<br>例如下图中，操作系统创建进程后，会在进程相应的数据结构中设置有一个.text段的VMA：它在虚拟空间中的地址为0x08048000~0x08049000，它对应ELF文件中偏移为0的.text，它的属性为只读，还有一些其他的属性。<br><img src="http://ww4.sinaimg.cn/mw690/8b331ee1gw1f92lokbzk3j20wi0lo0u7.jpg" alt=""></p>
<p><strong>页错误</strong><br>在上面的例子中，程序的入口地址为0x08048000，当CPU开始打算执行这个地址的指令时，发现页面0x08048000~0x08049000（虚拟地址）是个空页面，于是它就认为这是一个页错误。CPU将控制权交给操作系统，操作系统将查询虚拟空间与可执行文件的映射关系表，找到空页面所在的VMA，计算相应的页面在可执行文件中的偏移，然后在物理内存中分配一个物理页面，将进程中该虚拟页与分配的物理页之间建立映射关系，然后把控制权再还给进程，进程从刚才页错误的位置重新开始执行。</p>
<h3 id="链接视图和执行视图-1"><a href="#链接视图和执行视图-1" class="headerlink" title="链接视图和执行视图"></a>链接视图和执行视图</h3><p>以下面的程序为例。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">使用静态链接的方式将其编译成可执行文件：</div><div class="line">$gcc -static SectionMapping.c -o SectionMapping.elf</div><div class="line">**/</div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</div><div class="line">    &#123;</div><div class="line">        sleep(<span class="number">1000</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>下面的elf文件被重新划分成了三个部分，有一些段被归入可读可执行的，他们被统一映射到一个CODE VMA；另一部分段是可读可写的，它们被映射到了DATA VMA；还有一些段在程序执行时没有用，所以不需要映射。<br>ELF与Linux进程虚拟空间映射关系（一个常见进程的虚拟空间）如下图。<br><img src="http://ww2.sinaimg.cn/mw690/8b331ee1gw1f92lpqlsm9j212y1fkaem.jpg" alt=""></p>
<h4 id="程序头表-Program-Header-Table"><a href="#程序头表-Program-Header-Table" class="headerlink" title="程序头表(Program Header Table)"></a>程序头表(Program Header Table)</h4><p>用来保存“Segment”的信息,描述了ELF文件该如何被操作系统映射到虚拟空间。因为ELF目标文件不需要被装载，所以它没有程序头表，而ELF的可执行文件和共享库文件都有。<br>使用readelf查看程序头表。<br><img src="http://ww1.sinaimg.cn/mw690/8b331ee1gw1f92lreiga6j21380me0x3.jpg" alt=""></p>
<p>跟段表结构一样，程序头表也是一个结构体数组，其结构体用Elf32_Phdr表示。<br>下表是Elf32_Phdr结构的各个成员的基本含义。<br><img src="http://ww2.sinaimg.cn/mw690/8b331ee1gw1f92lrncz74j21jw0vwgtx.jpg" alt=""></p>
<h3 id="堆和栈"><a href="#堆和栈" class="headerlink" title="堆和栈"></a>堆和栈</h3><p>VMA除了被用来映射可执行文件中的各个”segment”以外，操作系统通过使用VMA来对进程的地址空间进行管理，包括堆和栈。<br>在Linux下，可以通过查看”/proc”来查看进程的虚拟空间分布：<br><img src="http://ww4.sinaimg.cn/mw690/8b331ee1gw1f92ltj5czaj21120hkwi3.jpg" alt=""><br>我们可以看到进程中有5个VMA,只有前两个是映射到可执行文件中的两个Segment。另外三个段的文件所在设备主设备号及文件节点号都是0，则表示他们没有映射到文件中，这种VMA叫做匿名虚拟内存区域。另外有一个很特殊的VMA叫“vdso”，它的地址已经位于内核空间了（即大于0xC0000000的地址），事实上它是一个内核的模块，进程可以通过访问这个VMA来跟内核进行一些通信。<br>操作系统通过给进程空间划分出一个个VMA来管理进程的虚拟空间；基本原则是将相同权限属性的、有相同映像文件的映射成一个VMA。</p>
<hr>
<h2 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h2><p>以下面的代码为例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">/* Lib.h */</div><div class="line">#ifndef LIB_H</div><div class="line">#define LIB_H</div><div class="line">void foobar(int i);</div><div class="line">#endif</div><div class="line"></div><div class="line">/* Lib.c */</div><div class="line">#include &lt;stdio.h&gt;</div><div class="line">void foobar(int i)&#123;</div><div class="line">    printf(&quot;Printing from Lib.so %d\n&quot;,i);</div><div class="line">    sleep(-1);</div><div class="line">&#125;</div><div class="line"></div><div class="line">/* Program1.c */</div><div class="line">#include &quot;Lib.h&quot;</div><div class="line">int main()&#123;</div><div class="line">    foobar(1);</div><div class="line">    return;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/* Program2.c */</div><div class="line">#include &quot;Lib.h&quot;</div><div class="line">int main()&#123;</div><div class="line">    foobar(2);</div><div class="line">    return;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>将Lib.c编译成一个共享对象文件：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$gcc</span> <span class="_">-f</span>PIC -shared -o Lib.so Lib.c</div></pre></td></tr></table></figure>
<p>分别编译链接Program1.c和Program2.c：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$gcc</span> -o Program1 Program1.c ./Lib.so</div></pre></td></tr></table></figure></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$gcc</span> -o Program2 Program2.c ./Lib.so</div></pre></td></tr></table></figure>
<p>查看进程的虚拟地址空间分布：<br><img src="http://ww4.sinaimg.cn/mw690/8b331ee1gw1f92lywp140j20zm0n0grl.jpg" alt=""><br>上图中的ld-2.6.so实际上是Linux下的动态链接器，它与普通共享对象一样被映射到了进程的地址空间，在系统开始运行program1之前，首先会把控制权交给动态链接器，由它完成所有的动态链接工作以后再把控制权交给program1,然后开始执行。</p>
<p>通过readelf查看Lib.so的装载属性：<br><img src="http://ww1.sinaimg.cn/mw690/8b331ee1gw1f9320c9v7lj214q0q8776.jpg" alt=""><br>与普通程序不同的是，动态链接模块的装载地址是从地址0x00000000开始的，这个地址是无效的，共享对象的最终装载地址在编译时时不确定的，而是在装载时，装载器根据当前地址空间的空前情况，动态分配一块足够大小的虚拟地址空间给相应的共享对象。</p>
<h3 id="地址无关代码-PIC"><a href="#地址无关代码-PIC" class="headerlink" title="地址无关代码(PIC)"></a>地址无关代码(PIC)</h3><p>装载时重定位是解决动态模块中有绝对地址引用的方法之一，但是它有一个很大的缺点是指令部分无法在多个进程之间共享，这样就失去了动态链接节省内存的一大优势。我们还需要有一种更好的方法解决共享对象指令中对绝对地址的重定位问题。其实我们的目的很简单，希望程序模块中共享的指令部分在装载时不需要因为装载地址的改变而改变，所以实现的基本思想就是把指令中那些需要被修改的部分分离出来，跟数据部分放在一起，这样指令部分就可以保持不变，而数据部分可以在每个进程中拥有一个副本。</p>
<p>模块中各种类型的地址引用方式如下图：<br><img src="http://ww3.sinaimg.cn/mw690/8b331ee1gw1f9321f0xmjj20hg0go76x.jpg" alt=""></p>
<h4 id="全局偏移表-GOT"><a href="#全局偏移表-GOT" class="headerlink" title="全局偏移表(GOT)"></a>全局偏移表(GOT)</h4><p>用于模块间数据访问，在数据段里建立一个指向外部模块变量的指针数组。当代码需要引用该全局变量时，可以通过GOT中相对用的项间接引用，它的基本机制如下图。<br><img src="http://ww2.sinaimg.cn/mw690/8b331ee1gw1f9321to16sj214w10qwgd.jpg" alt=""><br>当指令中需要访问变量b时，程序会先找到GOT，然后根据GOT中变量所对应的项找到变量的目标地址。每个变量都对应一个4字节的地址，链接器在装载模块的时候会查找每个变量所在的地址，然后填充GOT中的各个项，以确保每个指针所指向的地址正确。由于GOT本身是放在数据段的，所以它可以在模块装载时被修改，并且每个进程都可以有独立的副本，相互不受影响。</p>
<h4 id="延迟绑定-PLT"><a href="#延迟绑定-PLT" class="headerlink" title="延迟绑定(PLT)"></a>延迟绑定(PLT)</h4><p>动态链接下对于全局和静态的数据访问都要进行复杂的GOT定位，然后间接寻址；对于模块间的调用也要先定位GOT，然后再进行间接跳转。程序开始执行时，动态链接器都要进行一次链接工作，会寻找并装载所需的共享对象，然后进行符号查找地址重定位等工作，如此一来，程序的运行速度必定会减慢。</p>
<p>延迟绑定的实现<br>函数第一次被用到时才进行绑定（符号查找、重定位等），如果没有用到则不进行绑定。</p>
<p>GOT 位于 .got.plt section 中，而 PLT 位于 .plt section中。<br>GOT 保存了程序中所要调用的函数的地址，运行一开时其表项为空，会在运行时实时的更新表项。一个符号调用在第一次时会解析出绝对地址更新到 GOT 中，第二次调用时就直接找到 GOT 表项所存储的函数地址直接调用了。<br>printf（）函数的调用过程如下图<br><img src="http://ww3.sinaimg.cn/mw690/8b331ee1gw1f9322tt0r1j20le0dhjss.jpg" alt=""></p>
<h4 id="GDB调试分析延迟绑定机制"><a href="#GDB调试分析延迟绑定机制" class="headerlink" title="GDB调试分析延迟绑定机制"></a>GDB调试分析延迟绑定机制</h4><p>为了加深理解可以用GDB动态调试，Examine下断点前后GOT表的内存的变化。</p>
<p><img src="https://ws1.sinaimg.cn/large/8b331ee1gy1fhup35zlf7j20qb0ku43o.jpg" alt=""><br><img src="https://ws1.sinaimg.cn/large/8b331ee1gy1fhupado4inj20jh0dh7bk.jpg" alt=""><br><img src="https://ws1.sinaimg.cn/large/8b331ee1gy1fhupaf7mf9j20h6074adu.jpg" alt=""></p>
<p>动态加载器解析结束，可以看到got表项正确指向了libc动态库中printf的地址<br><img src="https://ws1.sinaimg.cn/large/8b331ee1gy1fhupah7cbjj20d3092acm.jpg" alt=""></p>
<h3 id="动态链接的相关结构"><a href="#动态链接的相关结构" class="headerlink" title="动态链接的相关结构"></a>动态链接的相关结构</h3><h4 id="interp段"><a href="#interp段" class="headerlink" title=".interp段"></a>.interp段</h4><p>在动态链接的ELF可执行文件中，有一个专门的段叫做”.interp”段。里面保存的是一个字符串，记录所需动态链接器的路径。<br>从下图可以看出，Android用的动态链接器是linker<br><img src="http://ww1.sinaimg.cn/mw690/8b331ee1gw1f9323mnszoj21j805itco.jpg" alt=""></p>
<h4 id="dynamic段"><a href="#dynamic段" class="headerlink" title=".dynamic段"></a>.dynamic段</h4><p>这个段里保存了动态链接器所需要的基本信息，比如依赖哪些共享对象、动态链接符号表的位置、动态链接重定位表的位置、共享对象初始化代码的地址等。<br>.dynamic段里保存的信息有点像ELF文件头。<br>.dynamic段的结构是由Elf32_Dyn组成的数组。<br>Elf32_Dyn结构由一个类型值加上一个附加的数值或指针，对于不同的类型，后面附加的数值或者指针有着不同的含义。<br><img src="http://ww3.sinaimg.cn/mw690/8b331ee1gw1f932414wnzj21ii0syq9p.jpg" alt=""></p>
<h4 id="动态符号表-dynsym"><a href="#动态符号表-dynsym" class="headerlink" title="动态符号表(.dynsym)"></a>动态符号表(.dynsym)</h4><p>为了表示动态链接模块之间的符号导入导出关系，ELF专门有一个叫做动态符号表的段用来保存这些信息。<br>与”.symtab”不同的是，”.dynsym”只保存了与动态链接相关的符号，对于那些模块内部的符号，比如模块私有变量则不保存。很多时候动态链接模块同时拥有”.dynsym”和”.symtab”两个表，”.symtab”中往往保存了所有符号，包括”.dynsym”中的符号。</p>
<h4 id="动态符号字符串表-dynstr"><a href="#动态符号字符串表-dynstr" class="headerlink" title="动态符号字符串表(.dynstr)"></a>动态符号字符串表(.dynstr)</h4><p>在动态链接时用于保存符号名的字符串表。</p>
<h4 id="符号哈希表-hash"><a href="#符号哈希表-hash" class="headerlink" title="符号哈希表(.hash)"></a>符号哈希表(.hash)</h4><p>由于动态链接下，需要在程序运行时查找符号，为了加快符号的查找过程，往往还有辅助的符号好戏表。<br>用readelf查看elf文件的动态符号表及它的哈希表。<br><img src="http://ww3.sinaimg.cn/mw690/8b331ee1gw1f9324ovvklj211g0n6af4.jpg" alt=""></p>
<h3 id="动态链接重定位表"><a href="#动态链接重定位表" class="headerlink" title="动态链接重定位表"></a>动态链接重定位表</h3><p>在动态链接中，导入符号的地址在运行时才确定，所以需要在运行时将这些导入符号的引用修正，即需要重定位。</p>
<p>“.rel.dyn”段对数据引用的修正，它所修正的位置位于”.got”以及数据段；<br>“.rel.plt”段对函数引用修正，它所修正的位置位于”.got.plt”。<br>用readelf来查看一个动态链接的文件的重定位表：</p>
<p><img src="http://ww3.sinaimg.cn/mw690/8b331ee1gw1f93258e2hrj21i00ue7a1.jpg" alt=""></p>
<p>R_386_JUMP_SLOT和R_386_GLOB_DAT这两个类型的重定位入口表示，被修正的位置只需要直接填入符号地址即可。<br>比如，printf这个重定位入口，它的类型为R_386_JUMP_SLOT，它的偏移为0x000015d8，它位于”.got.plt”中，下图为其结构。</p>
<p><img src="http://ww2.sinaimg.cn/mw690/8b331ee1gw1f9325hfyr7j213q0zitfq.jpg" alt=""></p>
<p>当链接器需要进行重定位时，它先查找”printf”的地址，“printf”位于libc.so中。假设链接器在全局符号表里面找到”printf”的地址为0x08801234,那么链接器就会将这个地址填入到”.got.plt”中偏移为0x000015d8的位置中去，从而实现了地址的重定位。<br>R_386_GLOB_DAT是对”.got”的重定位，它跟R_386_JUMP_SLOT的做法一样。</p>
<hr>
<h2 id="android-arm架构的一种hook实现方案"><a href="#android-arm架构的一种hook实现方案" class="headerlink" title="android arm架构的一种hook实现方案"></a>android arm架构的一种hook实现方案</h2><p>具体实现来自Andrey Petrov的<a href="http://shadowwhowalks.blogspot.com/2013/01/android-hacking-hooking-system.html" target="_blank" rel="external">blog</a>. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div></pre></td><td class="code"><pre><div class="line">#include &quot;linker.h&quot;  // get it from bionic</div><div class="line">static unsigned elfhash(const char *_name)  </div><div class="line">&#123;  </div><div class="line">  const unsigned char *name = (const unsigned char *) _name;  </div><div class="line">  unsigned h = 0, g;  </div><div class="line">  while(*name) &#123;  </div><div class="line">    h = (h &lt;&lt; 4) + *name++;  </div><div class="line">    g = h &amp; 0xf0000000;  </div><div class="line">    h ^= g;  </div><div class="line">    h ^= g &gt;&gt; 24;  </div><div class="line">  &#125;  </div><div class="line">  return h;  </div><div class="line">&#125;  </div><div class="line">static Elf32_Sym *soinfo_elf_lookup(soinfo *si, unsigned hash, const char *name)  </div><div class="line">&#123;  </div><div class="line">  Elf32_Sym *s;  </div><div class="line">  Elf32_Sym *symtab = si-&gt;symtab;  </div><div class="line">  const char *strtab = si-&gt;strtab;  </div><div class="line">  unsigned n;  </div><div class="line">  n = hash % si-&gt;nbucket;  </div><div class="line">  for(n = si-&gt;bucket[hash % si-&gt;nbucket]; n != 0; n = si-&gt;chain[n])&#123;  </div><div class="line">    s = symtab + n;  </div><div class="line">    if(strcmp(strtab + s-&gt;st_name, name)) continue;  </div><div class="line">      return s;  </div><div class="line">    &#125;  </div><div class="line">  return NULL;  </div><div class="line">&#125;  </div><div class="line"></div><div class="line">int hook_call(char *soname, char *symbol, unsigned newval) &#123;  </div><div class="line"> soinfo *si = NULL;  </div><div class="line"> Elf32_Rel *rel = NULL;  </div><div class="line"> Elf32_Sym *s = NULL;   </div><div class="line"> unsigned int sym_offset = 0;  </div><div class="line"> if (!soname || !symbol || !newval)  </div><div class="line">    return 0;  </div><div class="line"> si = (soinfo*) dlopen(soname, 0);  </div><div class="line"> if (!si)  </div><div class="line">  return 0;  </div><div class="line"> s = soinfo_elf_lookup(si, elfhash(symbol), symbol);  </div><div class="line"> if (!s)  </div><div class="line">   return 0;  </div><div class="line"> sym_offset = s - si-&gt;symtab;  </div><div class="line"> rel = si-&gt;plt_rel;  </div><div class="line"> /* walk through reloc table, find symbol index matching one we&apos;ve got */  </div><div class="line"> for (int i = 0; i &lt; si-&gt;plt_rel_count; i++, rel++) &#123;  </div><div class="line">  unsigned type = ELF32_R_TYPE(rel-&gt;r_info);  </div><div class="line">  unsigned sym = ELF32_R_SYM(rel-&gt;r_info);  </div><div class="line">  unsigned reloc = (unsigned)(rel-&gt;r_offset + si-&gt;base);  </div><div class="line">  uint32_t page_size = 0;</div><div class="line">  uint32_t entry_page_start = 0;</div><div class="line">  unsigned oldval = 0;  </div><div class="line">  if (sym_offset == sym) &#123;  </div><div class="line">   switch(type) &#123;  </div><div class="line">     case R_ARM_JUMP_SLOT:  </div><div class="line">         /* we do not have to read original value, but it would be good</div><div class="line">            idea to make sure it contains what we are looking for */</div><div class="line">        page_size = getpagesize();</div><div class="line">        entry_page_start = reloc&amp; (~(page_size - 1));</div><div class="line">        int ret = mprotect((uint32_t *)entry_page_start, page_size, PROT_READ | PROT_WRITE); </div><div class="line">        </div><div class="line">        oldval = *(unsigned*) reloc;  </div><div class="line">        *((unsigned*)reloc) = newval;  </div><div class="line">        return 1;  </div><div class="line">     default:  </div><div class="line">        return 0;  </div><div class="line">   &#125;  </div><div class="line">  &#125;  </div><div class="line"> &#125;  </div><div class="line"> return 0;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>用法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hook_call(&quot;libandroid_runtime.so&quot;, &quot;connect&quot;, &amp;my_connect);</div></pre></td></tr></table></figure></p>
<p>1.调用dlopen拿到so的句柄,得到soinfo,它包含了符号表、重定位表、plt表等信息。<br>2.查找需要hook的函数的符号，得到它在符号表中的索引。具体实现是soinfo_elf_lookup函数。</p>
<p><img src="http://ww4.sinaimg.cn/mw690/8b331ee1gw1f932uud83bj207r088mxj.jpg" alt=""></p>
<p>bucket数组包含nbucket个项目，chain数组包含nchain个项目，下标都是从0开始。bucket和chain中都保存了符号表的索引。chain表项和符号表存在对应。符号表项的数目应该和nchain相等，所以符号表的索引也可以用来选取chain表项。哈希函数能够接受符号名并返回一个可以用来计算bucket的索引。如果哈希函数针对某个名字返回了数值x，则bucket[x%nbucket]给出了一个索引y，该索引可用于符号表，也可用于chain表。如果该符号表项不是所需要的，那么chain[y]则给出了具有相同哈希值的下一个符号表项。我们可以沿着chain链一直搜索，直到所选中的符号表项包含了所需要的符号，或者chain项中包含值STN_UNDEF。</p>
<p> 3.遍历plt表，直到匹配第2步中找到的符号索引。<br> 如果是JUMP_SLOT类型（函数调用），替换为新的符号地址（函数指针）。</p>
<p>程序中调用mprotect的作用是：<br>修改一段指定内存区域的保护属性。<br><a href="https://linux.die.net/man/2/mprotect" target="_blank" rel="external">函数原型</a>为：<br><code>int mprotect(const void *start, size_t len, int prot);</code><br>mprotect()函数把自start开始的、长度为len的内存区的保护属性修改为prot指定的值。<br>需要指出的是，指定的内存区间必须包含整个内存页（4K）。区间开始的地址start必须是一个内存页的起始地址，并且区间长度len必须是页大小的整数倍。</p>
<hr>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li>《程序员的自我修养》</li>
<li>《深入理解计算机系统》</li>
<li><a href="http://shadowwhowalks.blogspot.com/2013/01/android-hacking-hooking-system.html" target="_blank" rel="external">Andrey Petrov’s blog</a></li>
<li><a href="https://www.apriorit.com/dev-blog/181-elf-hook" target="_blank" rel="external">Redirecting functions in shared ELF libraries</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;ELF文件格式解析&quot;&gt;&lt;a href=&quot;#ELF文件格式解析&quot; class=&quot;headerlink&quot; title=&quot;ELF文件格式解析&quot;&gt;&lt;/a&gt;ELF文件格式解析&lt;/h2&gt;&lt;p&gt;可执行和可链接格式(Executable and Linkable Format，缩
    
    </summary>
    
      <category term="C" scheme="http://felixzhang00.github.io/categories/C/"/>
    
    
      <category term="C" scheme="http://felixzhang00.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>jpeg编码学习笔记</title>
    <link href="http://felixzhang00.github.io/2016/12/24/2016-12-24-jpeg%E7%BC%96%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://felixzhang00.github.io/2016/12/24/2016-12-24-jpeg编码学习笔记/</id>
    <published>2016-12-24T12:59:13.000Z</published>
    <updated>2017-01-14T09:32:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>各种图片格式目的是在网络传输和存储的时候使用更少的字节，即起到压缩的作用。在图片格式解码后，无论图片的格式，图片数据都是像素数组。<br>本文将尝试通过JPEG这种图片编码格式的学习，了解图片编码的秘密。</p>
<hr>
<h2 id="JPEG简介"><a href="#JPEG简介" class="headerlink" title="JPEG简介"></a>JPEG简介</h2><p>一张100X100大小的普通图片，如果未经压缩，大概在100x100x4x8bits=0.3MB左右,这也是图片在内存中占用的内存大小。<br>通常JPEG文件相对于原始图像,能够得到1/8的压缩比，如此高的压缩率是如何做到的呢？</p>
<p>JPEG能够获得如此高的压缩比是因为使用了有损压缩技术，所谓有损压缩，就是把原始数据中不重要的部分去掉，以便可以用更小的体积保存。</p>
<p>JPEG编码是基于两个idea，第一个是基于相邻的像素信息是相近的，即空间冗余性，尽量少记录重复的数据来达到压缩的效果。第二个是基于图像信号的频谱特性，图像包含各种频率，大部分为低频频谱，少部分为高频频谱。可以保留包含图像信息较多的低频频谱，舍去包含图像信息较少的高频频谱。而达到图片质量没有可察觉的损伤，又能达到压缩的效果。这也说明了JPEG是有损编码。</p>
<hr>
<h2 id="JPEG的编码过程"><a href="#JPEG的编码过程" class="headerlink" title="JPEG的编码过程"></a>JPEG的编码过程</h2><p>编码流程如下图：</p>
<p><img src="http://ww4.sinaimg.cn/large/8b331ee1gw1fb2c7jxxyaj20eg08d74o.jpg" alt="编码流程示意图"></p>
<hr>
<h3 id="1-色彩空间转换"><a href="#1-色彩空间转换" class="headerlink" title="1.色彩空间转换"></a>1.色彩空间转换</h3><p>将RGB色彩空间转换到其他色彩空间，比如<a href="https://en.wikipedia.org/wiki/YUV" target="_blank" rel="external">YUV</a>色彩空间。<br>出现YUV,主要有两个原因，一个是为了让彩色信号兼容黑白电视机，另外一个原因是为了减少传输的带宽。<br>下图为老电视后面的色差接口。</p>
<p><img src="http://ww3.sinaimg.cn/large/8b331ee1gw1fb24juusowj206u046q3w.jpg" alt="电视色差接口"></p>
<p>YUV中，Y表示亮度，U和V表示色度，总之它是将RGB信号进行了一种处理，根据人对亮度更敏感些，增加亮度的信号，减少颜色的信号，以这样“欺骗”人的眼睛的手段来节省空间。YUV的格式也很多，不过常见的就是422和420格式。</p>
<p>下图为420格式，每四个Y共用一组UV分量，每个YUV分量和RGB一样都用8位来表示，YUV色彩空间就比RGB色彩空间所需的存储空间少一半，数据就被压缩到了一半。</p>
<p><img src="http://ww4.sinaimg.cn/large/8b331ee1gw1fb24kvqketj20aa04n3zt.jpg" alt="Y420"></p>
<hr>
<h3 id="2-离散余弦变换DCT"><a href="#2-离散余弦变换DCT" class="headerlink" title="2.离散余弦变换DCT"></a>2.离散余弦变换DCT</h3><p>简单地说，DCT是傅里叶变换的一种，变换后会得到一个系数。<br>有关DCT的详细介绍可以看这个<a href="https://www.youtube.com/watch?v=Q2aEzeMDHMA" target="_blank" rel="external">视频</a>。</p>
<p>在JPEG压缩过程中，经过颜色空间的转换，每一个色值表示成8X8的图像块，下图为一个色彩域取样块，转化为频率域的DCT系数块：<br><img src="http://ww1.sinaimg.cn/large/8b331ee1gw1fb24n45lgbj20gv03qq3u.jpg" alt="转化为频率域的DCT系数块"></p>
<p>图片经过此步骤会输出一个频率系数矩阵，左上的系数幅度值最大，越往右下，系数的幅度值越小，频率越高。大部分图片信息都在频率域矩阵左上区域，右下几乎不含有图片信息，甚至只含杂波。<br>注意：转换后的DCT系数块矩阵(x,y)处的值并不和转换前的颜色空间矩阵（x,y）处的像素值直接对应。</p>
<p>这一步骤没有压缩作用，它目的是为下一步骤找低频和高频区域，也就是找出留下的区域和舍去的区域。</p>
<hr>
<h3 id="3-量化"><a href="#3-量化" class="headerlink" title="3.量化"></a>3.量化</h3><p>此步是将上步求得的DCT系数的简化的过程，利用人眼对高频部分不敏感的特性来舍去高频部分。<br>这里有两张表分别对亮度和色度做量化处理。</p>
<p>标准亮度量化表：<br><img src="http://ww3.sinaimg.cn/large/8b331ee1gw1fb24qq7yq0j20sw0b8t9r.jpg" alt="标准亮度量化表"></p>
<p>标准色度量化表：<br><img src="http://ww2.sinaimg.cn/large/8b331ee1gw1fb24rftccuj20sy0b8gmn.jpg" alt="标准色度量化表"></p>
<p>量化表是控制 JPEG 压缩比的关键。<br>DCT系数矩阵中的不同位置的值代表了图像数据中不同频率的分量，这两张表中的数据是根据人眼对不同频率的敏感程度的差别所积累下的经验制定的。这个步骤除掉了一些高频量, 损失了很多细节. 但事实上人眼对高空间频率远没有低频敏感.所以处理后的视觉损失很小。<br>另一个重要原因是所有的图片的点与点之间会有一个色彩过渡的过程. 大量的图象信息被包含在低空间频率中。 经过量化处理后, 在高空间频率段, 将出现大量连续的零。</p>
<p>把上面的DCT系数块通过量化后的结果如下图，其中第一个数-26是直流DC部分，它是一块图象样本的平均值，包含了原始8x8图像块中的很多能量，其余的是交流AC部分。<br>计算方法为：频率系数矩阵的数值除以对应量化表位置上的数值，并四舍五入到最近的整数。<br><img src="http://ww4.sinaimg.cn/large/8b331ee1gw1fb24usawejg20ie034t8o.gif" alt="量化过程"></p>
<p>解码的时候，反量化步骤会乘回量化表相应值，但是四舍五入导致低频有所损失，高频0字段被舍弃。此步为有损运算，会导致图像质量变低。所以说JPEG是有损编码。</p>
<hr>
<h3 id="4-zig-zag游程编码"><a href="#4-zig-zag游程编码" class="headerlink" title="4.zig-zag游程编码"></a>4.zig-zag游程编码</h3><p>量化后的数据还可以进行简化，更大程度的去压缩。</p>
<p><img src="http://ww2.sinaimg.cn/large/8b331ee1gw1fbqaat9zbqj20ac07vgmd.jpg" alt="zig-zag表"></p>
<p>根据上面的zig-zag表重排数据的过程：</p>
<p><img src="http://ww4.sinaimg.cn/large/8b331ee1gw1fb255f7vvsj208s05mq38.jpg" alt="zig-zag过程"></p>
<p>根据ZigZag表的规则对量化后的数据进行重排后的结果中可以看到出现连续的多个0，这样有利于进行游程编码。</p>
<hr>
<h3 id="5-范式Huffman编码"><a href="#5-范式Huffman编码" class="headerlink" title="5.范式Huffman编码"></a>5.范式Huffman编码</h3><h4 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h4><p>huffman编码的基本原理是根据数据中元素的使用频率，调整元素的编码长度，以得到更高的压缩比。<br>举个例子，比如下面这段数据</p>
<p><code>AABCBABBCDBBDDBAABDBBDABBBBDDEDBD</code></p>
<p>这段数据里面包含了33个字符，每种字符出现的次数统计如下</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
<th>E</th>
</tr>
</thead>
<tbody>
<tr>
<td>次数</td>
<td>6</td>
<td>15</td>
<td>2</td>
<td>9</td>
<td>1</td>
<td></td>
</tr>
</tbody>
</table>
<p>如果我们用我们常见的定长编码，因为有5个文字，可以用3个bit表示，那么这段文字共需要3*33 = 99个bit来保存</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
<th>E</th>
</tr>
</thead>
<tbody>
<tr>
<td>编码</td>
<td>001</td>
<td>010</td>
<td>011</td>
<td>100</td>
<td>101</td>
<td></td>
</tr>
</tbody>
</table>
<p>如果根据字符出现的概率，使用如下的编码</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
<th>E</th>
</tr>
</thead>
<tbody>
<tr>
<td>编码</td>
<td>100</td>
<td>0</td>
<td>1110</td>
<td>10</td>
<td>1111</td>
<td></td>
</tr>
</tbody>
</table>
<p>那么这段文字共需要3x6 + 1x15 + 4x2 + 2x9 + 4x1 = 63bit，压缩比为63%。 是较短的编码不能够是较长编码的前缀，比如上面这个编码，就是由下面的这颗二叉树生成的。<br>哈弗曼编码一般都是使用二叉树来生成的，频率会高的数据对应的树节点的位置越高。这样得到的编码符合前缀规则，也就是较短的编码不能够是较长编码的前缀。</p>
<p><img src="http://ww4.sinaimg.cn/large/8b331ee1gw1fb25jyerm4j207h0760sr.jpg" alt="哈夫曼树"></p>
<h4 id="Huffman编码在JPEG中"><a href="#Huffman编码在JPEG中" class="headerlink" title="Huffman编码在JPEG中"></a>Huffman编码在JPEG中</h4><p>假设在JPEG量化处理后的数据为：<br><code>35,7,0,0,0,-6,-2,0,0,-9,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8,0,0,0,…,0</code></p>
<p>根据<a href="https://en.wikipedia.org/wiki/Run-length_encoding" target="_blank" rel="external">RLE</a>编码(游程编码)规则<br>1、用固定的4位来存储重复的数量，所以最多重复内容可以记录数量为15，超过15次要进行分段处理；<br>2、只将0作为重复的内容，每个数值记录前面有多少重复的0，末尾如果都是0用EOB作为代表；<br>3、此步不包含第一个数值，第一个数为直流系数，此步只处理交流系数。<br>得到处理结果：</p>
<p><img src="http://ww1.sinaimg.cn/large/8b331ee1gw1fb262lkvzaj21kw048ab4.jpg" alt="RLE编码"></p>
<p>为了提高储存效率, JPEG 里并不直接保存数值, 而是将数值按位数分成 16 组,JPEG提供了一张标准的码表用于对这些数字编码<br><img src="http://ww1.sinaimg.cn/large/8b331ee1gw1fbqabfrjzej20p70bvq4z.jpg" alt="标准码表"><br>举例来说，第3个单元中的“-6”这个数字，在表中的位置是长度为3的那组，所对应的bit码是“001”，由于这种编码附带长度信息，所以我们的数据变成了如下的格式。<br><img src="http://ww4.sinaimg.cn/large/8b331ee1gw1fb265nsj1aj21kw065jt8.jpg" alt="BIT编码"> </p>
<p>对于括号前面的数字的编码，分成DC编码和AC编码。<br>下表是针对直流(DC)部分即第一个数字的哈弗曼表，由于直流部分没有前置的0，所以取值范围在0~15之间。</p>
<p><img src="http://ww1.sinaimg.cn/large/8b331ee1gw1fbqabrz6wpj208d07vt8z.jpg" alt=""></p>
<p>对于其余的交流（AC）部分，取值范围在0~255，哈夫曼表如下：</p>
<p><img src="http://ww2.sinaimg.cn/large/8b331ee1gw1fbqab7b25sj206l09gjrr.jpg" alt=""></p>
<p>完整个编码过程如下表，最终的数据使用10个字节保存了原本长度为64字节的数据，JPEG的压缩算法完成。<br><img src="http://ww2.sinaimg.cn/large/8b331ee1gw1fb268ej9k9j21kw09yn0a.jpg" alt=""></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://blog.mrriddler.com/2016/07/20/%E5%9B%BE%E7%89%87%E4%B9%8B%E6%97%85/" target="_blank" rel="external">http://blog.mrriddler.com/2016/07/20/%E5%9B%BE%E7%89%87%E4%B9%8B%E6%97%85/</a></li>
<li><a href="http://thecodeway.com/blog/?p=69" target="_blank" rel="external">http://thecodeway.com/blog/?p=69</a></li>
<li><a href="http://www.impulseadventure.com/photo/jpeg-huffman-coding.html" target="_blank" rel="external">http://www.impulseadventure.com/photo/jpeg-huffman-coding.html</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/linux/l-cn-jpeg/index.html" target="_blank" rel="external">http://www.ibm.com/developerworks/cn/linux/l-cn-jpeg/index.html</a></li>
<li>《数字图像处理编程入门》</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;各种图片格式目的是在网络传输和存储的时候使用更少的字节，即起到压缩的作用。在图片格式解码后，无论图片的格式，图片数据都是像素数组。&lt;br&gt;本文将尝试通过JPEG这种图片编码格式的学习，了解图片编码的秘密。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;JPEG简介&quot;&gt;&lt;a href=&quot;
    
    </summary>
    
      <category term="图形学" scheme="http://felixzhang00.github.io/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
      <category term="图形学" scheme="http://felixzhang00.github.io/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
  </entry>
  
</feed>
