<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[代码浏览工具OpenGrok]]></title>
      <url>http://felixzhang00.github.io/2016/12/25/2016-12-25-%E4%BB%A3%E7%A0%81%E6%B5%8F%E8%A7%88%E5%B7%A5%E5%85%B7OpenGrok/</url>
      <content type="html"><![CDATA[<p><a href="https://opengrok.github.io/OpenGrok/" target="_blank" rel="external">OpenGrok</a>是一款强大的跨平台代码阅读工具，许多在线源码查看网站都是使用它来搭建的，比如著名的Android在线源码查看网站<a href="http://androidxref.com/" target="_blank" rel="external">androidxref</a>.</p>
<p><br><br><br><br><br></p>
<h2 id="OpenGrok特性"><a href="#OpenGrok特性" class="headerlink" title="OpenGrok特性"></a>OpenGrok特性</h2><p>OpenGrok 提供如下特性：</p>
<ul>
<li><p>1.快速搜索代码的引擎</p>
<p>  搜索全文、定义、符号、文件路径和修改历史</p>
<p>  搜索任意指定子目录（分层搜索）</p>
<p>  增量更新索引文件</p>
</li>
<li><p>2.支持类似 Google 的查询语法，比如 path:Makefile defs:target</p>
<p>  搜索日期范围内修改的文件</p>
<p>  支持使用通配符搜索，如 * 表示多个字符，? 表示单个字符</p>
<p>  在搜索结果中展示匹配行</p>
</li>
<li><p>3.一个 Web 只读版的版本历史查看界面</p>
<p>  文件的修改日志</p>
<p>  文件在两个版本间的 diff</p>
<p>  文件夹的历史记录</p>
</li>
<li><p>4.带语法高亮的交叉引用显示，可以使用 CSS 自定义样式</p>
<p>  可以开发插件支持新的语言和版本控制系统</p>
<p>  已经支持的语言： <a href="https://link.zhihu.com/?target=https%3A//github.com/OpenGrok/OpenGrok/wiki/Supported-Languages-and-Formats" target="_blank" rel="external">Supported Languages and Formats</a></p>
<p>  已经支持的版本控制系统：<a href="https://link.zhihu.com/?target=https%3A//github.com/OpenGrok/OpenGrok/wiki/Supported-Revision-Control-Systems" target="_blank" rel="external">Supported Revision Control Systems</a></p>
</li>
</ul>
<p><br><br><br><br><br></p>
<h2 id="在macOS平台搭建OpenGrok"><a href="#在macOS平台搭建OpenGrok" class="headerlink" title="在macOS平台搭建OpenGrok"></a>在macOS平台搭建OpenGrok</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>1.安装tomcat</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ brew install tomcat</div></pre></td></tr></table></figure>
<p>2.安装ctags</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ brew install ctags</div></pre></td></tr></table></figure>
<p>3.安装OpenGrok</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ wget -O - http://java.net/projects/opengrok/downloads/download/opengrok-0.12.1.tar.gz | tar xvz</div></pre></td></tr></table></figure>
<h3 id="开启tomcat"><a href="#开启tomcat" class="headerlink" title="开启tomcat"></a>开启tomcat</h3><p>方法1：cd到tomcat所在目录，然后执行命令，<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ catalina start </div><div class="line">$ open http://localhost:8080/<span class="built_in">source</span></div></pre></td></tr></table></figure></p>
<p>方法2：下载macOS下的GUI程序<a href="https://www.macupdate.com/app/mac/18706/tomcat-controller" target="_blank" rel="external">TomcatController</a><br>配置tomcat所在目录。<br><img src="http://ww3.sinaimg.cn/large/8b331ee1gw1fb2vmdecmpj217c0i6gpb.jpg" alt=""></p>
<h3 id="开启openGrok项目"><a href="#开启openGrok项目" class="headerlink" title="开启openGrok项目"></a>开启openGrok项目</h3><p>openGrok其实就是一个webapp<br><img src="http://ww3.sinaimg.cn/large/8b331ee1gw1fb2vobc954j21kw09saf1.jpg" alt=""></p>
<h3 id="导入项目"><a href="#导入项目" class="headerlink" title="导入项目"></a>导入项目</h3><p>比如导入ffmpeg，在opengrok目录下创建一个local_src文件夹，把ffmpeg文件夹通过软引用的方式链到local_src下的src目录，这样就能让opengrok找到ffmpeg的代码了。<br><img src="http://ww2.sinaimg.cn/large/8b331ee1gw1fb2vt7txidj21kw0cx42c.jpg" alt=""></p>
<h3 id="建立索引"><a href="#建立索引" class="headerlink" title="建立索引"></a>建立索引</h3><p><img src="http://ww2.sinaimg.cn/large/8b331ee1gw1fb2vtrtcuwj216g03476a.jpg" alt=""></p>
<h3 id="打开浏览器"><a href="#打开浏览器" class="headerlink" title="打开浏览器"></a>打开浏览器</h3><p>访问 <a href="http://localhost:8080/source" target="_blank" rel="external">http://localhost:8080/source</a> 就能看到代码了。<br><img src="http://ww1.sinaimg.cn/large/8b331ee1gw1fb2vuwcxfej21gc0aw3zw.jpg" alt=""></p>
<p><img src="http://ww2.sinaimg.cn/large/8b331ee1gw1fb2vv6s7voj21kw1d3aoa.jpg" alt=""></p>
<hr>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://blog.simplypatrick.com/2015/01/16/opengrok-on-mac-osx/" target="_blank" rel="external">http://blog.simplypatrick.com/2015/01/16/opengrok-on-mac-osx/</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/24369747" target="_blank" rel="external">https://zhuanlan.zhihu.com/p/24369747</a></p>
<p><a href="https://github.com/OpenGrok/OpenGrok/wiki/Features" target="_blank" rel="external">https://github.com/OpenGrok/OpenGrok/wiki/Features</a></p>
<p><a href="http://bytesthink.com/blog/?p=184" target="_blank" rel="external">http://bytesthink.com/blog/?p=184</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[ELF文件装载链接过程及hook原理]]></title>
      <url>http://felixzhang00.github.io/2016/12/24/2016-12-24-ELF%E6%96%87%E4%BB%B6%E8%A3%85%E8%BD%BD%E9%93%BE%E6%8E%A5%E8%BF%87%E7%A8%8B%E5%8F%8Ahook%E5%8E%9F%E7%90%86/</url>
      <content type="html"><![CDATA[<h2 id="ELF文件格式解析"><a href="#ELF文件格式解析" class="headerlink" title="ELF文件格式解析"></a>ELF文件格式解析</h2><p>可执行和可链接格式(Executable and Linkable Format，缩写为ELF)，常被称为ELF格式，在计算机科学中，是一种用于执行档、目的档、共享库和核心转储的标准文件格式。</p>
<p>ELF文件主要有四种类型：</p>
<ul>
<li>可重定位文件（Relocatable File） 包含适合于与其他目标文件链接来创建可执行文件或者共享目标文件的代码和数据。</li>
<li>可执行文件（Executable File） 包含适合于执行的一个程序，此文件规定了 exec() 如何创建一个程序的进程映像。</li>
<li>共享目标文件（Shared Object File） 包含可在两种上下文中链接的代码和数据。首先链接编辑器可以将它和其它可重定位文件和共享目标文件一起处理，生成另外一个目标文件。其次，动态链接器（Dynamic Linker）可能将它与某个可执行文件以及其它共享目标一起组合，创建进程映像。</li>
</ul>
<p>以一个简单的目标文件为例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">int global_init_var = 84;</div><div class="line">int global_uninit_var;</div><div class="line">void func1(int i)</div><div class="line">&#123;</div><div class="line">    printf(&quot;%d\n&quot;,i);</div><div class="line">&#125;</div><div class="line">int main(void)</div><div class="line">&#123;</div><div class="line">    char *str = &quot;hello&quot;;</div><div class="line">    static int static_var = 85;</div><div class="line">    static int static_var2;</div><div class="line">    int a = 1;</div><div class="line">    int b;</div><div class="line">    func1(static_var + static_var2 + a + b);</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gcc -c SimpleSection.c</div></pre></td></tr></table></figure>
<h3 id="ELF文件结构"><a href="#ELF文件结构" class="headerlink" title="ELF文件结构"></a>ELF文件结构</h3><p><img src="http://ww2.sinaimg.cn/mw690/8b331ee1gw1f92kqr2mfoj20ty14k76x.jpg" alt="ELF文件结构"></p>
<h3 id="链接视图和执行视图"><a href="#链接视图和执行视图" class="headerlink" title="链接视图和执行视图"></a>链接视图和执行视图</h3><p>ELF文件在磁盘中和被加载到内存中并不是完全一样的，ELF文件提供了两种视图来反映这两种情况:链接视图和执行视图。顾名思义，链接视图就是在链接时用到的视图，而执行视图则是在执行时用到的视图。<br><img src="http://ww4.sinaimg.cn/mw690/8b331ee1gw1f92kvnpkstj20bz06fwf8.jpg" alt="链接视图和执行视图"></p>
<p>程序头部表(Program Header Table)，如果存在的话，告诉系统如何创建进程映像。<br>节区头部表(Section Header Table)包含了描述文件节区的信息，比如大小，偏移等。</p>
<h3 id="ELF文件头（ELF-Header）"><a href="#ELF文件头（ELF-Header）" class="headerlink" title="ELF文件头（ELF Header）"></a>ELF文件头（ELF Header）</h3><p>定义了ELF魔数、硬件平台等、<br>入口地址、程序头入口和长度、<br>段表的位置和长度及段的数量、<br>段表字符串表（.shstrtab）所在的段在段表中的下标。</p>
<p>可以在”/usr/include/elf.h”中找到它的定义（Elf32_Ehdr）。<br>ELF各个字段的说明:</p>
<p><img src="http://ww2.sinaimg.cn/mw690/8b331ee1gw1f92kwlnz2ej20ht0snqbv.jpg" alt=""></p>
<h3 id="段表-Section-Header-Table"><a href="#段表-Section-Header-Table" class="headerlink" title="段表(Section Header Table)"></a>段表(Section Header Table)</h3><p>描述了各个段的信息，比如每个段的段名、段的长度、在文件中的偏移、读写权限及段的其它属性。<br>段表的结构是一个以Elf32_Shdr结构体（段描述符）为元素的数组。<br>每个Elf32_Shdr结构体对应一个段。<br>使用readelf工具查看ELF文件的段:<br><img src="http://ww4.sinaimg.cn/mw690/8b331ee1gw1f92kx9tdv3j21kw0sfak2.jpg" alt=""></p>
<p><strong>段描述符（Elf32_Shdr）</strong>的各个成员及含义：<br><img src="http://ww4.sinaimg.cn/large/8b331ee1gw1f92kyt2f0gj21kw1oq4j0.jpg" alt=""></p>
<p><strong>段的类型(sh_type)</strong><br>对于编译器和链接器，主要决定段的属性的是段的类型(sh_type)和段的标志位(shflags)。段的类型相关常量以SHT开头，列举如下表。<br><img src="http://ww3.sinaimg.cn/large/8b331ee1gw1f92l0g93grj20k80bg0vq.jpg" alt=""></p>
<p><strong>段的标志位(sh<em>flag)</em></strong>表示该节在进程虚拟地址空间中的属性，比如是否可写，是否可执行等。相关常量以SHF开头，如下表：<br><img src="http://ww1.sinaimg.cn/large/8b331ee1gw1f92l38ufjqj20k504sjsn.jpg" alt=""></p>
<p><strong>段的链接信息(sh_link、sh_info)</strong> 如果节的类型是和链接相关的，比如重定位表、符号表等，那么sh_link和sh_info两个成员包含的意义如下。对于其他段，这两个成员没有意义。<br><img src="http://ww4.sinaimg.cn/large/8b331ee1gw1f92l3seot7j20kd06babi.jpg" alt=""></p>
<h3 id="代码段-text"><a href="#代码段-text" class="headerlink" title="代码段(.text)"></a>代码段(.text)</h3><p>使用objdump工具查看代码段的内容，”-d”参数将所有包含指令的段反汇编。<br><img src="http://ww1.sinaimg.cn/mw690/8b331ee1gw1f92l64fa4ej21b41q2114.jpg" alt=""></p>
<h3 id="数据段-data-和只读数据段-rodata"><a href="#数据段-data-和只读数据段-rodata" class="headerlink" title="数据段(.data)和只读数据段(.rodata)"></a>数据段(.data)和只读数据段(.rodata)</h3><p>.data段保存的是那些已经初始化了的全局静态变量和局部静态变量。前面SimpleSection.c代码里面一共有两个这样的变量，都是int类型的，一共刚好8字节。<br>在SimpleSection.c里在调用”printf”的时候，用到了一个字符串常量”%d\n”,它是一种只读数据，所以被放到了”.rodata”段。<br><img src="http://ww2.sinaimg.cn/mw690/8b331ee1gw1f92l6sfdb3j21ei0kmmzk.jpg" alt=""></p>
<h3 id="BSS段-bss"><a href="#BSS段-bss" class="headerlink" title="BSS段(.bss)"></a>BSS段(.bss)</h3><p>.bss段存放的未初始化的全局变量和局部静态变量。.bss段不占磁盘空间。<br><img src="http://ww4.sinaimg.cn/mw690/8b331ee1gw1f92l7ea9guj21eo0ao0ti.jpg" alt=""></p>
<h3 id="字符串表（-strtab）"><a href="#字符串表（-strtab）" class="headerlink" title="字符串表（.strtab）"></a>字符串表（.strtab）</h3><p>在ELF文件中，会用到很多字符串，比如节名，变量名等。所以ELF将所有的字符串集中放到一个表里，每一个字符串以’\0’分隔，然后使用字符串在表中的偏移来引用字符串。<br>比如下面这样：<br><img src="http://ww2.sinaimg.cn/mw690/8b331ee1gw1f92l7t2tyrj20k903fgm5.jpg" alt=""><br>那么偏移与他们对用的字符串如下表:<br><img src="http://ww2.sinaimg.cn/mw690/8b331ee1gw1f92l81n2y1j20k7043jrs.jpg" alt=""><br>这样在ELF中引用字符串只需要给出一个数组下标即可。字符串表在ELF也以段的形式保存，常见的段名为”.strtab”或”.shstrtab”。这两个字符串表分别为字符串表(String Table)和段表字符串表(Header String Table)，字符串表保存的是普通的字符串，而段表字符串表用来保存段表中用到的字符串，比如段名。</p>
<h3 id="符号表（-symtab）"><a href="#符号表（-symtab）" class="headerlink" title="符号表（.symtab）"></a>符号表（.symtab）</h3><p>在链接的过程中需要把多个不同的目标文件合并在一起，不同的目标文件相互之间会引用变量和函数。在链接过程中，我们将函数和变量统称为符号，函数名和变量名就是符号名。<br>每一个目标文件中都有一个相应的符号表(System Table)，这个表里纪录了目标文件所用到的所有符号。每个定义的符号都有一个相应的值，叫做符号值(Symbol Value)，对于变量和函数，符号值就是它们的地址。<br>符号表是一个Elf32_Sym(32位)的数组，每个Elf32_Sym对应一个符号。这个数组的第一个元素，也就是下标为0的元素为无效的”未定义”符号。<br>他们的定义如下：<br><img src="http://ww1.sinaimg.cn/mw690/8b331ee1gw1f92l8p5639j20ku06t768.jpg" alt=""></p>
<p><strong>符号类型和绑定信息(st_info)</strong><br>该成员的低4位标识符号的类型(Symbol Type)，高28位标识符号绑定信息(Symbol Binding)，如下表所示。<br><img src="http://ww2.sinaimg.cn/mw690/8b331ee1gw1f92l9hsyp1j20kf04rwf9.jpg" alt=""><br><img src="http://ww2.sinaimg.cn/mw690/8b331ee1gw1f92l9o0v6dj20k907575x.jpg" alt=""><br><strong>符号所在段(st_shndx)</strong><br>如果符号定义在本目标文件中，那么这个成员表示符号所在段在段表中的下表，但是如果符号不是定义在本目标文件中，或者对于有些特殊符号，sh_shndx的值有些特殊。如下：<br><img src="http://ww3.sinaimg.cn/mw690/8b331ee1gw1f92la2n675j20kk07dq4r.jpg" alt=""></p>
<p><strong>符号值(st_value)</strong><br>每个符号都有一个对应的值。主要分下面几种情况：</p>
<ul>
<li>如果符号不是”COMMON”类型的(即st_shndx不为SHN_COMMON)，则st_value表示该符号在段中的偏移，即符号所对应的函数或变量位于由st_shndx指定的段，偏移st_value的位置。比如SimpleSection中的”func1”，”main”和”global_init_var”。</li>
<li>在目标文件中，如果符号是”COMMON”类型(即st_shndx为SHN_COMMON)，则st_value表示该符号的对齐属性。比如SimleSection中的”global_uninit_var”。</li>
<li>在可执行文件中，st_value表示符号的虚拟地址。</li>
</ul>
<p>下图为使用readelf工具来查看ELF文件的符号:<br><img src="http://ww3.sinaimg.cn/mw690/8b331ee1gw1f92lb4pncvj21jm0rgtea.jpg" alt=""><br>比如，Num13行指的是符号表中的第13个元素，符号名为main，它是函数类型，定义在第一个段（即.text段）的第001b偏移处，大小为64字节。</p>
<h3 id="重定位表-rel-text"><a href="#重定位表-rel-text" class="headerlink" title="重定位表(.rel.text)"></a>重定位表(.rel.text)</h3><p>SimpleSection.o中有一个叫”.rel.text”的段，它的类型(sh_type)为”SHT_REL”，也就是说它是一个重定位表。链接器在处理目标文件时，需要对目标文件中的某些部位进行重定位，即代码段和数据中中那些绝对地址引用的位置。对于每个需要重定位的代码段或数据段，都会有一个相应的重定位表。比如”.rel.text”就是针对”.text”的重定位表，”.rel.data”就是针对”.data”的重定位表。</p>
<hr>
<h2 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h2><p>这节以下面两个文件为例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">/* a.c */</div><div class="line">extern int shared;</div><div class="line">int main()&#123;</div><div class="line">    int a = 100;</div><div class="line">    swap(&amp;a,&amp;shared);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">/* b.c */</div><div class="line">int shared = 1;</div><div class="line">void swap(int* a, int* b)&#123;</div><div class="line">    *a ^= *b ^= *a ^= *b;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当我们有两个目标文件时，如何将他们链接起来形成一个可执行文件？<br>对于多个输入目标文件，链接器如何将它们的各个段合并到输出文件？输出文件中的空间如何更配给输入文件？<br>下图为现在链接器采用的空间分配策略。<br><img src="http://ww1.sinaimg.cn/mw690/8b331ee1gw1f92lhyc2ugj2124138dkb.jpg" alt=""></p>
<p>整个链接过程分两步：</p>
<ul>
<li>第一步 空间与地址分配 扫描所有的输入目标文件，并且获得它们的各个段的长度、属性和位置，并且将输入目标文件中的符号表中所有的符号定义和符号引用收集起来，统一放到一个全局符号表中。</li>
<li>第二步 符号解析与重定位 使用第一步中收集到的信息，读取输入文件中段的数据、重定位信息，并且进行符号解析与重定位、调整代码中的地址等</li>
</ul>
<p>使用ld链接器将”a.o”和”b.o”链接起来：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ld a.o b.o -e main -o ab</div></pre></td></tr></table></figure></p>
<p>查看链接前后各个段的属性<br><img src="http://ww4.sinaimg.cn/mw690/8b331ee1gw1f92ljdpqkgj21b418244f.jpg" alt=""><br>VMA表示虚拟地址，LMA表示加载地址，正常情况下这两个值应该一样。</p>
<p>整个链接过程前后，目标文件各段的分配、程序虚拟地址:<br><img src="http://ww1.sinaimg.cn/mw690/8b331ee1gw1f92ljxvmqmj21hq10ygo3.jpg" alt=""><br>在Linux下，ELF可执行未见默认从地址0x08048000开始分配。</p>
<h3 id="符号解析与重定位"><a href="#符号解析与重定位" class="headerlink" title="符号解析与重定位"></a>符号解析与重定位</h3><p>编译器在将”a.c”编译成指令时，它如何访问”shared”变量？如何调用”swap”函数？<br><strong>重定位表(Relocation Tabel)</strong>专门用来保存与重定位相关的信息，链接器根据它知道哪些指令时要被调整的，以及如何调整。<br>对于32位的Intel x86系列处理器来说，重定位表的结构是一个Elf_32Rel结构的数组，每个数组元素对应一个重定位入口。定义如下：<br><img src="http://ww4.sinaimg.cn/mw690/8b331ee1gw1f92lm64qwqj21j00kwtec.jpg" alt=""></p>
<p>可以使用objdump来查看目标文件的重定位表：<br><img src="http://ww4.sinaimg.cn/mw690/8b331ee1gw1f92lmerm9rj20oa0bu3za.jpg" alt=""></p>
<p>将”a.o”的代码段反汇编可以看到，此时编译器并不知道“shared”的地址，暂时把地址0看做”shared”的地址。<br>0xE8是一条近址相对位移调用指令，后面4个字节就是被调用函数的相对于调用指令的下一条指令的偏移量。<br>此处”swap”函数的地址是0x2b-4=0x27,可以看出0xfffffffc也是一个临时地址。<br><img src="http://ww2.sinaimg.cn/mw690/8b331ee1gw1f92lmrq7o2j21900yagpl.jpg" alt=""></p>
<p><strong>指令修正方式</strong><br><img src="http://ww3.sinaimg.cn/mw690/8b331ee1gw1f92lngo4gzj21iu0fsjuq.jpg" alt=""></p>
<p>指令修复的结果<br><img src="http://ww2.sinaimg.cn/mw690/8b331ee1gw1f92lnnaqsej21d411ydlb.jpg" alt=""></p>
<hr>
<h2 id="可执行文件的装载与进程"><a href="#可执行文件的装载与进程" class="headerlink" title="可执行文件的装载与进程"></a>可执行文件的装载与进程</h2><p>程序执行时所需要的指令和数据必需在内存中才能够正常运行。<br>页映射将内存和所有磁盘中的数据和指令按照“页（Page）”为单位划分成若干个页，以后所有的装载和操作的单位就是页。</p>
<p>进程的建立需要做下面三件事情：</p>
<ul>
<li>创建一个独立的虚拟地址空间</li>
<li>读取可执行文件头，并且建立虚拟空间与可执行文件的映射关系。</li>
<li>将CPU的指令寄存器设置成可执行文件的入口地址，启动运行。</li>
</ul>
<p>对于第2步，当操作系统捕获到缺页错误时，它应该知道程序当前所需的页在可执行文件中的哪一个位置。<br>这种映射关系是保存在操作系统内部的一个数据结构<strong>VMA</strong>。<br>例如下图中，操作系统创建进程后，会在进程相应的数据结构中设置有一个.text段的VMA：它在虚拟空间中的地址为0x08048000~0x08049000，它对应ELF文件中偏移为0的.text，它的属性为只读，还有一些其他的属性。<br><img src="http://ww4.sinaimg.cn/mw690/8b331ee1gw1f92lokbzk3j20wi0lo0u7.jpg" alt=""></p>
<p><strong>页错误</strong><br>在上面的例子中，程序的入口地址为0x08048000，当CPU开始打算执行这个地址的指令时，发现页面0x08048000~0x08049000（虚拟地址）是个空页面，于是它就认为这是一个页错误。CPU将控制权交给操作系统，操作系统将查询虚拟空间与可执行文件的映射关系表，找到空页面所在的VMA，计算相应的页面在可执行文件中的偏移，然后在物理内存中分配一个物理页面，将进程中该虚拟页与分配的物理页之间建立映射关系，然后把控制权再还给进程，进程从刚才页错误的位置重新开始执行。</p>
<h3 id="链接视图和执行视图-1"><a href="#链接视图和执行视图-1" class="headerlink" title="链接视图和执行视图"></a>链接视图和执行视图</h3><p>以下面的程序为例。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">使用静态链接的方式将其编译成可执行文件：</div><div class="line">$gcc -static SectionMapping.c -o SectionMapping.elf</div><div class="line">**/</div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</div><div class="line">    &#123;</div><div class="line">        sleep(<span class="number">1000</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>下面的elf文件被重新划分成了三个部分，有一些段被归入可读可执行的，他们被统一映射到一个CODE VMA；另一部分段是可读可写的，它们被映射到了DATA VMA；还有一些段在程序执行时没有用，所以不需要映射。<br>ELF与Linux进程虚拟空间映射关系（一个常见进程的虚拟空间）如下图。<br><img src="http://ww2.sinaimg.cn/mw690/8b331ee1gw1f92lpqlsm9j212y1fkaem.jpg" alt=""></p>
<h4 id="程序头表-Program-Header-Table"><a href="#程序头表-Program-Header-Table" class="headerlink" title="程序头表(Program Header Table)"></a>程序头表(Program Header Table)</h4><p>用来保存“Segment”的信息,描述了ELF文件该如何被操作系统映射到虚拟空间。因为ELF目标文件不需要被装载，所以它没有程序头表，而ELF的可执行文件和共享库文件都有。<br>使用readelf查看程序头表。<br><img src="http://ww1.sinaimg.cn/mw690/8b331ee1gw1f92lreiga6j21380me0x3.jpg" alt=""></p>
<p>跟段表结构一样，程序头表也是一个结构体数组，其结构体用Elf32_Phdr表示。<br>下表是Elf32_Phdr结构的各个成员的基本含义。<br><img src="http://ww2.sinaimg.cn/mw690/8b331ee1gw1f92lrncz74j21jw0vwgtx.jpg" alt=""></p>
<h3 id="堆和栈"><a href="#堆和栈" class="headerlink" title="堆和栈"></a>堆和栈</h3><p>VMA除了被用来映射可执行文件中的各个”segment”以外，操作系统通过使用VMA来对进程的地址空间进行管理，包括堆和栈。<br>在Linux下，可以通过查看”/proc”来查看进程的虚拟空间分布：<br><img src="http://ww4.sinaimg.cn/mw690/8b331ee1gw1f92ltj5czaj21120hkwi3.jpg" alt=""><br>我们可以看到进程中有5个VMA,只有前两个是映射到可执行文件中的两个Segment。另外三个段的文件所在设备主设备号及文件节点号都是0，则表示他们没有映射到文件中，这种VMA叫做匿名虚拟内存区域。另外有一个很特殊的VMA叫“vdso”，它的地址已经位于内核空间了（即大于0xC0000000的地址），事实上它是一个内核的模块，进程可以通过访问这个VMA来跟内核进行一些通信。<br>操作系统通过给进程空间划分出一个个VMA来管理进程的虚拟空间；基本原则是将相同权限属性的、有相同映像文件的映射成一个VMA。</p>
<hr>
<h2 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h2><p>以下面的代码为例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">/* Lib.h */</div><div class="line">#ifndef LIB_H</div><div class="line">#define LIB_H</div><div class="line">void foobar(int i);</div><div class="line">#endif</div><div class="line"></div><div class="line">/* Lib.c */</div><div class="line">#include &lt;stdio.h&gt;</div><div class="line">void foobar(int i)&#123;</div><div class="line">    printf(&quot;Printing from Lib.so %d\n&quot;,i);</div><div class="line">    sleep(-1);</div><div class="line">&#125;</div><div class="line"></div><div class="line">/* Program1.c */</div><div class="line">#include &quot;Lib.h&quot;</div><div class="line">int main()&#123;</div><div class="line">    foobar(1);</div><div class="line">    return;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/* Program2.c */</div><div class="line">#include &quot;Lib.h&quot;</div><div class="line">int main()&#123;</div><div class="line">    foobar(2);</div><div class="line">    return;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>将Lib.c编译成一个共享对象文件：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$gcc</span> <span class="_">-f</span>PIC -shared -o Lib.so Lib.c</div></pre></td></tr></table></figure>
<p>分别编译链接Program1.c和Program2.c：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$gcc</span> -o Program1 Program1.c ./Lib.so</div></pre></td></tr></table></figure></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$gcc</span> -o Program2 Program2.c ./Lib.so</div></pre></td></tr></table></figure>
<p>查看进程的虚拟地址空间分布：<br><img src="http://ww4.sinaimg.cn/mw690/8b331ee1gw1f92lywp140j20zm0n0grl.jpg" alt=""><br>上图中的ld-2.6.so实际上是Linux下的动态链接器，它与普通共享对象一样被映射到了进程的地址空间，在系统开始运行program1之前，首先会把控制权交给动态链接器，由它完成所有的动态链接工作以后再把控制权交给program1,然后开始执行。</p>
<p>通过readelf查看Lib.so的装载属性：<br><img src="http://ww1.sinaimg.cn/mw690/8b331ee1gw1f9320c9v7lj214q0q8776.jpg" alt=""><br>与普通程序不同的是，动态链接模块的装载地址是从地址0x00000000开始的，这个地址是无效的，共享对象的最终装载地址在编译时时不确定的，而是在装载时，装载器根据当前地址空间的空前情况，动态分配一块足够大小的虚拟地址空间给相应的共享对象。</p>
<h3 id="地址无关代码-PIC"><a href="#地址无关代码-PIC" class="headerlink" title="地址无关代码(PIC)"></a>地址无关代码(PIC)</h3><p>装载时重定位是解决动态模块中有绝对地址引用的方法之一，但是它有一个很大的缺点是指令部分无法在多个进程之间共享，这样就失去了动态链接节省内存的一大优势。我们还需要有一种更好的方法解决共享对象指令中对绝对地址的重定位问题。其实我们的目的很简单，希望程序模块中共享的指令部分在装载时不需要因为装载地址的改变而改变，所以实现的基本思想就是把指令中那些需要被修改的部分分离出来，跟数据部分放在一起，这样指令部分就可以保持不变，而数据部分可以在每个进程中拥有一个副本。</p>
<p>模块中各种类型的地址引用方式如下图：<br><img src="http://ww3.sinaimg.cn/mw690/8b331ee1gw1f9321f0xmjj20hg0go76x.jpg" alt=""></p>
<h4 id="全局偏移表-GOT"><a href="#全局偏移表-GOT" class="headerlink" title="全局偏移表(GOT)"></a>全局偏移表(GOT)</h4><p>用于模块间数据访问，在数据段里建立一个指向外部模块变量的指针数组。当代码需要引用该全局变量时，可以通过GOT中相对用的项间接引用，它的基本机制如下图。<br><img src="http://ww2.sinaimg.cn/mw690/8b331ee1gw1f9321to16sj214w10qwgd.jpg" alt=""><br>当指令中需要访问变量b时，程序会先找到GOT，然后根据GOT中变量所对应的项找到变量的目标地址。每个变量都对应一个4字节的地址，链接器在装载模块的时候会查找每个变量所在的地址，然后填充GOT中的各个项，以确保每个指针所指向的地址正确。由于GOT本身是放在数据段的，所以它可以在模块装载时被修改，并且每个进程都可以有独立的副本，相互不受影响。</p>
<h4 id="延迟绑定-PLT"><a href="#延迟绑定-PLT" class="headerlink" title="延迟绑定(PLT)"></a>延迟绑定(PLT)</h4><p>动态链接下对于全局和静态的数据访问都要进行复杂的GOT定位，然后间接寻址；对于模块间的调用也要先定位GOT，然后再进行间接跳转。程序开始执行时，动态链接器都要进行一次链接工作，会寻找并装载所需的共享对象，然后进行符号查找地址重定位等工作，如此一来，程序的运行速度必定会减慢。</p>
<p>延迟绑定的实现<br>函数第一次被用到时才进行绑定（符号查找、重定位等），如果没有用到则不进行绑定。</p>
<p>GOT 位于 .got.plt section 中，而 PLT 位于 .plt section中。<br>GOT 保存了程序中所要调用的函数的地址，运行一开时其表项为空，会在运行时实时的更新表项。一个符号调用在第一次时会解析出绝对地址更新到 GOT 中，第二次调用时就直接找到 GOT 表项所存储的函数地址直接调用了。<br>printf（）函数的调用过程如下图<br><img src="http://ww3.sinaimg.cn/mw690/8b331ee1gw1f9322tt0r1j20le0dhjss.jpg" alt=""></p>
<h3 id="动态链接的相关结构"><a href="#动态链接的相关结构" class="headerlink" title="动态链接的相关结构"></a>动态链接的相关结构</h3><h4 id="interp段"><a href="#interp段" class="headerlink" title=".interp段"></a>.interp段</h4><p>在动态链接的ELF可执行文件中，有一个专门的段叫做”.interp”段。里面保存的是一个字符串，记录所需动态链接器的路径。<br>从下图可以看出，Android用的动态链接器是linker<br><img src="http://ww1.sinaimg.cn/mw690/8b331ee1gw1f9323mnszoj21j805itco.jpg" alt=""></p>
<h4 id="dynamic段"><a href="#dynamic段" class="headerlink" title=".dynamic段"></a>.dynamic段</h4><p>这个段里保存了动态链接器所需要的基本信息，比如依赖哪些共享对象、动态链接符号表的位置、动态链接重定位表的位置、共享对象初始化代码的地址等。<br>.dynamic段里保存的信息有点像ELF文件头。<br>.dynamic段的结构是由Elf32_Dyn组成的数组。<br>Elf32_Dyn结构由一个类型值加上一个附加的数值或指针，对于不同的类型，后面附加的数值或者指针有着不同的含义。<br><img src="http://ww3.sinaimg.cn/mw690/8b331ee1gw1f932414wnzj21ii0syq9p.jpg" alt=""></p>
<h4 id="动态符号表-dynsym"><a href="#动态符号表-dynsym" class="headerlink" title="动态符号表(.dynsym)"></a>动态符号表(.dynsym)</h4><p>为了表示动态链接模块之间的符号导入导出关系，ELF专门有一个叫做动态符号表的段用来保存这些信息。<br>与”.symtab”不同的是，”.dynsym”只保存了与动态链接相关的符号，对于那些模块内部的符号，比如模块私有变量则不保存。很多时候动态链接模块同时拥有”.dynsym”和”.symtab”两个表，”.symtab”中往往保存了所有符号，包括”.dynsym”中的符号。</p>
<h4 id="动态符号字符串表-dynstr"><a href="#动态符号字符串表-dynstr" class="headerlink" title="动态符号字符串表(.dynstr)"></a>动态符号字符串表(.dynstr)</h4><p>在动态链接时用于保存符号名的字符串表。</p>
<h4 id="符号哈希表-hash"><a href="#符号哈希表-hash" class="headerlink" title="符号哈希表(.hash)"></a>符号哈希表(.hash)</h4><p>由于动态链接下，需要在程序运行时查找符号，为了加快符号的查找过程，往往还有辅助的符号好戏表。<br>用readelf查看elf文件的动态符号表及它的哈希表。<br><img src="http://ww3.sinaimg.cn/mw690/8b331ee1gw1f9324ovvklj211g0n6af4.jpg" alt=""></p>
<h3 id="动态链接重定位表"><a href="#动态链接重定位表" class="headerlink" title="动态链接重定位表"></a>动态链接重定位表</h3><p>在动态链接中，导入符号的地址在运行时才确定，所以需要在运行时将这些导入符号的引用修正，即需要重定位。</p>
<p>“.rel.dyn”段对数据引用的修正，它所修正的位置位于”.got”以及数据段；<br>“.rel.plt”段对函数引用修正，它所修正的位置位于”.got.plt”。<br>用readelf来查看一个动态链接的文件的重定位表：<br><img src="http://ww3.sinaimg.cn/mw690/8b331ee1gw1f93258e2hrj21i00ue7a1.jpg" alt=""><br>R_386_JUMP_SLOT和R_386_GLOB_DAT这两个类型的重定位入口表示，被修正的位置只需要直接填入符号地址即可。<br>比如，printf这个重定位入口，它的类型为R_386_JUMP_SLOT，它的偏移为0x000015d8，它位于”.got.plt”中，下图为其结构。<br><img src="http://ww2.sinaimg.cn/mw690/8b331ee1gw1f9325hfyr7j213q0zitfq.jpg" alt=""><br>当链接器需要进行重定位时，它先查找”printf”的地址，“printf”位于libc.so中。假设链接器在全局符号表里面找到”printf”的地址为0x08801234,那么链接器就会将这个地址填入到”.got.plt”中偏移为0x000015d8的位置中去，从而实现了地址的重定位。<br>R_386_GLOB_DAT是对”.got”的重定位，它跟R_386_JUMP_SLOT的做法一样。</p>
<hr>
<h2 id="hook方案的一种实现方案"><a href="#hook方案的一种实现方案" class="headerlink" title="hook方案的一种实现方案"></a>hook方案的一种实现方案</h2><p>具体实现来自Andrey Petrov的<a href="http://shadowwhowalks.blogspot.com/2013/01/android-hacking-hooking-system.html" target="_blank" rel="external">blog</a>. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line">#include &quot;linker.h&quot;  // get it from bionic</div><div class="line">static unsigned elfhash(const char *_name)  </div><div class="line">&#123;  </div><div class="line">  const unsigned char *name = (const unsigned char *) _name;  </div><div class="line">  unsigned h = 0, g;  </div><div class="line">  while(*name) &#123;  </div><div class="line">    h = (h &lt;&lt; 4) + *name++;  </div><div class="line">    g = h &amp; 0xf0000000;  </div><div class="line">    h ^= g;  </div><div class="line">    h ^= g &gt;&gt; 24;  </div><div class="line">  &#125;  </div><div class="line">  return h;  </div><div class="line">&#125;  </div><div class="line">static Elf32_Sym *soinfo_elf_lookup(soinfo *si, unsigned hash, const char *name)  </div><div class="line">&#123;  </div><div class="line">  Elf32_Sym *s;  </div><div class="line">  Elf32_Sym *symtab = si-&gt;symtab;  </div><div class="line">  const char *strtab = si-&gt;strtab;  </div><div class="line">  unsigned n;  </div><div class="line">  n = hash % si-&gt;nbucket;  </div><div class="line">  for(n = si-&gt;bucket[hash % si-&gt;nbucket]; n != 0; n = si-&gt;chain[n])&#123;  </div><div class="line">    s = symtab + n;  </div><div class="line">    if(strcmp(strtab + s-&gt;st_name, name)) continue;  </div><div class="line">      return s;  </div><div class="line">    &#125;  </div><div class="line">  return NULL;  </div><div class="line">&#125;  </div><div class="line"></div><div class="line">int hook_call(char *soname, char *symbol, unsigned newval) &#123;  </div><div class="line"> soinfo *si = NULL;  </div><div class="line"> Elf32_Rel *rel = NULL;  </div><div class="line"> Elf32_Sym *s = NULL;   </div><div class="line"> unsigned int sym_offset = 0;  </div><div class="line"> if (!soname || !symbol || !newval)  </div><div class="line">    return 0;  </div><div class="line"> si = (soinfo*) dlopen(soname, 0);  </div><div class="line"> if (!si)  </div><div class="line">  return 0;  </div><div class="line"> s = soinfo_elf_lookup(si, elfhash(symbol), symbol);  </div><div class="line"> if (!s)  </div><div class="line">   return 0;  </div><div class="line"> sym_offset = s - si-&gt;symtab;  </div><div class="line"> rel = si-&gt;plt_rel;  </div><div class="line"> /* walk through reloc table, find symbol index matching one we&apos;ve got */  </div><div class="line"> for (int i = 0; i &lt; si-&gt;plt_rel_count; i++, rel++) &#123;  </div><div class="line">  unsigned type = ELF32_R_TYPE(rel-&gt;r_info);  </div><div class="line">  unsigned sym = ELF32_R_SYM(rel-&gt;r_info);  </div><div class="line">  unsigned reloc = (unsigned)(rel-&gt;r_offset + si-&gt;base);  </div><div class="line">  unsigned oldval = 0;  </div><div class="line">  if (sym_offset == sym) &#123;  </div><div class="line">   switch(type) &#123;  </div><div class="line">     case R_ARM_JUMP_SLOT:  </div><div class="line">        /* we do not have to read original value, but it would be good   </div><div class="line">          idea to make sure it contains what we are looking for */  </div><div class="line">        oldval = *(unsigned*) reloc;  </div><div class="line">        *((unsigned*)reloc) = newval;  </div><div class="line">        return 1;  </div><div class="line">     default:  </div><div class="line">        return 0;  </div><div class="line">   &#125;  </div><div class="line">  &#125;  </div><div class="line"> &#125;  </div><div class="line"> return 0;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>用法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hook_call(&quot;libandroid_runtime.so&quot;, &quot;connect&quot;, &amp;my_connect);</div></pre></td></tr></table></figure></p>
<p>1.调用dlopen拿到so的句柄,得到soinfo,它包含了符号表、重定位表、plt表等信息。<br>2.查找需要hook的函数的符号，得到它在符号表中的索引。具体实现是soinfo_elf_lookup函数。</p>
<p><img src="http://ww4.sinaimg.cn/mw690/8b331ee1gw1f932uud83bj207r088mxj.jpg" alt=""></p>
<p>bucket数组包含nbucket个项目，chain数组包含nchain个项目，下标都是从0开始。bucket和chain中都保存了符号表的索引。chain表项和符号表存在对应。符号表项的数目应该和nchain相等，所以符号表的索引也可以用来选取chain表项。哈希函数能够接受符号名并返回一个可以用来计算bucket的索引。如果哈希函数针对某个名字返回了数值x，则bucket[x%nbucket]给出了一个索引y，该索引可用于符号表，也可用于chain表。如果该符号表项不是所需要的，那么chain[y]则给出了具有相同哈希值的下一个符号表项。我们可以沿着chain链一直搜索，直到所选中的符号表项包含了所需要的符号，或者chain项中包含值STN_UNDEF。</p>
<p> 3.遍历plt表，直到匹配第2步中找到的符号索引。<br> 如果是JUMP_SLOT类型（函数调用），替换为新的符号地址（函数指针）。</p>
<hr>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li>《程序员的自我修养》</li>
<li>《深入理解计算机系统》</li>
<li><a href="http://shadowwhowalks.blogspot.com/2013/01/android-hacking-hooking-system.html" target="_blank" rel="external">Andrey Petrov’s blog</a></li>
<li><a href="https://www.apriorit.com/dev-blog/181-elf-hook" target="_blank" rel="external">Redirecting functions in shared ELF libraries</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[jpeg编码学习笔记]]></title>
      <url>http://felixzhang00.github.io/2016/12/24/2016-12-24-jpeg%E7%BC%96%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<p>各种图片格式目的是在网络传输和存储的时候使用更少的字节，即起到压缩的作用。在图片格式解码后，无论图片的格式，图片数据都是像素数组。<br>本文将尝试通过JPEG这种图片编码格式的学习，了解图片编码的秘密。</p>
<p><br><br><br><br><br></p>
<h2 id="JPEG简介"><a href="#JPEG简介" class="headerlink" title="JPEG简介"></a>JPEG简介</h2><p>一张100X100大小的普通图片，如果未经压缩，大概在100<em>100</em>4*8bits=0.3MB左右,这也是图片在内存中占用的内存大小。<br>通常JPEG文件相对于原始图像,能够得到1/8的压缩比，如此高的压缩率是如何做到的呢？</p>
<p>JPEG能够获得如此高的压缩比是因为使用了有损压缩技术，所谓有损压缩，就是把原始数据中不重要的部分去掉，以便可以用更小的体积保存。</p>
<p>JPEG编码是基于两个idea，第一个是基于相邻的像素信息是相近的，即空间冗余性，尽量少记录重复的数据来达到压缩的效果。第二个是基于图像信号的频谱特性，图像包含各种频率，大部分为低频频谱，少部分为高频频谱。可以保留包含图像信息较多的低频频谱，舍去包含图像信息较少的高频频谱。而达到图片质量没有可察觉的损伤，又能达到压缩的效果。这也说明了JPEG是有损编码。</p>
<p><br><br><br><br><br></p>
<h2 id="JPEG的编码过程"><a href="#JPEG的编码过程" class="headerlink" title="JPEG的编码过程"></a>JPEG的编码过程</h2><p>编码流程如下图：<br><img src="http://ww4.sinaimg.cn/large/8b331ee1gw1fb2c7jxxyaj20eg08d74o.jpg" alt="编码流程示意图"></p>
<p><br><br><br><br><br></p>
<h3 id="1-色彩空间转换"><a href="#1-色彩空间转换" class="headerlink" title="1.色彩空间转换"></a>1.色彩空间转换</h3><p>将RGB色彩空间转换到其他色彩空间，比如<a href="https://en.wikipedia.org/wiki/YUV" target="_blank" rel="external">YUV</a>色彩空间。<br>出现YUV,主要有两个原因，一个是为了让彩色信号兼容黑白电视机，另外一个原因是为了减少传输的带宽。<br>下图为老电视后面的色差接口。<br><img src="http://ww3.sinaimg.cn/large/8b331ee1gw1fb24juusowj206u046q3w.jpg" alt="电视色差接口"><br>YUV中，Y表示亮度，U和V表示色度，总之它是将RGB信号进行了一种处理，根据人对亮度更敏感些，增加亮度的信号，减少颜色的信号，以这样“欺骗”人的眼睛的手段来节省空间。YUV的格式也很多，不过常见的就是422和420格式。</p>
<p>下图为420格式，每四个Y共用一组UV分量，每个YUV分量和RGB一样都用8位来表示，YUV色彩空间就比RGB色彩空间所需的存储空间少一半，数据就被压缩到了一半。<br><img src="http://ww4.sinaimg.cn/large/8b331ee1gw1fb24kvqketj20aa04n3zt.jpg" alt="Y420"></p>
<p><br><br><br><br><br></p>
<h3 id="2-离散余弦变换DCT"><a href="#2-离散余弦变换DCT" class="headerlink" title="2.离散余弦变换DCT"></a>2.离散余弦变换DCT</h3><p>简单地说，DCT是傅里叶变换的一种，变换后会得到一个系数。<br>有关DCT的详细介绍可以看这个<a href="https://www.youtube.com/watch?v=Q2aEzeMDHMA" target="_blank" rel="external">视频</a>。</p>
<p>在JPEG压缩过程中，经过颜色空间的转换，每一个色值表示成8X8的图像块，下图为一个色彩域取样块，转化为频率域的DCT系数块：<br><img src="http://ww1.sinaimg.cn/large/8b331ee1gw1fb24n45lgbj20gv03qq3u.jpg" alt="转化为频率域的DCT系数块"></p>
<p>图片经过此步骤会输出一个频率系数矩阵，左上的系数幅度值最大，越往右下，系数的幅度值越小，频率越高。大部分图片信息都在频率域矩阵左上区域，右下几乎不含有图片信息，甚至只含杂波。<br>注意：转换后的DCT系数块矩阵(x,y)处的值并不和转换前的颜色空间矩阵（x,y）处的像素值直接对应。</p>
<p>这一步骤没有压缩作用，它目的是为下一步骤找低频和高频区域，也就是找出留下的区域和舍去的区域。</p>
<p><br><br><br><br><br></p>
<h3 id="3-量化"><a href="#3-量化" class="headerlink" title="3.量化"></a>3.量化</h3><p>此步是将上步求得的DCT系数的简化的过程，利用人眼对高频部分不敏感的特性来舍去高频部分。<br>这里有两张表分别对亮度和色度做量化处理。</p>
<p>标准亮度量化表：<br><img src="http://ww3.sinaimg.cn/large/8b331ee1gw1fb24qq7yq0j20sw0b8t9r.jpg" alt="标准亮度量化表"></p>
<p>标准色度量化表：<br><img src="http://ww2.sinaimg.cn/large/8b331ee1gw1fb24rftccuj20sy0b8gmn.jpg" alt="标准色度量化表"></p>
<p>量化表是控制 JPEG 压缩比的关键。<br>DCT系数矩阵中的不同位置的值代表了图像数据中不同频率的分量，这两张表中的数据是根据人眼对不同频率的敏感程度的差别所积累下的经验制定的。这个步骤除掉了一些高频量, 损失了很多细节. 但事实上人眼对高空间频率远没有低频敏感.所以处理后的视觉损失很小。<br>另一个重要原因是所有的图片的点与点之间会有一个色彩过渡的过程. 大量的图象信息被包含在低空间频率中。 经过量化处理后, 在高空间频率段, 将出现大量连续的零。</p>
<p>把上面的DCT系数块通过量化后的结果如下图，其中第一个数-26是直流DC部分，它是一块图象样本的平均值，包含了原始8x8图像块中的很多能量，其余的是交流AC部分。<br>计算方法为：频率系数矩阵的数值除以对应量化表位置上的数值，并四舍五入到最近的整数。<br><img src="http://ww4.sinaimg.cn/large/8b331ee1gw1fb24usawejg20ie034t8o.gif" alt="量化过程"></p>
<p>解码的时候，反量化步骤会乘回量化表相应值，但是四舍五入导致低频有所损失，高频0字段被舍弃。此步为有损运算，会导致图像质量变低。所以说JPEG是有损编码。</p>
<p><br><br><br><br><br></p>
<h3 id="4-zig-zag游程编码"><a href="#4-zig-zag游程编码" class="headerlink" title="4.zig-zag游程编码"></a>4.zig-zag游程编码</h3><p>量化后的数据还可以进行简化，更大程度的去压缩。<br><img src="http://ww4.sinaimg.cn/large/8b331ee1gw1fb251cuevrj20fe0bq0tg.jpg" alt="zig-zag表"></p>
<p>根据上面的zig-zag表重排数据的过程：<br><img src="http://ww4.sinaimg.cn/large/8b331ee1gw1fb255f7vvsj208s05mq38.jpg" alt="zig-zag过程"><br>根据ZigZag表的规则对量化后的数据进行重排后的结果中可以看到出现连续的多个0，这样有利于进行游程编码。</p>
<p><br><br><br><br><br></p>
<h3 id="5-范式Huffman编码"><a href="#5-范式Huffman编码" class="headerlink" title="5.范式Huffman编码"></a>5.范式Huffman编码</h3><h4 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h4><p>huffman编码的基本原理是根据数据中元素的使用频率，调整元素的编码长度，以得到更高的压缩比。<br>举个例子，比如下面这段数据</p>
<p><code>AABCBABBCDBBDDBAABDBBDABBBBDDEDBD</code></p>
<p>这段数据里面包含了33个字符，每种字符出现的次数统计如下</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
<th>E</th>
</tr>
</thead>
<tbody>
<tr>
<td>次数</td>
<td>6</td>
<td>15</td>
<td>2</td>
<td>9</td>
<td>1</td>
<td></td>
</tr>
</tbody>
</table>
<p>如果我们用我们常见的定长编码，因为有5个文字，可以用3个bit表示，那么这段文字共需要3*33 = 99个bit来保存</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
<th>E</th>
</tr>
</thead>
<tbody>
<tr>
<td>编码</td>
<td>001</td>
<td>010</td>
<td>011</td>
<td>100</td>
<td>101</td>
<td></td>
</tr>
</tbody>
</table>
<p>如果根据字符出现的概率，使用如下的编码</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
<th>E</th>
</tr>
</thead>
<tbody>
<tr>
<td>编码</td>
<td>100</td>
<td>0</td>
<td>1110</td>
<td>10</td>
<td>1111</td>
<td></td>
</tr>
</tbody>
</table>
<p>那么这段文字共需要3<em>6 + 1</em>15 + 4<em>2 + 2</em>9 + 4*1 = 63bit，压缩比为63%。 是较短的编码不能够是较长编码的前缀，比如上面这个编码，就是由下面的这颗二叉树生成的。<br>哈弗曼编码一般都是使用二叉树来生成的，频率会高的数据对应的树节点的位置越高。这样得到的编码符合前缀规则，也就是较短的编码不能够是较长编码的前缀。</p>
<p><img src="http://ww4.sinaimg.cn/large/8b331ee1gw1fb25jyerm4j207h0760sr.jpg" alt="哈夫曼树"></p>
<p><br></p>
<h4 id="Huffman编码在JPEG中"><a href="#Huffman编码在JPEG中" class="headerlink" title="Huffman编码在JPEG中"></a>Huffman编码在JPEG中</h4><p>假设在JPEG量化处理后的数据为：<br><code>35,7,0,0,0,-6,-2,0,0,-9,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8,0,0,0,…,0</code></p>
<p>根据<a href="https://en.wikipedia.org/wiki/Run-length_encoding" target="_blank" rel="external">RLE</a>编码(游程编码)规则<br>1、用固定的4位来存储重复的数量，所以最多重复内容可以记录数量为15，超过15次要进行分段处理；<br>2、只将0作为重复的内容，每个数值记录前面有多少重复的0，末尾如果都是0用EOB作为代表；<br>3、此步不包含第一个数值，第一个数为直流系数，此步只处理交流系数。<br>得到处理结果：</p>
<p><img src="http://ww1.sinaimg.cn/large/8b331ee1gw1fb262lkvzaj21kw048ab4.jpg" alt="RLE编码"><br><br><br><br> </p>
<p>为了提高储存效率, JPEG 里并不直接保存数值, 而是将数值按位数分成 16 组,JPEG提供了一张标准的码表用于对这些数字编码<br><img src="http://ww3.sinaimg.cn/large/8b331ee1gw1fb263fusn6j210w0he768.jpg" alt="标准码表"></p>
<p>举例来说，第3个单元中的“-6”这个数字，在表中的位置是长度为3的那组，所对应的bit码是“001”，由于这种编码附带长度信息，所以我们的数据变成了如下的格式。<br><img src="http://ww4.sinaimg.cn/large/8b331ee1gw1fb265nsj1aj21kw065jt8.jpg" alt="BIT编码"><br><br><br><br> </p>
<p>对于括号前面的数字的编码，分成DC编码和AC编码。<br>下表是针对直流(DC)部分即第一个数字的哈弗曼表，由于直流部分没有前置的0，所以取值范围在0~15之间。</p>
<p><img src="http://ww2.sinaimg.cn/mw690/8b331ee1gw1fb26bixac2j20pc0nugmw.jpg" alt=""></p>
<p>对于其余的交流（AC）部分，取值范围在0~255，哈夫曼表如下：</p>
<p><img src="http://ww4.sinaimg.cn/mw690/8b331ee1gw1fb26bvyx0oj20q211e410.jpg" alt=""></p>
<p><br><br><br><br>完整个编码过程如下表，最终的数据使用10个字节保存了原本长度为64字节的数据，JPEG的压缩算法完成。<br><img src="http://ww2.sinaimg.cn/large/8b331ee1gw1fb268ej9k9j21kw09yn0a.jpg" alt=""></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://blog.mrriddler.com/2016/07/20/%E5%9B%BE%E7%89%87%E4%B9%8B%E6%97%85/" target="_blank" rel="external">http://blog.mrriddler.com/2016/07/20/%E5%9B%BE%E7%89%87%E4%B9%8B%E6%97%85/</a></li>
<li><a href="http://thecodeway.com/blog/?p=69" target="_blank" rel="external">http://thecodeway.com/blog/?p=69</a></li>
<li><a href="http://www.impulseadventure.com/photo/jpeg-huffman-coding.html" target="_blank" rel="external">http://www.impulseadventure.com/photo/jpeg-huffman-coding.html</a></li>
<li>《数字图像处理编程入门》</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[用OpenGL构建粒子喷泉]]></title>
      <url>http://felixzhang00.github.io/2015/05/18/2015-05-18-use_opengl_build_particleshooter/</url>
      <content type="html"><![CDATA[<h2 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h2><p><img src="http://7viip0.com1.z0.glb.clouddn.com/particles-1.gif"></p>
<p>这是<a href="http://book.douban.com/subject/25979507/" target="_blank" rel="external">《OpenGL ES应用开发实践指南》</a>中的一个例子，写这篇blog简单总结下在Android上进行OpenGL ES开发的方法。</p>
<h2 id="工作流程概述"><a href="#工作流程概述" class="headerlink" title="工作流程概述"></a>工作流程概述</h2><pre><code>定义顶点着色器、片段着色器。
</code></pre><p>##在哪里画图<br>在Activity中设置ContentView为GLSurfaceView，在该控件上设置自定义渲染器Renderer完成OpenGL绘图。<br>Renderer接口定义的方法：<br>onSurfaceCreated(GL10 gl10, EGLConfig eglConfig)<br>在Surface被创建时调用。</p>
<p>onSurfaceChanged(GL10 gl10, int width, int height)<br>每次Suface尺寸变化时被调用，包括第一次刚创建时。</p>
<p>onDrawFrame(GL10 gl10)<br>当绘制一帧时会被调用，比如一秒钟会被调用执行60次。</p>
<p>##如何告诉GPU绘制信息</p>
<h3 id="把内存从java堆复制到本地堆"><a href="#把内存从java堆复制到本地堆" class="headerlink" title="把内存从java堆复制到本地堆"></a>把内存从java堆复制到本地堆</h3><p>图形有顶点和颜色构成，将这些信息存放在一个数组中，并且需要将java数组转移到本地数组中,可以使用这个工具类<a href="https://github.com/FelixZhang00/My_Particles2/blob/master/app/src/main/java/me/felixzhang/example/my_particles2/data/VertexArray.java" target="_blank" rel="external">VertexArray</a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by felix on 15/5/19.</div><div class="line"> * 负责将内存从java堆复制到本地堆。</div><div class="line"> * 关联属性与顶点数据，告诉OpenGL去哪里找属性对应的数据。</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VertexArray</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> FloatBuffer floatBuffer;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">VertexArray</span><span class="params">(<span class="keyword">float</span>[] vertexData)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.floatBuffer = ByteBuffer.allocateDirect(vertexData.length * BYTE_PER_FLOAT)</div><div class="line">                .order(ByteOrder.nativeOrder())</div><div class="line">                .asFloatBuffer();</div><div class="line">        floatBuffer.put(vertexData);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setVertexAttribPointer</span><span class="params">(<span class="keyword">int</span> dataOffset, <span class="keyword">int</span> attributeLocation, <span class="keyword">int</span> componentCount, <span class="keyword">int</span> stride)</span> </span>&#123;</div><div class="line">        floatBuffer.position(dataOffset);</div><div class="line">        glVertexAttribPointer(attributeLocation, componentCount, GL_FLOAT, <span class="keyword">false</span>, stride, floatBuffer);</div><div class="line">        glEnableVertexAttribArray(attributeLocation);</div><div class="line">        floatBuffer.position(<span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 在原有数组的基础上更新指定范围的元素，如果全部复制的话速度太慢</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> vertexData</div><div class="line">     * <span class="doctag">@param</span> start</div><div class="line">     * <span class="doctag">@param</span> count</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateBuffer</span><span class="params">(<span class="keyword">float</span>[] vertexData, <span class="keyword">int</span> start, <span class="keyword">int</span> count)</span> </span>&#123;</div><div class="line">        floatBuffer.position(start);</div><div class="line">        floatBuffer.put(vertexData, start, count);</div><div class="line">        floatBuffer.position(<span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>###还需要着色器<br>告诉GPU如何绘制数据，数据在着色器这一管道中传递。</p>
<p>着色器中变量的解释</p>
<pre><code>uniform：会让每个顶点都使用同一个值，不需要对每个顶点设置，除非我们再次改变它。
attribute：把顶点属性放进着色器的手段，每个顶点都要设置一次
varying：不需要设置，共顶点着色器和片段着色器之间共享数据。
</code></pre><p>下面是一个顶点着色器</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">uniform mat4 u_Matrix;</div><div class="line">uniform <span class="keyword">float</span> u_Time;                   <span class="comment">//当前系统的时间</span></div><div class="line"></div><div class="line">attribute vec3 a_Position;</div><div class="line">attribute vec3 a_Color;</div><div class="line">attribute vec3 a_DirectionVector;</div><div class="line">attribute <span class="keyword">float</span> a_ParticleStartTime;        <span class="comment">//例子创建的时间</span></div><div class="line"></div><div class="line"></div><div class="line">varying <span class="keyword">float</span> v_ElapseTime;</div><div class="line">varying vec3 v_Color;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">   v_Color=a_Color;</div><div class="line">   v_ElapseTime=u_Time-a_ParticleStartTime;</div><div class="line">   vec3 currentPosition=a_Position+(a_DirectionVector*v_ElapseTime);</div><div class="line"></div><div class="line">   gl_Position=u_Matrix*vec4(currentPosition,<span class="number">1.0</span>);</div><div class="line">   gl_PointSize=<span class="number">10.0</span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面是一个片段着色器：<br>告诉GPU每个片段最终颜色是什么，对于基本图元的每个片段都会被调用一次。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">precision mediump <span class="keyword">float</span>;</div><div class="line"></div><div class="line">varying vec3 v_Color;</div><div class="line">varying <span class="keyword">float</span> v_ElapseTime;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">gl_FragColor=vec4(v_Color/v_ElapseTime,<span class="number">1.0</span>);</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>###如何让OpenGL画图<br>当调用下面的方法时，OpenGL就会从缓冲区读数据，每读取完一组数据就会调用一次main方法，并把数据填到attribute对应的变量中。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">glDrawArrays(GL_POINTS, <span class="number">0</span>, currentParticleCount);</div></pre></td></tr></table></figure></p>
<p>着色器main方法中的gl_Position和gl_PointSize是OpenGL中的变量，也就是最终给GPU的信息。</p>
<p>##编译着色器<br>glsl文件需要编译链接成OpenGL的一个程序才能使用。<br>需要使用这几个<a href="https://github.com/FelixZhang00/My_Particles2/tree/master/app/src/main/java/me/felixzhang/example/my_particles2/util" target="_blank" rel="external">工具类</a>。<br><img src="http://7viip0.com1.z0.glb.clouddn.com/opengl-particlesshooter-compile-tool.jpg"></p>
<p>##构建粒子系统<br><img src="http://7viip0.com1.z0.glb.clouddn.com/particles-class-diagram.jpg"></p>
<p><a href="https://gist.github.com/FelixZhang00/bc6c7d4adc98319359b7" target="_blank" rel="external">ParticlesRenderer</a></p>
<p><a href="https://gist.github.com/FelixZhang00/353d9d25a853341d6623" target="_blank" rel="external">ParticlesShooter</a></p>
<p><a href="https://gist.github.com/FelixZhang00/1d010a3f4af23f348b6c" target="_blank" rel="external">ParticlsSystem</a></p>
<p>###向粒子系统中填充数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line">   * 向系统中添加粒子，每次添加一个</div><div class="line">   *</div><div class="line">   * <span class="doctag">@param</span> positionPoint 新加粒子的位置</div><div class="line">   */</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addParticles</span><span class="params">(Point positionPoint, <span class="keyword">int</span> color, Vector direction, <span class="keyword">float</span> particleStrtTime)</span> </span>&#123;</div><div class="line"></div><div class="line">      <span class="keyword">final</span> <span class="keyword">int</span> particleOffset = nextParticleOffset * TOTAL_COMPONENT_COUNT;  <span class="comment">//记住新粒子从数组的哪个编号开始</span></div><div class="line">      <span class="keyword">int</span> currentOffset = particleOffset;                       <span class="comment">//记住新粒子的每个属性从哪里开始</span></div><div class="line"></div><div class="line">      nextParticleOffset++;</div><div class="line">      <span class="keyword">if</span> (currentParticlesCount &lt; maxParticlesCount) &#123;</div><div class="line">          currentParticlesCount++;</div><div class="line">      &#125;</div><div class="line">      <span class="comment">//当超出数组范围时，将下一个粒子放在数组的开头位置，达到回收的目的</span></div><div class="line">      <span class="keyword">if</span> (nextParticleOffset == maxParticlesCount) &#123;</div><div class="line">          nextParticleOffset = <span class="number">0</span>;</div><div class="line">      &#125;</div><div class="line"></div><div class="line"></div><div class="line">      <span class="comment">//把新粒子的数据写到数组中</span></div><div class="line">      particles[currentOffset++] = positionPoint.x;</div><div class="line">      particles[currentOffset++] = positionPoint.y;</div><div class="line">      particles[currentOffset++] = positionPoint.z;</div><div class="line"></div><div class="line">      particles[currentOffset++] = Color.red(color) / <span class="number">255f</span>;       <span class="comment">//OpenGL需要[0,1)的颜色值</span></div><div class="line">      particles[currentOffset++] = Color.green(color) / <span class="number">255f</span>;</div><div class="line">      particles[currentOffset++] = Color.blue(color) / <span class="number">255f</span>;</div><div class="line"></div><div class="line"></div><div class="line">      particles[currentOffset++] = direction.x;</div><div class="line">      particles[currentOffset++] = direction.y;</div><div class="line">      particles[currentOffset++] = direction.z;</div><div class="line"></div><div class="line"></div><div class="line">      particles[currentOffset++] = particleStrtTime;</div><div class="line"></div><div class="line">      vertexArray.updateBuffer(particles, particleOffset, TOTAL_COMPONENT_COUNT);</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>通过发射器向粒子系统中添加数据<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParticlesShooter</span> </span>&#123;</div><div class="line"></div><div class="line">   <span class="comment">//确定粒子发射器的位置，方向和颜色</span></div><div class="line">   <span class="keyword">private</span> <span class="keyword">final</span> Point position;</div><div class="line">   <span class="keyword">private</span> <span class="keyword">final</span> Vector direction;</div><div class="line">   <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> color;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ParticlesShooter</span><span class="params">(Point position, Vector direction, <span class="keyword">int</span> color)</span> </span>&#123;</div><div class="line">       <span class="keyword">this</span>.position = position;</div><div class="line">       <span class="keyword">this</span>.direction = direction;</div><div class="line">       <span class="keyword">this</span>.color = color;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addParticles</span><span class="params">(ParticlsSystem particlsSystem, <span class="keyword">float</span> currentTime, <span class="keyword">int</span> count)</span> </span>&#123;</div><div class="line"></div><div class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</div><div class="line">           particlsSystem.addParticles(position,color,direction,currentTime);</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>最后在ParticlesRenderer中加入一些调用统一管理这一切。</p>
<p><a href="https://github.com/FelixZhang00/My_Particles2" target="_blank" rel="external">项目地址</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[【LeetCode】Letter Combinations of a Phone Number]]></title>
      <url>http://felixzhang00.github.io/2015/05/08/2015-05-08-%E3%80%90LeetCode%E3%80%91Letter%20Combinations%20of%20a%20Phone%20Number/</url>
      <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a><a href="https://leetcode.com/submissions/detail/27236262/" target="_blank" rel="external">题目</a></h2><p>在手机九宫格键盘上输入一串数字，给出可能打印出来的字符串的集合。</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ul>
<li>先做一个map将数字映射到键盘上相应的字母集合。</li>
<li>把按键顺序看成深度优先遍历的深度，每次dfs将深度d+1直到d=按键字符串的长度未知，此时即完成了一次按键可能的输出。</li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">static</span> Map&lt;Integer, Character[]&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, Character[]&gt;();   <span class="comment">//数字键--键上的字母集合</span></div><div class="line"></div><div class="line">   <span class="keyword">static</span> &#123;</div><div class="line">       map.put(<span class="number">1</span>, <span class="keyword">new</span> Character[]&#123;<span class="string">'\0'</span>&#125;);</div><div class="line">       map.put(<span class="number">2</span>, <span class="keyword">new</span> Character[]&#123;<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>&#125;);</div><div class="line">       map.put(<span class="number">3</span>, <span class="keyword">new</span> Character[]&#123;<span class="string">'d'</span>, <span class="string">'e'</span>, <span class="string">'f'</span>&#125;);</div><div class="line">       map.put(<span class="number">4</span>, <span class="keyword">new</span> Character[]&#123;<span class="string">'g'</span>, <span class="string">'h'</span>, <span class="string">'i'</span>&#125;);</div><div class="line">       map.put(<span class="number">5</span>, <span class="keyword">new</span> Character[]&#123;<span class="string">'j'</span>, <span class="string">'k'</span>, <span class="string">'l'</span>&#125;);</div><div class="line">       map.put(<span class="number">6</span>, <span class="keyword">new</span> Character[]&#123;<span class="string">'m'</span>, <span class="string">'n'</span>, <span class="string">'o'</span>&#125;);</div><div class="line">       map.put(<span class="number">7</span>, <span class="keyword">new</span> Character[]&#123;<span class="string">'p'</span>, <span class="string">'q'</span>, <span class="string">'r'</span>, <span class="string">'s'</span>&#125;);</div><div class="line">       map.put(<span class="number">8</span>, <span class="keyword">new</span> Character[]&#123;<span class="string">'t'</span>, <span class="string">'u'</span>, <span class="string">'v'</span>&#125;);</div><div class="line">       map.put(<span class="number">9</span>, <span class="keyword">new</span> Character[]&#123;<span class="string">'w'</span>, <span class="string">'x'</span>, <span class="string">'y'</span>, <span class="string">'z'</span>&#125;);</div><div class="line">       map.put(<span class="number">0</span>, <span class="keyword">new</span> Character[]&#123;<span class="string">' '</span>&#125;);</div><div class="line"></div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">letterCombinations</span><span class="params">(String digits)</span> </span>&#123;</div><div class="line">       ArrayList&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;String&gt;();</div><div class="line">       <span class="keyword">if</span> (digits == <span class="keyword">null</span> || digits.length() == <span class="number">0</span>) <span class="keyword">return</span> result;</div><div class="line"></div><div class="line">       dfs(digits, <span class="number">0</span>, <span class="string">""</span>, result);</div><div class="line">       <span class="keyword">return</span> result;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="comment">/**</span></div><div class="line">    * 深度优先遍历，每次将数字键上的字母拼接到s中，一旦到达底部，则将s放入结果集中，并返回</div><div class="line">    */</div><div class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(String digits, <span class="keyword">int</span> d, String s, ArrayList&lt;String&gt; result)</span> </span>&#123;</div><div class="line">       <span class="keyword">if</span> (d == digits.length()) &#123;</div><div class="line">           result.add(s);</div><div class="line">           <span class="keyword">return</span>;</div><div class="line">       &#125;</div><div class="line">       Integer number = Integer.parseInt(digits.charAt(d) + <span class="string">""</span>);  <span class="comment">//得到输入数字串在深度d时的数字</span></div><div class="line"></div><div class="line">       <span class="keyword">for</span> (Character c : map.get(number)) &#123;                      <span class="comment">//遍历该数字对应的每一个字母</span></div><div class="line">           dfs(digits, d + <span class="number">1</span>, s + c, result);</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[【LeetCode】Merge Intervals]]></title>
      <url>http://felixzhang00.github.io/2015/05/08/2015-05-08-%E3%80%90LeetCode%E3%80%91Merge%20Intervals/</url>
      <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a><a href="https://leetcode.com/problems/merge-intervals/" target="_blank" rel="external">题目</a></h2><pre><code>Given a collection of intervals, merge all overlapping intervals.

For example,
Given [1,3],[2,6],[8,10],[15,18],
return [1,6],[8,10],[15,18].
</code></pre><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>先对intervals集合按start从小到大排序，last变量用于保存可能插入到结果集中的元素，遍历每一个集合中的元素，如果符合合并的条件，将last和当前元素合并,并重新赋值给last，此时last仍然具有合并的潜力；如果不符合合并的条件，则将last放入结果集中，并把当前元素赋值给last，成为一个新的潜在具有合并性的元素。</p>
<h3 id="自定义比较类"><a href="#自定义比较类" class="headerlink" title="自定义比较类"></a>自定义比较类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">//      Definition for an interval</span></div><div class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Interval</span> </span>&#123;</div><div class="line">      <span class="keyword">int</span> start;</div><div class="line">      <span class="keyword">int</span> end;</div><div class="line"></div><div class="line">      Interval() &#123;</div><div class="line">          start = <span class="number">0</span>;</div><div class="line">          end = <span class="number">0</span>;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      Interval(<span class="keyword">int</span> s, <span class="keyword">int</span> e) &#123;</div><div class="line">          start = s;</div><div class="line">          end = e;</div><div class="line">      &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Comparator&lt;Interval&gt; BY_START = <span class="keyword">new</span> ByStart();</div><div class="line"></div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ByStart</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Interval</span>&gt; </span>&#123;</div><div class="line">      <span class="meta">@Override</span></div><div class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Interval o1, Interval o2)</span> </span>&#123;</div><div class="line">          <span class="keyword">return</span> o1.start - o2.start;</div><div class="line">      &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<h3 id="主方法"><a href="#主方法" class="headerlink" title="主方法"></a>主方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> List&lt;Interval&gt; <span class="title">merge</span><span class="params">(List&lt;Interval&gt; intervals)</span> </span>&#123;</div><div class="line">     ArrayList&lt;Interval&gt; result = <span class="keyword">new</span> ArrayList&lt;Interval&gt;();</div><div class="line"></div><div class="line">     <span class="keyword">if</span> (intervals == <span class="keyword">null</span> || intervals.size() == <span class="number">0</span>) &#123;</div><div class="line">         <span class="keyword">return</span> result;</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     <span class="comment">//按Interval的start对intervals排序</span></div><div class="line">     Collections.sort(intervals, BY_START);</div><div class="line"></div><div class="line">     Interval last = intervals.get(<span class="number">0</span>);</div><div class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; intervals.size(); i++) &#123;</div><div class="line">         Interval temp = intervals.get(i);</div><div class="line">         <span class="keyword">if</span> (canMerge(last, temp)) &#123;</div><div class="line">             <span class="keyword">if</span> (last.end &lt;= temp.end) &#123;</div><div class="line">                 last = <span class="keyword">new</span> Interval(last.start, temp.end);</div><div class="line">             &#125;</div><div class="line">             <span class="comment">//另外一种情况last保持不变</span></div><div class="line">         &#125; <span class="keyword">else</span> &#123;</div><div class="line">             result.add(last);</div><div class="line">             last = intervals.get(i);</div><div class="line">         &#125;</div><div class="line"></div><div class="line">     &#125;</div><div class="line">     result.add(last);</div><div class="line">     <span class="keyword">return</span> result;</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">canMerge</span><span class="params">(Interval item1, Interval item2)</span> </span>&#123;</div><div class="line">     <span class="keyword">if</span> (item1.end &gt;= item2.start) &#123;</div><div class="line">         <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">     &#125;</div><div class="line">     <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode第207题--Course Schedule]]></title>
      <url>http://felixzhang00.github.io/2015/05/07/2015-05-07-LeetCode%E7%AC%AC207%E9%A2%98--Course%20Schedule/</url>
      <content type="html"><![CDATA[<h2 id="原题"><a href="#原题" class="headerlink" title="原题"></a><a href="https://leetcode.com/problems/course-schedule/" target="_blank" rel="external">原题</a></h2><p>给出课程总数，用不同整数编号表示不同课程，用一个二维数组表示多组先修课程的顺序对。</p>
<p>比如：有2门课，要学课程1必须先学课程0，这是有效的。</p>
<pre><code>2, [[1,0]]
</code></pre><p>如果有2门课，要学课程1必须先学课程0，要学课程0必须先学课程1，这是无效的。</p>
<pre><code>2, [[1,0],[0,1]]
</code></pre><p>需要完成的就是这个方法：</p>
<pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites)</span> </span>&#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre><h3 id="测试数据："><a href="#测试数据：" class="headerlink" title="测试数据："></a>测试数据：</h3><pre><code>8, [[1,0],[2,6],[1,7],[5,1],[6,4],[7,0],[0,5],[5,1],[6,4]]
</code></pre><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>由课程的编号构成一幅有向图，方向为先修顺序，构造完成后只要判断图是否有环。</p>
<h3 id="有向图数据结构"><a href="#有向图数据结构" class="headerlink" title="有向图数据结构"></a>有向图数据结构</h3><p>初始化时构造一张图，但只有顶点个事，顶点之间没有边相连。</p>
<p>用邻接表表示有向图。</p>
<p>调用<code>addEdge()</code>方法可以将课程之间先修关系写到图中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">	</div><div class="line">	</div><div class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Digraph</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> V;</div><div class="line">    <span class="keyword">private</span> ArrayList&lt;Integer&gt;[] adj;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Digraph</span><span class="params">(<span class="keyword">int</span> V)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.V = V;</div><div class="line">        adj = (ArrayList&lt;Integer&gt;[]) <span class="keyword">new</span> ArrayList[V];</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; V; v++) &#123;</div><div class="line">            adj[v] = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</div><div class="line">        adj[v].add(w);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">V</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> V;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;Integer&gt; <span class="title">adj</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> adj[v];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="判断有向图中是否有环"><a href="#判断有向图中是否有环" class="headerlink" title="判断有向图中是否有环"></a>判断有向图中是否有环</h3><p>用一个数组<code>boolean[] onStack</code>保存递归调用期间栈上的所有顶点.</p>
<p>onStack[v]=true,记录顶点v出现在这次dfs中，在这次dfs结束后，是onStack[v]=false</p>
<p>在递归执行dfs的过程中，记录当前下当前顶点在递归调用栈中，这样以后的递归调用栈只要判断它的相连点是否在之前的递归调用栈中出现过，就能判断是否有环。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">DirectedCycle</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[] marked;        <span class="comment">// marked[v] 顶点v是否被访问过</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[] onStack;       <span class="comment">//保存递归调用期间栈上的所有顶点。 onStack[v] = ？顶点v是否在栈中</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> hasCycle;       <span class="comment">// 有向图中是否环</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DirectedCycle</span><span class="params">(Digraph G)</span> </span>&#123;</div><div class="line">        marked = <span class="keyword">new</span> <span class="keyword">boolean</span>[G.V()];</div><div class="line">        onStack = <span class="keyword">new</span> <span class="keyword">boolean</span>[G.V()];</div><div class="line">        hasCycle = <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; G.V(); v++)   <span class="comment">//对图中每一个没有被访问过的点做深度优先遍历</span></div><div class="line">            <span class="keyword">if</span> (!marked[v]) dfs(G, v);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 从v顶点开始做深度优先遍历</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Digraph G, <span class="keyword">int</span> v)</span> </span>&#123;</div><div class="line">        onStack[v] = <span class="keyword">true</span>;</div><div class="line">        marked[v] = <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> w : G.adj(v)) &#123;        <span class="comment">//遍历所有顶点v的相连点</span></div><div class="line">            <span class="keyword">if</span> (hasCycle) <span class="keyword">return</span>;       <span class="comment">//如果已经找到一个环就不再dfs</span></div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!marked[w]) &#123;      <span class="comment">//对每一个未访问过的点继续dfs</span></div><div class="line">                dfs(G, w);</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (onStack[w]) &#123;    <span class="comment">//顶点w在之前的递归调用栈中，并且已经被访问过，构成环</span></div><div class="line">                hasCycle = <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        onStack[v] = <span class="keyword">false</span>;             <span class="comment">//顶点v所有的相连点遍历结束,顶点v退出当前调用栈</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> hasCycle;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="主方法"><a href="#主方法" class="headerlink" title="主方法"></a>主方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites)</span> </span>&#123;</div><div class="line">      Digraph G = <span class="keyword">new</span> Digraph(numCourses);</div><div class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prerequisites.length; i++) &#123;</div><div class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; prerequisites[i].length; j++) &#123;</div><div class="line">              G.addEdge(prerequisites[i][j], prerequisites[i][++j]);</div><div class="line">          &#125;</div><div class="line">      &#125;</div><div class="line">      DirectedCycle dag = <span class="keyword">new</span> DirectedCycle(G);</div><div class="line"></div><div class="line">      <span class="keyword">return</span> !dag.hasCycle();</div><div class="line"></div><div class="line">  &#125;</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[霍夫曼压缩算法]]></title>
      <url>http://felixzhang00.github.io/2015/05/05/2015-05-05-%E9%9C%8D%E5%A4%AB%E6%9B%BC%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95/</url>
      <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>霍夫曼压缩算法的主要思想是用较少的比特表示出现频率较高的字符，用较多的比特表示出现频率较低的字符。如下图所示，<br><img src="http://7viip0.com1.z0.glb.clouddn.com/2015-05-05-trie-representation.jpeg"></p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><pre><code>①读入完整的输入流，并转化为字符数组。
②计算每个字符出现的次数
③构建Huffman树
④构建编译表
⑤将单词查找树编码成比特输出串并写入到输出流
⑥将单词总数编码成比特输出串并写入到输出流
⑦使用编译表翻译每个输入字符
</code></pre><h3 id="节点的表示"><a href="#节点的表示" class="headerlink" title="节点的表示"></a>节点的表示</h3><pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> R = <span class="number">256</span>;       <span class="comment">//字符为ASCII表示</span></div><div class="line"></div><div class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Node</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">       <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> ch;</div><div class="line">       <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> freq;</div><div class="line">       <span class="keyword">private</span> <span class="keyword">final</span> Node left, right;</div><div class="line"></div><div class="line">       <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">char</span> ch, <span class="keyword">int</span> freq, Node left, Node right)</span> </span>&#123;</div><div class="line">           <span class="keyword">this</span>.freq = freq;</div><div class="line">           <span class="keyword">this</span>.ch = ch;</div><div class="line">           <span class="keyword">this</span>.left = left;</div><div class="line">           <span class="keyword">this</span>.right = right;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isLeaf</span><span class="params">()</span> </span>&#123;</div><div class="line">           <span class="keyword">return</span> left == <span class="keyword">null</span> &amp;&amp; right == <span class="keyword">null</span>;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="meta">@Override</span></div><div class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Node that)</span> </span>&#123;</div><div class="line">           <span class="keyword">return</span> <span class="keyword">this</span>.freq - that.freq;</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
</code></pre><h3 id="构建Huffman单词查找树"><a href="#构建Huffman单词查找树" class="headerlink" title="构建Huffman单词查找树"></a>构建Huffman单词查找树</h3><p>构建初始有一堆没有父节点的节点，将它们放到最小队列中，这样对头总是freq为最小的那个节点。<br>从队列中找到freq最小的两个节点，创建一个它们的父节点，将三个节点归并成一个大节点，接着放入队列中，<br>循环往复直至队列中只剩一个节点。</p>
<pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line">    * <span class="doctag">@param</span> freq 字符出现的次数</div><div class="line">    * <span class="doctag">@return</span></div><div class="line">    */</div><div class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Node <span class="title">buildTrie</span><span class="params">(<span class="keyword">char</span>[] freq)</span> </span>&#123;</div><div class="line">       MinPQ&lt;Node&gt; pq = <span class="keyword">new</span> MinPQ&lt;Node&gt;();</div><div class="line"></div><div class="line">       <span class="comment">//初始化多个将构成一颗Huffman树的结点</span></div><div class="line">       <span class="keyword">for</span> (<span class="keyword">char</span> i = <span class="number">0</span>; i &lt; R; i++) &#123;</div><div class="line">           <span class="keyword">if</span> (freq[i] &gt; <span class="number">0</span>) pq.insert(<span class="keyword">new</span> Node(i, freq[i], <span class="keyword">null</span>, <span class="keyword">null</span>));</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="comment">// special case in case there is only one character with a nonzero frequency</span></div><div class="line">       <span class="keyword">if</span> (pq.size() == <span class="number">1</span>) &#123;</div><div class="line">           <span class="keyword">if</span> (freq[<span class="string">'\0'</span>] == <span class="number">0</span>) pq.insert(<span class="keyword">new</span> Node(<span class="string">'\0'</span>, <span class="number">0</span>, <span class="keyword">null</span>, <span class="keyword">null</span>));</div><div class="line">           <span class="keyword">else</span> pq.insert(<span class="keyword">new</span> Node(<span class="string">'\1'</span>, <span class="number">0</span>, <span class="keyword">null</span>, <span class="keyword">null</span>));</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="comment">//归并两个小树</span></div><div class="line">       <span class="keyword">while</span> (pq.size() &gt; <span class="number">1</span>) &#123;</div><div class="line">           Node left = pq.delMin();</div><div class="line">           Node right = pq.delMin();</div><div class="line"></div><div class="line">           Node parent = <span class="keyword">new</span> Node(<span class="string">'\0'</span>, left.freq + right.freq, left, right);      <span class="comment">//创建连接子树的中间结点</span></div><div class="line">           pq.insert(parent);</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="keyword">return</span> pq.delMin();</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
</code></pre><h3 id="将Huffman单词查找树转化成字节流写到压缩文件中"><a href="#将Huffman单词查找树转化成字节流写到压缩文件中" class="headerlink" title="将Huffman单词查找树转化成字节流写到压缩文件中"></a>将Huffman单词查找树转化成字节流写到压缩文件中</h3><p>做如下规定：<br>    中间结点写0；叶子结点写1，并在后面写结点上的字符。<br><img src="http://7viip0.com1.z0.glb.clouddn.com/2015-05-05-trie-encode.jpeg"></p>
<pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">    * 将单词查找树编码成比特输出串并写入到输出流</div><div class="line">    * 用前序遍历</div><div class="line">    */</div><div class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeTrie</span><span class="params">(Node x)</span> </span>&#123;</div><div class="line">       <span class="keyword">if</span> (x.isLeaf()) &#123;</div><div class="line">           BinaryStdOut.write(<span class="keyword">true</span>);</div><div class="line">           BinaryStdOut.write(x.ch);</div><div class="line">           <span class="keyword">return</span>;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       BinaryStdOut.write(<span class="keyword">false</span>);</div><div class="line">       writeTrie(x.left);</div><div class="line">       writeTrie(x.right);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
</code></pre><h3 id="将压缩文件中字节流转化为Huffman单词查找树"><a href="#将压缩文件中字节流转化为Huffman单词查找树" class="headerlink" title="将压缩文件中字节流转化为Huffman单词查找树"></a>将压缩文件中字节流转化为Huffman单词查找树</h3><p>按写入时的规定解析字节流。</p>
<pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">    * 读比特流，得出一颗单词查找树</div><div class="line">    */</div><div class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Node <span class="title">readTrie</span><span class="params">()</span> </span>&#123;</div><div class="line">       <span class="keyword">if</span> (BinaryStdIn.readBoolean()) &#123;   <span class="comment">//读到1，说明是叶子结点</span></div><div class="line">           <span class="keyword">return</span> <span class="keyword">new</span> Node(BinaryStdIn.readChar(), <span class="number">0</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="comment">//读到的是0，说明是中间结点，需要递归直到读到1为止</span></div><div class="line"></div><div class="line">       Node left = readTrie();</div><div class="line">       Node right = readTrie();</div><div class="line">       <span class="keyword">return</span> <span class="keyword">new</span> Node(<span class="string">'\0'</span>, <span class="number">0</span>, left, right);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
</code></pre><h3 id="构建编译表"><a href="#构建编译表" class="headerlink" title="构建编译表"></a>构建编译表</h3><p>构建编译表st，索引为字符，值为路径（比特字符串）。<br>根据这张表，可以将源文件中的某个字符，压缩为更少bit表示的Huffman树上的路径。</p>
<pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">buildCode</span><span class="params">(String[] st, Node x, String s)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (!x.isLeaf()) &#123;</div><div class="line">        buildCode(st, x.left, s + <span class="string">"0"</span>);</div><div class="line">        buildCode(st, x.right, s + <span class="string">"1"</span>);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        st[x.ch] = s;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre><h3 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h3><pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">	</div><div class="line"><span class="comment">/**</span></div><div class="line">  * 从输入流中读字节流，并将压缩后的结果写入输出流</div><div class="line">  */</div><div class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">compress</span><span class="params">()</span> </span>&#123;</div><div class="line">     <span class="comment">//①读入完整的输入流，并转化为字符数组</span></div><div class="line">     String s = BinaryStdIn.readString();</div><div class="line">     <span class="keyword">char</span>[] input = s.toCharArray();</div><div class="line"></div><div class="line">     <span class="comment">//②计算每个字符出现的次数，没有出现的就为0</span></div><div class="line">     <span class="keyword">char</span>[] freq = <span class="keyword">new</span> <span class="keyword">char</span>[R];</div><div class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; input.length; i++) &#123;</div><div class="line">         freq[input[i]]++;</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     <span class="comment">//③构建Huffman树</span></div><div class="line">     Node root = buildTrie(freq);</div><div class="line"></div><div class="line">     <span class="comment">//④构建编译表，将输入中的每个char值与一个比特字符串（即Huffman树上路径）相关联</span></div><div class="line">     String st[] = <span class="keyword">new</span> String[R];</div><div class="line">     buildCode(st, root, <span class="string">""</span>);</div><div class="line"></div><div class="line"></div><div class="line">     <span class="comment">//⑤将单词查找树编码成比特输出串并写入到输出流</span></div><div class="line">     writeTrie(root);</div><div class="line"></div><div class="line">     <span class="comment">//⑥将单词总数编码成比特输出串并写入到输出流</span></div><div class="line">     BinaryStdOut.write(input.length);</div><div class="line"></div><div class="line"></div><div class="line">     <span class="comment">//⑦使用编译表翻译每个输入字符</span></div><div class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; input.length; i++) &#123;</div><div class="line">         String code = st[input[i]];   <span class="comment">//code表示Huffman单词查找数上的路径</span></div><div class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; code.length(); j++) &#123;  <span class="comment">//要一位一位地输出</span></div><div class="line">             <span class="keyword">if</span> (code.charAt(j) == <span class="string">'1'</span>) &#123;</div><div class="line">                 BinaryStdOut.write(<span class="keyword">true</span>);</div><div class="line">             &#125; <span class="keyword">else</span> &#123;</div><div class="line">                 BinaryStdOut.write(<span class="keyword">false</span>);</div><div class="line">             &#125;</div><div class="line">         &#125;</div><div class="line"></div><div class="line">     &#125;</div><div class="line"></div><div class="line">     BinaryStdOut.close();</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
</code></pre><h3 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h3><pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">	</div><div class="line"><span class="comment">/**</span></div><div class="line">   * 解压</div><div class="line">   * 读取压缩文件的比特流，</div><div class="line">   * 将比特流对应为路径在单词查找树上找，将找到的结点中的字符写出</div><div class="line">   */</div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">expand</span><span class="params">()</span> </span>&#123;</div><div class="line">      Node root = readTrie();</div><div class="line">      <span class="keyword">int</span> N = BinaryStdIn.readInt();  <span class="comment">//读出存在压缩文件中的字符串长度</span></div><div class="line"></div><div class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;   <span class="comment">//找出源文件中每个字符</span></div><div class="line"></div><div class="line">          Node x = root;</div><div class="line">          <span class="keyword">while</span> (!x.isLeaf()) &#123;       <span class="comment">//遍历，知道叶子结点</span></div><div class="line">              <span class="keyword">if</span> (BinaryStdIn.readBoolean()) &#123;</div><div class="line">                  x = x.right;</div><div class="line">              &#125; <span class="keyword">else</span> &#123;</div><div class="line">                  x = x.left;</div><div class="line">              &#125;</div><div class="line"></div><div class="line">          &#125;</div><div class="line"></div><div class="line">          BinaryStdOut.write(x.ch);</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      BinaryStdOut.close();</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://algs4.cs.princeton.edu/home/" target="_blank" rel="external">Algorithms, 4th Edition by Robert Sedgewick and Kevin Wayne</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[游程编码算法]]></title>
      <url>http://felixzhang00.github.io/2015/05/05/2015-05-05-%E6%B8%B8%E7%A8%8B%E7%BC%96%E7%A0%81%E7%AE%97%E6%B3%95/</url>
      <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>利用比特流常见的冗余形式：连续的重复数据，来压缩数据。</p>
<pre><code>0000000000000001111111000000011111111111    --40bit

在源数据中，记录重复bit的个数，记录到压缩数据中。

1111，0111，0111，1011                             --16bit            
</code></pre><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><pre><code>* 压缩原理：
* 将源文件中连续的1或0的个数（count）写到压缩文件中,
* 比如count用8位表示，规定压缩文件的格式为：
* 0连续的个数-1连续的个数-0连续的个数-1连续的个数.....
* 个数的大小为0~255，
* 如何处理连续的0(或1)的个数过大，无法存到count中：
* count0(=255)-count1(=0)-count0(=?)-.......
</code></pre><h3 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h3><pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> R = <span class="number">256</span>;</div><div class="line">   <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> lgR = <span class="number">8</span>;			<span class="comment">//存储cnt需要多少位</span></div><div class="line"><span class="comment">/**</span></div><div class="line">    * 压缩</div><div class="line">    */</div><div class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">compress</span><span class="params">()</span> </span>&#123;</div><div class="line">       <span class="keyword">boolean</span> b, old = <span class="keyword">false</span>;</div><div class="line">       <span class="keyword">int</span> cnt = <span class="number">0</span>;                            <span class="comment">//记录连续的0或1的个数</span></div><div class="line"></div><div class="line">       <span class="keyword">while</span> (!BinaryStdIn.isEmpty()) &#123;</div><div class="line">           b = BinaryStdIn.readBoolean();</div><div class="line">           <span class="keyword">if</span> (b != old) &#123;                     <span class="comment">//该向输出流写数据了</span></div><div class="line">               BinaryStdOut.write(cnt,lgR);</div><div class="line">               cnt = <span class="number">0</span>;</div><div class="line">               old = !old;</div><div class="line">           &#125; <span class="keyword">else</span> &#123;</div><div class="line"></div><div class="line">               <span class="keyword">if</span> (cnt == (R - <span class="number">1</span>)) &#123;           <span class="comment">// 处理连续的0(或1)的个数过大，无法存到count</span></div><div class="line">                   BinaryStdOut.write(cnt,lgR);    <span class="comment">//count0(=255)-count1(=0)-count0(=?)-.......</span></div><div class="line">                   cnt = <span class="number">0</span>;</div><div class="line">                   BinaryStdOut.write(cnt,lgR);</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">           cnt++;</div><div class="line"></div><div class="line">       &#125;</div><div class="line">       BinaryStdOut.write(cnt,lgR);    <span class="comment">//把剩余的cnt写出</span></div><div class="line">       BinaryStdOut.close();</div><div class="line"></div><div class="line">   &#125;</div></pre></td></tr></table></figure>
</code></pre><h3 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h3><pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">	</div><div class="line"><span class="comment">/**</span></div><div class="line"> * 解压</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">expand</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">boolean</span> bit = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (!BinaryStdIn.isEmpty()) &#123;</div><div class="line">        <span class="keyword">int</span> run = BinaryStdIn.readInt(lgR);   <span class="comment">//从输入流中读取lgR 位,这个数值代表了源文件中连续1或连续0的长度</span></div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; run; i++) &#123;       <span class="comment">//根据run的大小向输出流中写位</span></div><div class="line">            BinaryStdOut.write(bit);</div><div class="line">        &#125;</div><div class="line">        bit = !bit;                           <span class="comment">//压缩的格式要求</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    BinaryStdOut.close();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre><h3 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h3><pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">	</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (args[<span class="number">0</span>].equals(<span class="string">"-"</span>)) compress();</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (args[<span class="number">0</span>].equals(<span class="string">"+"</span>)) expand();</div><div class="line">    <span class="keyword">else</span> <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal command line argument"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[KMP子字符串查找算法]]></title>
      <url>http://felixzhang00.github.io/2015/05/02/2015-05-02-%20KMP%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/</url>
      <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>算法的基本思想是：当出现不匹配时，就能知晓一部分文本的内容，可以利用这些信息避免将指针回退到所有这些已知的字符串之前。</p>
<h2 id="DFA（确定有限状态机）模拟"><a href="#DFA（确定有限状态机）模拟" class="headerlink" title="DFA（确定有限状态机）模拟"></a>DFA（确定有限状态机）模拟</h2><p>提前判断如何重新查找，而这种判断只取决于模式本身，所以可以对模式的字符序列做一个确定有限状态机。</p>
<p>DFA的数据结构表示为二维数组dfa[R][M]，其中R为指定字典中的字符集的个数（比如ASCII为256），M为匹配字符串pat的长度，状态的意思是文本中某个位置i匹配pat的程度，0状态为未匹配状态，M状态为终止状态，找到了完整匹配的字符串。<br>如图中R=3，M=6，二维数组中的值指向下一个状态。<br><img src="http://7viip0.com1.z0.glb.clouddn.com/KMP-2015-05-02.jpeg"></p>
<h3 id="构造DFA"><a href="#构造DFA" class="headerlink" title="构造DFA"></a>构造DFA</h3><p>穷举模式pat的所有可能情况，将这些情况用状态图表示。其中X记录匹配失败时重启的索引位置。</p>
<p><img src="http://7viip0.com1.z0.glb.clouddn.com/KMP--2-2015-05-02.png"></p>
<h2 id="编码实现"><a href="#编码实现" class="headerlink" title="编码实现"></a>编码实现</h2><h3 id="用暴力算法实现子字符串查找算法"><a href="#用暴力算法实现子字符串查找算法" class="headerlink" title="用暴力算法实现子字符串查找算法"></a>用暴力算法实现子字符串查找算法</h3><pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(String txt, String pat)</span> </span>&#123;</div><div class="line">     <span class="keyword">int</span> i, N = txt.length();</div><div class="line">     <span class="keyword">int</span> j, M = pat.length();</div><div class="line"></div><div class="line">     <span class="keyword">for</span> (i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; N &amp;&amp; j &lt; M; i++) &#123;</div><div class="line">         <span class="keyword">if</span> (txt.charAt(i) == pat.charAt(j)) &#123;</div><div class="line">             j++;</div><div class="line">         &#125; <span class="keyword">else</span> &#123;  <span class="comment">//显式回退</span></div><div class="line">             i-=j;</div><div class="line">             j=<span class="number">0</span>;</div><div class="line">         &#125;</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     <span class="keyword">if</span> (j==M) <span class="keyword">return</span> i-M;</div><div class="line">     <span class="keyword">return</span> N;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
</code></pre><h3 id="KMP查找"><a href="#KMP查找" class="headerlink" title="KMP查找"></a>KMP查找</h3><pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">    * <span class="doctag">@return</span> pat在txt中开始出现的位置，如果等于txt.length()表示没有找到</div><div class="line">    */</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(String txt)</span> </span>&#123;</div><div class="line">       <span class="keyword">int</span> M = pat.length();</div><div class="line">       <span class="keyword">int</span> N = txt.length();</div><div class="line"></div><div class="line">       <span class="keyword">int</span> i, j;  <span class="comment">//i指向txt，j指向pat</span></div><div class="line">       <span class="keyword">for</span> (i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; N &amp;&amp; j &lt; M; i++) &#123;</div><div class="line">           j = dfa[txt.charAt(i)][j];</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">if</span> (j == M) <span class="keyword">return</span> i - M;   <span class="comment">//匹配</span></div><div class="line">       <span class="keyword">return</span> N;                   <span class="comment">//不匹配</span></div><div class="line"></div><div class="line">   &#125;</div></pre></td></tr></table></figure>
</code></pre><h3 id="构造DFA-1"><a href="#构造DFA-1" class="headerlink" title="构造DFA"></a>构造DFA</h3><pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> R;       <span class="comment">// the radix</span></div><div class="line">   <span class="keyword">private</span> <span class="keyword">int</span>[][] dfa;       <span class="comment">// the KMP automoton</span></div><div class="line"></div><div class="line">   <span class="keyword">private</span> String pat;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="title">KMP</span><span class="params">(String pat)</span> </span>&#123;</div><div class="line">       <span class="keyword">this</span>.R = <span class="number">256</span>;   <span class="comment">//设置字典大小</span></div><div class="line">       <span class="keyword">this</span>.pat = pat;</div><div class="line"></div><div class="line">       <span class="comment">//构造pat对应的dfa</span></div><div class="line">       <span class="keyword">int</span> M = pat.length();</div><div class="line">       dfa = <span class="keyword">new</span> <span class="keyword">int</span>[R][M];</div><div class="line">       dfa[pat.charAt(<span class="number">0</span>)][<span class="number">0</span>] = <span class="number">1</span>;</div><div class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> X = <span class="number">0</span>, j = <span class="number">1</span>; j &lt; M; j++) &#123;  <span class="comment">//X记录匹配失败时的索引位置,j指向pat</span></div><div class="line"></div><div class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; R; c++) &#123;   <span class="comment">//对于匹配失败的情况，直接复制重启状态</span></div><div class="line">               dfa[c][j] = dfa[c][X];</div><div class="line">           &#125;</div><div class="line"></div><div class="line">           dfa[pat.charAt(j)][j] = j + <span class="number">1</span>;           <span class="comment">//匹配成功的指向下一个状态</span></div><div class="line"></div><div class="line">           X = dfa[pat.charAt(j)][X]; <span class="comment">//更新重启位置X</span></div><div class="line">       &#125;</div><div class="line"></div><div class="line">   &#125;</div></pre></td></tr></table></figure>
</code></pre><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><pre><code>优点：适合在长度不确定的输入流中进行查找，不需要在输入中回退。
缺点：最坏的情况（在重复性很高的文本中查找重复性很高的模式）在实际应用中很少出现，还不如使用暴力算法来的容易，性能也差不了多少。
</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://algs4.cs.princeton.edu/home/" target="_blank" rel="external">Algorithms, 4th Edition by Robert Sedgewick and Kevin Wayne</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[滑动卡片式效果]]></title>
      <url>http://felixzhang00.github.io/2015/04/30/2015-04-30-%E6%BB%91%E5%8A%A8%E5%8D%A1%E7%89%87%E5%BC%8F%E6%95%88%E6%9E%9C/</url>
      <content type="html"><![CDATA[<p>##效果图<br><img src="http://7viip0.com1.z0.glb.clouddn.com/SlideCard-demo-2015-04-30.gif"></p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="静态布局"><a href="#静态布局" class="headerlink" title="静态布局"></a>静态布局</h3><p>使用瀑布流效果的StaggeredGridView控件作为GroupView.</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">com.etsy.android.grid.StaggeredGridView</span></span></div><div class="line">   <span class="attr">android:id</span>=<span class="string">"@+id/page"</span></div><div class="line">   <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></div><div class="line">   <span class="attr">xmlns:app</span>=<span class="string">"http://schemas.android.com/apk/res-auto"</span></div><div class="line">   <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></div><div class="line">   <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></div><div class="line">   <span class="attr">app:column_count</span>=<span class="string">"1"</span></div><div class="line">   <span class="attr">app:item_margin</span>=<span class="string">"8dp"</span></div><div class="line">   &gt;</div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">com.etsy.android.grid.StaggeredGridView</span>&gt;</span></div></pre></td></tr></table></figure>
<p>定义item布局</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></div><div class="line">             <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></div><div class="line">             <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></div><div class="line">             <span class="attr">android:background</span>=<span class="string">"@drawable/card_bg"</span></div><div class="line">             <span class="attr">android:descendantFocusability</span>=<span class="string">"blocksDescendants"</span></div><div class="line">             <span class="attr">android:orientation</span>=<span class="string">"vertical"</span></div><div class="line">             <span class="attr">android:padding</span>=<span class="string">"8dp"</span></div><div class="line">   &gt;</div><div class="line"></div><div class="line">   <span class="tag">&lt;<span class="name">TextView</span></span></div><div class="line">       <span class="attr">android:id</span>=<span class="string">"@+id/tv_caption"</span></div><div class="line">       <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></div><div class="line">       <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></div><div class="line">       <span class="attr">android:text</span>=<span class="string">"caption"</span></div><div class="line">       <span class="attr">android:textSize</span>=<span class="string">"20sp"</span></div><div class="line">       <span class="attr">android:textStyle</span>=<span class="string">"normal"</span></div><div class="line">       /&gt;</div><div class="line"></div><div class="line">   <span class="tag">&lt;<span class="name">ImageView</span></span></div><div class="line">       <span class="attr">android:id</span>=<span class="string">"@+id/iv_normal"</span></div><div class="line">       <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></div><div class="line">       <span class="attr">android:layout_height</span>=<span class="string">"200dp"</span></div><div class="line">       <span class="attr">android:background</span>=<span class="string">"#c9c9c9"</span></div><div class="line">       <span class="attr">android:minHeight</span>=<span class="string">"200dp"</span></div><div class="line">       <span class="attr">android:scaleType</span>=<span class="string">"centerCrop"</span></div><div class="line">       /&gt;</div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></div></pre></td></tr></table></figure>
<h3 id="动画实现"><a href="#动画实现" class="headerlink" title="动画实现"></a>动画实现</h3><p>这里需要使用<a href="https://github.com/nhaarman/ListViewAnimations" target="_blank" rel="external">listviewanimations</a>和<a href="https://github.com/JakeWharton/NineOldAndroids" target="_blank" rel="external">nineoldandroids</a>两个有关动画效果的库，继承AnimationAdapter自定义CardsAnimationAdapter，覆写public Animator[] getAnimators(ViewGroup viewGroup, View view)方法，为每个view指定动画效果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CardsAnimationAdapter</span> <span class="keyword">extends</span> <span class="title">AnimationAdapter</span> </span>&#123;</div><div class="line"></div><div class="line"></div><div class="line">   <span class="keyword">private</span> <span class="keyword">float</span> mTranslationY = <span class="number">400</span>;</div><div class="line">   <span class="keyword">private</span> <span class="keyword">float</span> mRotationX = <span class="number">15</span>;</div><div class="line">   <span class="keyword">private</span> <span class="keyword">long</span> mDuration = <span class="number">400</span>;</div><div class="line">   <span class="keyword">private</span> <span class="keyword">long</span> mDelay = <span class="number">30</span>;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="title">CardsAnimationAdapter</span><span class="params">(BaseAdapter baseAdapter)</span> </span>&#123;</div><div class="line">       <span class="keyword">super</span>(baseAdapter);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">long</span> <span class="title">getAnimationDelayMillis</span><span class="params">()</span> </span>&#123;</div><div class="line">       <span class="keyword">return</span> mDelay;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">long</span> <span class="title">getAnimationDurationMillis</span><span class="params">()</span> </span>&#123;</div><div class="line">       <span class="keyword">return</span> mDuration;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="meta">@Override</span></div><div class="line">   <span class="keyword">public</span> Animator[] getAnimators(ViewGroup viewGroup, View view) &#123;</div><div class="line">       <span class="keyword">return</span> <span class="keyword">new</span> Animator[]&#123;</div><div class="line">               ObjectAnimator.ofFloat(view, <span class="string">"translationY"</span>, mTranslationY, <span class="number">0</span>),</div><div class="line">               ObjectAnimator.ofFloat(view, <span class="string">"rotationX"</span>, mRotationX, <span class="number">0</span>)</div><div class="line">       &#125;;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>将原生的adapter装饰成带有动画效果的CardsAnimationAdapter.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">private</span> StaggeredGridView mPage;</div><div class="line">   mPage = (StaggeredGridView) findViewById(R.id.page);</div><div class="line"></div><div class="line">      mAdapter=<span class="keyword">new</span> PageAdapter(<span class="keyword">this</span>, imgIds);</div><div class="line">      AnimationAdapter animationAdapter = <span class="keyword">new</span> CardsAnimationAdapter(mAdapter);</div><div class="line">      animationAdapter.setAbsListView(mPage);</div><div class="line"></div><div class="line">      mPage.setAdapter(animationAdapter);</div></pre></td></tr></table></figure>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><p><a href="https://github.com/FelixZhang00/SlideCard" target="_blank" rel="external">github</a></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://github.com/stormzhang/9GAG" target="_blank" rel="external">9GAG-Android (unofficial)</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android滑动删除控件]]></title>
      <url>http://felixzhang00.github.io/2015/04/26/2015-04-26-Android%E6%BB%91%E5%8A%A8%E5%88%A0%E9%99%A4%E6%8E%A7%E4%BB%B6/</url>
      <content type="html"><![CDATA[<h2 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h2><p><img src="http://7viip0.com1.z0.glb.clouddn.com/2015-04-26-滑动删除.gif"></p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="静态布局"><a href="#静态布局" class="headerlink" title="静态布局"></a>静态布局</h3><p>自定义一个ViewGroup，继承至FrameLayout，覆写其中的几个关键方法，用于给其中的两个子view设置布局位置。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line">	</div><div class="line">	private View contentView, deleteView;</div><div class="line">	int contentViewHeight, contentViewWidth;</div><div class="line">	int deleteViewHeight, deleteViewWidth;</div><div class="line"></div><div class="line">	private void init() &#123;</div><div class="line">	&#125;</div><div class="line"></div><div class="line"></div><div class="line">	/**</div><div class="line">	 * 从xml中加载完布局，只知道有几个子view，并没有进行测量</div><div class="line">	 * 一般可以初始化子view的引用</div><div class="line">	 */</div><div class="line">	@Override</div><div class="line">	protected void onFinishInflate() &#123;</div><div class="line">    super.onFinishInflate();</div><div class="line">    contentView = getChildAt(0);</div><div class="line">    deleteView = getChildAt(1);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	/**</div><div class="line">	 * 测量完子view后调用，在这里可以直接获取子view的高度</div><div class="line">	 */</div><div class="line">	@Override</div><div class="line">	protected void onSizeChanged(int w, int h, int oldw, int oldh) &#123;</div><div class="line">    super.onSizeChanged(w, h, oldw, oldh);</div><div class="line">    contentViewWidth = contentView.getMeasuredWidth();</div><div class="line">    deleteViewHeight = deleteView.getMeasuredHeight();</div><div class="line">	&#125;</div><div class="line"></div><div class="line"></div><div class="line">	/**</div><div class="line">	 * 放置子view到合适的位置</div><div class="line">	 */</div><div class="line">	@Override</div><div class="line">	protected void onLayout(boolean changed, int left, int top, int right, int bottom) &#123;</div><div class="line">    super.onLayout(changed, left, top, right, bottom);</div><div class="line">    contentView.layout(0, 0, contentViewWidth, contentViewHeight);</div><div class="line">    deleteView.layout(contentViewWidth, 0, contentViewWidth + deleteViewWidth, 	deleteViewHeight);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">```	</div><div class="line"></div><div class="line"></div><div class="line">### 处理滑动逻辑</div><div class="line"></div><div class="line">利用ViewDragHelper类封装了对触摸位置、速度、距离的检测，以及Scroller.</div><div class="line">需要我们制定什么时候滑动，以及滑动多少。</div><div class="line">需要把ViewGroup中受到的触摸事件传给ViewDragHelper实例。</div><div class="line"></div><div class="line">#### 触摸事件传给ViewDragHelper实例</div><div class="line"></div><div class="line">```java</div><div class="line"></div><div class="line">	   @Override</div><div class="line">    public boolean onInterceptTouchEvent(MotionEvent ev) &#123;</div><div class="line">        return mViewDragHelper.shouldInterceptTouchEvent(ev);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public boolean onTouchEvent(MotionEvent event) &#123;</div><div class="line">        mViewDragHelper.processTouchEvent(event);</div><div class="line"></div><div class="line">        //消费掉此触摸事件，不向上返回</div><div class="line">        return true;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>####在ViewDragHelper的回调函数中处理滑动逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">private</span> ViewDragHelper mViewDragHelper;</div><div class="line">   <span class="keyword">private</span> ViewDragHelper.Callback callback = <span class="keyword">new</span> ViewDragHelper.Callback() &#123;</div><div class="line"></div><div class="line">       <span class="comment">/**</span></div><div class="line">        * <span class="doctag">@return</span> 返回true表示获得view的控制权</div><div class="line">        */</div><div class="line">       <span class="meta">@Override</span></div><div class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryCaptureView</span><span class="params">(View view, <span class="keyword">int</span> i)</span> </span>&#123;</div><div class="line">           <span class="keyword">return</span> view == contentView || view == deleteView;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="meta">@Override</span></div><div class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onViewCaptured</span><span class="params">(View capturedChild, <span class="keyword">int</span> activePointerId)</span> </span>&#123;</div><div class="line">           <span class="keyword">super</span>.onViewCaptured(capturedChild, activePointerId);</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="comment">/**</span></div><div class="line">        * 控制view在水平方向上实际滑动了多少</div><div class="line">        * <span class="doctag">@param</span> child 当前触摸的view</div><div class="line">        * <span class="doctag">@param</span> left view的左边坐标，负数表示view的左边超出父view边界的长度</div><div class="line">        * <span class="doctag">@param</span> dx</div><div class="line">        * <span class="doctag">@return</span> 返回多少，代表想让child的left=多少</div><div class="line">        */</div><div class="line">       <span class="meta">@Override</span></div><div class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">clampViewPositionHorizontal</span><span class="params">(View child, <span class="keyword">int</span> left, <span class="keyword">int</span> dx)</span> </span>&#123;</div><div class="line">           Log.i(TAG, <span class="string">"clampViewPositionHorizontal--&gt;"</span> + <span class="string">"left="</span> + left);</div><div class="line">           <span class="keyword">if</span> (child == contentView) &#123;</div><div class="line">               <span class="keyword">if</span> (left &gt; <span class="number">0</span>) left = <span class="number">0</span>;</div><div class="line">               <span class="keyword">if</span> (left &lt; -deleteViewWidth) left = -deleteViewWidth;</div><div class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (child == deleteView) &#123;</div><div class="line">               <span class="comment">//使deleteVie不会超出指定的边界</span></div><div class="line">               <span class="keyword">if</span> (left &lt; contentViewWidth - deleteViewWidth) &#123;</div><div class="line">                   left = contentViewWidth - deleteViewWidth;</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">           <span class="keyword">return</span> left;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="comment">/**</span></div><div class="line">        * 水平方向拖拽的范围</div><div class="line">        */</div><div class="line">       <span class="meta">@Override</span></div><div class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getViewHorizontalDragRange</span><span class="params">(View child)</span> </span>&#123;</div><div class="line">           <span class="keyword">return</span> <span class="keyword">super</span>.getViewHorizontalDragRange(child);</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="comment">/**</span></div><div class="line">        * view滑动后的回调</div><div class="line">        * <span class="doctag">@param</span> changedView</div><div class="line">        * <span class="doctag">@param</span> left</div><div class="line">        * <span class="doctag">@param</span> top</div><div class="line">        * <span class="doctag">@param</span> dx   x轴方向的改编值</div><div class="line">        * <span class="doctag">@param</span> dy</div><div class="line">        */</div><div class="line">       <span class="meta">@Override</span></div><div class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onViewPositionChanged</span><span class="params">(View changedView, <span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> dx, <span class="keyword">int</span> dy)</span> </span>&#123;</div><div class="line">           <span class="keyword">super</span>.onViewPositionChanged(changedView, left, top, dx, dy);</div><div class="line">           Log.i(TAG, <span class="string">"onViewPositionChanged--&gt;"</span> + <span class="string">"dx="</span> + dx);</div><div class="line">           <span class="comment">//重新布局子view的位置</span></div><div class="line">           <span class="keyword">if</span> (changedView == contentView) &#123;</div><div class="line">               deleteView.layout(deleteView.getLeft() + dx, <span class="number">0</span>, deleteView.getRight() + dx, deleteView.getBottom());</div><div class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (changedView == deleteView) &#123;</div><div class="line">               contentView.layout(contentView.getLeft() + dx, <span class="number">0</span>, contentView.getRight() + dx, contentView.getBottom());</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="comment">/**</span></div><div class="line">        * TouchUp的回调</div><div class="line">        * <span class="doctag">@param</span> releasedChild</div><div class="line">        * <span class="doctag">@param</span> xvel</div><div class="line">        * <span class="doctag">@param</span> yvel</div><div class="line">        */</div><div class="line">       <span class="meta">@Override</span></div><div class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onViewReleased</span><span class="params">(View releasedChild, <span class="keyword">float</span> xvel, <span class="keyword">float</span> yvel)</span> </span>&#123;</div><div class="line">           <span class="keyword">super</span>.onViewReleased(releasedChild, xvel, yvel);</div><div class="line"></div><div class="line">           <span class="keyword">if</span> (contentView.getLeft() &lt; -deleteViewWidth / <span class="number">2</span>) &#123;   <span class="comment">//滑动条打开状态</span></div><div class="line">               mViewDragHelper.smoothSlideViewTo(contentView, -deleteViewWidth, <span class="number">0</span>);</div><div class="line">           &#125; <span class="keyword">else</span> &#123;          <span class="comment">//滑动条关闭状态</span></div><div class="line">               mViewDragHelper.smoothSlideViewTo(contentView, <span class="number">0</span>, <span class="number">0</span>);</div><div class="line">           &#125;</div><div class="line">           <span class="comment">//</span></div><div class="line">           ViewCompat.postInvalidateOnAnimation(SwipeView.<span class="keyword">this</span>);  <span class="comment">//动画刷新</span></div><div class="line">       &#125;</div><div class="line">   &#125;;</div></pre></td></tr></table></figure>
<h4 id="动画效果"><a href="#动画效果" class="headerlink" title="动画效果"></a>动画效果</h4><p>Scroller帮助计算好view在某个时间点会处于某个位置，达到动画的效果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">computeScroll</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.computeScroll();</div><div class="line">    <span class="keyword">if</span>(mViewDragHelper.continueSettling(<span class="keyword">true</span>))&#123;     <span class="comment">//内部有Scroller计算位置和移动</span></div><div class="line">        ViewCompat.postInvalidateOnAnimation(SwipeView.<span class="keyword">this</span>);       <span class="comment">//刷新当前view</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="ListView中的滑动删除效果"><a href="#ListView中的滑动删除效果" class="headerlink" title="ListView中的滑动删除效果"></a>ListView中的滑动删除效果</h3><p><img src="http://7viip0.com1.z0.glb.clouddn.com/2015-04-2-ListView中的滑动删除.gif"></p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><p><a href="https://github.com/FelixZhang00/My_SwipeViewDemo" target="_blank" rel="external">github</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android ListView头部视差控件]]></title>
      <url>http://felixzhang00.github.io/2015/04/25/2015-04-25-Android%20ListView%E5%A4%B4%E9%83%A8%E8%A7%86%E5%B7%AE%E6%8E%A7%E4%BB%B6/</url>
      <content type="html"><![CDATA[<h2 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h2><p><img src="http://7viip0.com1.z0.glb.clouddn.com/2015-04-25-头部视差.gif"></p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="静态布局，为ListView增加头部的View"><a href="#静态布局，为ListView增加头部的View" class="headerlink" title="静态布局，为ListView增加头部的View"></a>静态布局，为ListView增加头部的View</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">mListView = (ParallaxListView) findViewById(R.id.listview);</div><div class="line">      mHeadView = View.inflate(<span class="keyword">this</span>, R.layout.head, <span class="keyword">null</span>);            <span class="comment">//异步解析xml中的布局</span></div><div class="line">      mListView.addHeaderView(mHeadView);</div></pre></td></tr></table></figure>
<h3 id="自定义ListView，重写overScrollBy方法"><a href="#自定义ListView，重写overScrollBy方法" class="headerlink" title="自定义ListView，重写overScrollBy方法"></a>自定义ListView，重写overScrollBy方法</h3><pre><code>overScrollBy方法会在ListView滑动到顶部和底部时会调用。
获取头部控件的大小需要在布局解析完成后才能知道，否则得到的将是0，
通过设置监听器mHeadView.getViewTreeObserver().addOnGlobalLayoutListener，
当布局文件解析完成后，会调用此监听器中的回调方法，这是就可以将头部控件传入自定义的ListView中了
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParallaxListView</span> <span class="keyword">extends</span> <span class="title">ListView</span> </span>&#123;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ParallaxListView</span><span class="params">(Context context)</span> </span>&#123;</div><div class="line">       <span class="keyword">super</span>(context);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ParallaxListView</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</div><div class="line">       <span class="keyword">super</span>(context, attrs);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ParallaxListView</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyleAttr)</span> </span>&#123;</div><div class="line">       <span class="keyword">super</span>(context, attrs, defStyleAttr);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="keyword">private</span> ImageView parallaxImageView;</div><div class="line">   <span class="keyword">private</span> <span class="keyword">int</span> maxHeight;</div><div class="line">   <span class="keyword">private</span> <span class="keyword">int</span> originalHeight;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setParallaxImageView</span><span class="params">(ImageView parallaxImageView)</span> </span>&#123;</div><div class="line">       <span class="keyword">this</span>.parallaxImageView = parallaxImageView;</div><div class="line">       originalHeight = parallaxImageView.getHeight();</div><div class="line"></div><div class="line">       <span class="comment">//获得imagview上图片的原始高度，即为imageview的最高度</span></div><div class="line">       maxHeight = parallaxImageView.getDrawable().getIntrinsicHeight();</div><div class="line"></div><div class="line">   &#125;</div><div class="line"></div><div class="line"></div><div class="line">   <span class="comment">/**</span></div><div class="line">    * 当ListView被滑动到顶部和底部时会调用此方法</div><div class="line">    *</div><div class="line">    * <span class="doctag">@param</span> deltaY         y方向滑动的距离。 正：底部到头;负：顶部到头</div><div class="line">    * <span class="doctag">@param</span> maxOverScrollY 到头后，最大可滚动的范围</div><div class="line">    * <span class="doctag">@param</span> isTouchEvent   是否是触摸滑动。true:手指拖动到头;false:惯性滑动到头。</div><div class="line">    * <span class="doctag">@return</span></div><div class="line">    */</div><div class="line">   <span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">overScrollBy</span><span class="params">(<span class="keyword">int</span> deltaX, <span class="keyword">int</span> deltaY, <span class="keyword">int</span> scrollX, <span class="keyword">int</span> scrollY, <span class="keyword">int</span> scrollRangeX, <span class="keyword">int</span> scrollRangeY, <span class="keyword">int</span> maxOverScrollX, <span class="keyword">int</span> maxOverScrollY, <span class="keyword">boolean</span> isTouchEvent)</span> </span>&#123;</div><div class="line">       <span class="keyword">if</span> (deltaY &lt; <span class="number">0</span> &amp;&amp; isTouchEvent) &#123;</div><div class="line">           <span class="keyword">int</span> newHeight = parallaxImageView.getHeight() - deltaY / <span class="number">3</span>;     <span class="comment">//新的高度增加与手指拖动的距离不成正比，</span></div><div class="line">           <span class="comment">//达到拖动吃力的效果</span></div><div class="line">           <span class="keyword">if</span> (newHeight &gt; maxHeight) newHeight = maxHeight;</div><div class="line">           <span class="keyword">if</span> (parallaxImageView != <span class="keyword">null</span>) &#123;</div><div class="line">               parallaxImageView.getLayoutParams().height = newHeight;</div><div class="line">               parallaxImageView.requestLayout();                              <span class="comment">//当完成高度设置后，需要调用重新布局方法</span></div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="keyword">return</span> <span class="keyword">super</span>.overScrollBy(deltaX, deltaY, scrollX, scrollY, scrollRangeX, scrollRangeY, maxOverScrollX, maxOverScrollY, isTouchEvent);</div><div class="line"></div><div class="line">   &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>在<code>MainActivity</code>中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> ImageView parallaxImageView = (ImageView) mHeadView.findViewById(R.id.imageView);</div><div class="line">       <span class="comment">//当从xml中加载完成后，才能知道imageview的长高</span></div><div class="line">       mHeadView.getViewTreeObserver().addOnGlobalLayoutListener(<span class="keyword">new</span> OnGlobalLayoutListener() 		&#123;</div><div class="line">           <span class="meta">@SuppressLint</span>(<span class="string">"NewApi"</span>)</div><div class="line">           <span class="meta">@Override</span></div><div class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onGlobalLayout</span><span class="params">()</span> </span>&#123;</div><div class="line">               mListView.setParallaxImageView(parallaxImageView);</div><div class="line">               mHeadView.getViewTreeObserver().removeOnGlobalLayoutListener(<span class="keyword">this</span>);  <span class="comment">//取消当前的观察者</span></div><div class="line">           &#125;</div><div class="line">       &#125;);</div><div class="line">       mAdapter = <span class="keyword">new</span> MyAdapter(<span class="keyword">this</span>, R.layout.list_item, lists);</div><div class="line">       mListView.setAdapter(mAdapter);</div></pre></td></tr></table></figure>
<h3 id="设置动画"><a href="#设置动画" class="headerlink" title="设置动画"></a>设置动画</h3><pre><code>当手指抬起时，希望头部View可以慢慢地回到原来的大小。
为达到此目的，可以先自定义Animation    ,在构造方法中传入需要动画效果的View，覆写applyTransformation方法，
该方法会传入interpolatedTime参数，表示当前动画进行的时间百分比，据此可以设置每一帧View的属性，达到动画的效果。
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResetHeightAnimation</span> <span class="keyword">extends</span> <span class="title">Animation</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> mOriginalHeight, mTargetHeight;</div><div class="line">    <span class="keyword">int</span> totalValue;</div><div class="line">    View mView;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ResetHeightAnimation</span><span class="params">(View view, <span class="keyword">int</span> targetHeight)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>();</div><div class="line">        mTargetHeight = targetHeight;</div><div class="line">        mView = view;</div><div class="line">        mOriginalHeight = mView.getHeight();</div><div class="line">        totalValue = mTargetHeight - mOriginalHeight;</div><div class="line"></div><div class="line">        setDuration(<span class="number">400</span>);</div><div class="line">        setInterpolator(<span class="keyword">new</span> OvershootInterpolator()); <span class="comment">//设置加速器</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * <span class="doctag">@param</span> interpolatedTime 标示动画执行的精度或者百分比</div><div class="line">     *                         范围在0~1，对于每一个进度，我都可以在此方法中为制定的view设置属性，</div><div class="line">     *                         达到动画额效果</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">applyTransformation</span><span class="params">(<span class="keyword">float</span> interpolatedTime, Transformation t)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.applyTransformation(interpolatedTime, t);</div><div class="line">        <span class="keyword">int</span> newHeight = (<span class="keyword">int</span>) (mOriginalHeight + totalValue * interpolatedTime);</div><div class="line">        mView.getLayoutParams().height = newHeight;</div><div class="line">        mView.requestLayout();</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><p><a href="https://github.com/FelixZhang00/My_HeadParallax" target="_blank" rel="external">github</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android快速索引条控件]]></title>
      <url>http://felixzhang00.github.io/2015/04/25/2015-04-25-Android%E5%BF%AB%E9%80%9F%E7%B4%A2%E5%BC%95%E6%9D%A1%E6%8E%A7%E4%BB%B6/</url>
      <content type="html"><![CDATA[<h2 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h2><p><img src="http://7viip0.com1.z0.glb.clouddn.com/2015-04-25 快速索引条.gif"></p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="自定义view，画出静态的图形"><a href="#自定义view，画出静态的图形" class="headerlink" title="自定义view，画出静态的图形"></a>自定义view，画出静态的图形</h3><pre><code>在canvas上指定好位置，用各种画笔Paint，重要的是分析的过程。
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">private</span> Paint paint;</div><div class="line">   <span class="keyword">private</span> <span class="keyword">int</span> cellWidth, cellHeight;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</div><div class="line">       paint = <span class="keyword">new</span> Paint();</div><div class="line">       paint.setTextSize(<span class="number">40</span>);</div><div class="line">       paint.setColor(Color.WHITE);</div><div class="line">       paint.setTypeface(Typeface.DEFAULT_BOLD);</div><div class="line">       paint.setAntiAlias(<span class="keyword">true</span>);</div><div class="line">   &#125;</div><div class="line"></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</div><div class="line">   <span class="keyword">super</span>.onDraw(canvas);</div><div class="line">   <span class="keyword">if</span> (cellHeight == <span class="number">0</span>) cellHeight = getMeasuredHeight() / indexs.length;</div><div class="line">   <span class="keyword">if</span> (cellWidth == <span class="number">0</span>) cellWidth = getMeasuredWidth();</div><div class="line"></div><div class="line">   <span class="comment">//分别画26个字母</span></div><div class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; indexs.length; i++) &#123;</div><div class="line"></div><div class="line">       <span class="comment">//先测量用此画笔画字母的大小，用一个矩形把它包裹起来，这样方便计算字母的高度</span></div><div class="line">       Rect bounds = <span class="keyword">new</span> Rect();</div><div class="line">       paint.getTextBounds(indexs[i], <span class="number">0</span>, indexs[i].length(), bounds);</div><div class="line"></div><div class="line">       <span class="comment">//计算画每个字母的起始坐标</span></div><div class="line">       <span class="keyword">float</span> x = cellWidth / <span class="number">2</span> - paint.measureText(indexs[i]) / <span class="number">2</span>;</div><div class="line">       <span class="keyword">float</span> y = cellHeight / <span class="number">2</span> + bounds.height() / <span class="number">2</span> + i * cellHeight;</div><div class="line">       canvas.drawText(indexs[i], x, y, paint);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="实现onTouch事件，完成动态效果"><a href="#实现onTouch事件，完成动态效果" class="headerlink" title="实现onTouch事件，完成动态效果"></a>实现onTouch事件，完成动态效果</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">	<span class="keyword">private</span> <span class="keyword">int</span> lastIndex = -<span class="number">1</span>;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> x = (<span class="keyword">int</span>) event.getX();</div><div class="line"><span class="comment">//        if (x &gt;= 0 &amp;&amp; x &lt;= cellWidth) &#123;  //只对quickindexbar的触摸事件有效</span></div><div class="line"><span class="comment">//            return false;</span></div><div class="line"><span class="comment">//        &#125;</span></div><div class="line">        <span class="keyword">int</span> y = (<span class="keyword">int</span>) event.getY();</div><div class="line">        <span class="keyword">switch</span> (event.getAction()) &#123;</div><div class="line">            <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</div><div class="line">            <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</div><div class="line">                <span class="keyword">if</span> (isSameIndex(y / cellHeight)) <span class="keyword">break</span>;</div><div class="line"></div><div class="line"></div><div class="line">                String word = indexs[((<span class="keyword">int</span>) (y / cellHeight))];</div><div class="line">                lastIndex = y / cellHeight;</div><div class="line">                <span class="keyword">if</span> (mIndexChangedListener != <span class="keyword">null</span>) &#123;</div><div class="line">                    mIndexChangedListener.indexChanged(word);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> MotionEvent.ACTION_UP:</div><div class="line">                lastIndex = -<span class="number">1</span>;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">default</span>:</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//自行处理触摸事件，不向上传递</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 当前的索引位置是否和上一个相等</div><div class="line">     *</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isSameIndex</span><span class="params">(<span class="keyword">int</span> currIndex)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> lastIndex == currIndex;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> IndexChangedListener mIndexChangedListener;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIndexChangedListener</span><span class="params">(IndexChangedListener indexChangedListener)</span> </span>&#123;</div><div class="line">        mIndexChangedListener = indexChangedListener;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IndexChangedListener</span> </span>&#123;</div><div class="line">        <span class="function"><span class="keyword">void</span> <span class="title">indexChanged</span><span class="params">(String word)</span></span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="给触摸事件添加更加人性化的交互"><a href="#给触摸事件添加更加人性化的交互" class="headerlink" title="给触摸事件添加更加人性化的交互"></a>给触摸事件添加更加人性化的交互</h3><h4 id="QuickIndexBar交互效果的实现"><a href="#QuickIndexBar交互效果的实现" class="headerlink" title="QuickIndexBar交互效果的实现"></a>QuickIndexBar交互效果的实现</h4><pre><code>在处理onTouch事件时，改变画笔的设置，画出不同的图案。

在onTouch中调用
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">//重新调用onDraw</span></div><div class="line">invalidate();</div></pre></td></tr></table></figure>
<pre><code>在onDraw中增加下面的逻辑：
画每个元素之前先设置不同的画笔。    
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">if</span> (i == lastIndex) &#123;               <span class="comment">//正在touch的位置 需要更加人性化的交互</span></div><div class="line">   paint.setTextSize(<span class="number">60</span>);</div><div class="line">   paint.setColor(Color.GRAY);</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">   paint.setTextSize(<span class="number">40</span>);</div><div class="line">   paint.setColor(Color.WHITE);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="中间放大框的实现"><a href="#中间放大框的实现" class="headerlink" title="中间放大框的实现"></a>中间放大框的实现</h4><pre><code>当前Activity接受到QuickIndexBar的变化事件后，调用showIndexLabel方法，通过handler完成延迟操作。
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">private</span> Handler mHandler = <span class="keyword">new</span> Handler();</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">showIndexLabel</span><span class="params">(String word)</span> </span>&#123;</div><div class="line">   mLabel.setVisibility(View.VISIBLE);</div><div class="line">   mLabel.setText(word);</div><div class="line"></div><div class="line">   mHandler.removeCallbacksAndMessages(<span class="keyword">null</span>); <span class="comment">//移除所有消息队列</span></div><div class="line">   mHandler.postDelayed(<span class="keyword">new</span> Runnable() &#123;      <span class="comment">//发送延时消息</span></div><div class="line">       <span class="meta">@Override</span></div><div class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">           mLabel.setVisibility(View.GONE);</div><div class="line">       &#125;</div><div class="line">   &#125;, DEFAULT_DELAY);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><p><a href="https://github.com/FelixZhang00/My_QuickIndexBar" target="_blank" rel="external">github</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[HTML5动态时钟]]></title>
      <url>http://felixzhang00.github.io/2015/04/20/2015-04-20-HTML5%E5%8A%A8%E6%80%81%E6%97%B6%E9%92%9F/</url>
      <content type="html"><![CDATA[<p>##效果图</p>
<p><canvas id="mycanvas" width="500" height="500" style="background: #B0D141"></canvas></p>
<script>
            var mycanvas = document.getElementById("mycanvas");
            var context = mycanvas.getContext("2d");

            function drawClock() {
                //每次调用函数都要对指定区域清屏
                context.clearRect(0, 0, 500, 500);
                var date = new Date();
                var hour = date.getHours();
                var min = date.getMinutes();
                var sec = date.getSeconds();
                hour = (hour >= 12) ? hour - 12 : hour;
                hour = hour + min / 60;
                min = min + sec / 60;

                //画圆
                context.lineWidth=10;
                context.strokeStyle='#000';
                context.beginPath();
                context.arc(250, 250, 200, 0, 360, false);
                context.closePath();
                context.stroke();



                //画时刻度

                for (var i = 0; i < 12; i++) {
                    context.save();
                    context.strokeStyle='black';
                    context.beginPath();
                    context.translate(250, 250);
                    context.rotate(i * 30 * Math.PI / 180);
                    context.beginPath();
                    context.moveTo(0, -190);
                    context.lineTo(0, -170);
                    context.closePath();
                    context.stroke();
                    context.restore();
                }


                //画分刻度
                context.beginPath();
                for (var i = 0; i < 60; i++) {
                    context.save();
                    context.strokeStyle='black';
                    context.beginPath();
                    context.translate(250, 250);
                    context.rotate(i * 6 * Math.PI / 180);
                    context.moveTo(0, -190);
                    context.lineTo(0, -180);
                    context.closePath();
                    context.stroke();
                    context.restore();
                }


                //画时针
                context.save();
                context.lineWidth=12;
                context.beginPath();
                context.translate(250, 250);
                context.rotate(hour * Math.PI * 30 / 180);
                context.moveTo(0, -135);
                context.lineTo(0, 10);
                context.closePath();
                context.stroke();
                context.restore();

                //画分针
                context.save();
                context.lineWidth=8;
                context.beginPath();
                context.translate(250, 250);
                context.rotate(min * Math.PI * 6 / 180);
                context.moveTo(0, -160);
                context.lineTo(0, 10);
                context.closePath();
                context.stroke();
                context.restore();

                //画秒针
                context.save();
                context.lineWidth=5;
                context.strokeStyle='red';
                context.beginPath();
                context.translate(250, 250);
                context.rotate(sec * Math.PI * 6 / 180);
                context.moveTo(0, -182);
                context.lineTo(0, 16);
                context.closePath();
                context.stroke();
                context.restore();
            }
            setInterval(drawClock, 1000);
        </script>


<p>##原理<br>    先打上html5中的canvas标签，它定义了一块画布，可以用javascript在上前面做动态效果。<br>    调用浏览器内置对象window的setInterval（animate，delay）方法，可以实现每隔delay时间调用一次自定义的animate方法，从而达到动态的效果。</p>
<p>##代码实现<br>    <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div></pre></td><td class="code"><pre><div class="line">&lt;body&gt;</div><div class="line"><span class="xml"><span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">"mycanvas"</span> <span class="attr">width</span>=<span class="string">"500"</span> <span class="attr">height</span>=<span class="string">"500"</span> <span class="attr">style</span>=<span class="string">"background: #B0D141"</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span></div><div class="line">&lt;script&gt;</div><div class="line">		<span class="keyword">var</span> mycanvas = <span class="built_in">document</span>.getElementById(<span class="string">"mycanvas"</span>);</div><div class="line">		<span class="keyword">var</span> context = mycanvas.getContext(<span class="string">"2d"</span>);</div><div class="line"></div><div class="line">		<span class="function"><span class="keyword">function</span> <span class="title">drawClock</span>(<span class="params"></span>) </span>&#123;</div><div class="line">			<span class="comment">//每次调用函数都要对指定区域清屏</span></div><div class="line">			context.clearRect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">500</span>, <span class="number">500</span>);</div><div class="line">			<span class="keyword">var</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>();</div><div class="line">			<span class="keyword">var</span> hour = date.getHours();</div><div class="line">			<span class="keyword">var</span> min = date.getMinutes();</div><div class="line">			<span class="keyword">var</span> sec = date.getSeconds();</div><div class="line">			hour = (hour &gt;= <span class="number">12</span>) ? hour - <span class="number">12</span> : hour;</div><div class="line">			hour = hour + min / <span class="number">60</span>;</div><div class="line">			min = min + sec / <span class="number">60</span>;</div><div class="line"></div><div class="line">			<span class="comment">//画圆</span></div><div class="line">			context.lineWidth=<span class="number">10</span>;</div><div class="line">			context.strokeStyle=<span class="string">'#000'</span>;</div><div class="line">			context.beginPath();</div><div class="line">			context.arc(<span class="number">250</span>, <span class="number">250</span>, <span class="number">200</span>, <span class="number">0</span>, <span class="number">360</span>, <span class="literal">false</span>);</div><div class="line">			context.closePath();</div><div class="line">			context.stroke();</div><div class="line">			</div><div class="line">			</div><div class="line"></div><div class="line">			<span class="comment">//画时刻度</span></div><div class="line"></div><div class="line">			<span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">12</span>; i++) &#123;</div><div class="line">				context.save();</div><div class="line">				context.strokeStyle=<span class="string">'black'</span>;</div><div class="line">				context.beginPath();</div><div class="line">				context.translate(<span class="number">250</span>, <span class="number">250</span>);</div><div class="line">				context.rotate(i * <span class="number">30</span> * <span class="built_in">Math</span>.PI / <span class="number">180</span>);</div><div class="line">				context.beginPath();</div><div class="line">				context.moveTo(<span class="number">0</span>, <span class="number">-190</span>);</div><div class="line">				context.lineTo(<span class="number">0</span>, <span class="number">-170</span>);</div><div class="line">				context.closePath();</div><div class="line">				context.stroke();</div><div class="line">				context.restore();</div><div class="line">			&#125;</div><div class="line"></div><div class="line"></div><div class="line">			<span class="comment">//画分刻度</span></div><div class="line">			context.beginPath();</div><div class="line">			<span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">60</span>; i++) &#123;</div><div class="line">				context.save();</div><div class="line">				context.strokeStyle=<span class="string">'black'</span>;</div><div class="line">				context.beginPath();</div><div class="line">				context.translate(<span class="number">250</span>, <span class="number">250</span>);</div><div class="line">				context.rotate(i * <span class="number">6</span> * <span class="built_in">Math</span>.PI / <span class="number">180</span>);</div><div class="line">				context.moveTo(<span class="number">0</span>, <span class="number">-190</span>);</div><div class="line">				context.lineTo(<span class="number">0</span>, <span class="number">-180</span>);</div><div class="line">				context.closePath();</div><div class="line">				context.stroke();</div><div class="line">				context.restore();</div><div class="line">			&#125;</div><div class="line"></div><div class="line"></div><div class="line">			<span class="comment">//画时针</span></div><div class="line">			context.save();</div><div class="line">			context.lineWidth=<span class="number">12</span>;</div><div class="line">			context.beginPath();</div><div class="line">			context.translate(<span class="number">250</span>, <span class="number">250</span>);</div><div class="line">			context.rotate(hour * <span class="built_in">Math</span>.PI * <span class="number">30</span> / <span class="number">180</span>);</div><div class="line">			context.moveTo(<span class="number">0</span>, <span class="number">-135</span>);</div><div class="line">			context.lineTo(<span class="number">0</span>, <span class="number">10</span>);</div><div class="line">			context.closePath();</div><div class="line">			context.stroke();</div><div class="line">			context.restore();</div><div class="line"></div><div class="line">			<span class="comment">//画分针</span></div><div class="line">			context.save();</div><div class="line">			context.lineWidth=<span class="number">8</span>;</div><div class="line">			context.beginPath();</div><div class="line">			context.translate(<span class="number">250</span>, <span class="number">250</span>);</div><div class="line">			context.rotate(min * <span class="built_in">Math</span>.PI * <span class="number">6</span> / <span class="number">180</span>);</div><div class="line">			context.moveTo(<span class="number">0</span>, <span class="number">-160</span>);</div><div class="line">			context.lineTo(<span class="number">0</span>, <span class="number">10</span>);</div><div class="line">			context.closePath();</div><div class="line">			context.stroke();</div><div class="line">			context.restore();</div><div class="line"></div><div class="line">			<span class="comment">//画秒针</span></div><div class="line">			context.save();</div><div class="line">			context.lineWidth=<span class="number">5</span>;</div><div class="line">			context.strokeStyle=<span class="string">'red'</span>;</div><div class="line">			context.beginPath();</div><div class="line">			context.translate(<span class="number">250</span>, <span class="number">250</span>);</div><div class="line">			context.rotate(sec * <span class="built_in">Math</span>.PI * <span class="number">6</span> / <span class="number">180</span>);</div><div class="line">			context.moveTo(<span class="number">0</span>, <span class="number">-182</span>);</div><div class="line">			context.lineTo(<span class="number">0</span>, <span class="number">16</span>);</div><div class="line">			context.closePath();</div><div class="line">			context.stroke();</div><div class="line">			context.restore();</div><div class="line">		&#125;</div><div class="line">		setInterval(drawClock, <span class="number">1000</span>);</div><div class="line">	<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></div><div class="line">	&lt;body/&gt;</div></pre></td></tr></table></figure></p>
<p>##后记<br>没想到markdown还能支持javascript。这样以后可以通过类似的方法在blog中用js做动态效果了。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[在AndroidStudio编译过程中遇到Error:duplicate files during packaging of APK问题的解决方法]]></title>
      <url>http://felixzhang00.github.io/2015/04/20/2015-04-20-AndroidStudio%E7%BC%96%E8%AF%91%E6%8A%A5%E9%94%99/</url>
      <content type="html"><![CDATA[<p>##问题描述<br>    Error:duplicate files during packaging of APK /Users/sample/app/build/outputs/apk/app-debug-unaligned.apk</p>
<pre><code>Path in archive: META-INF/LICENSE.txt

Origin 1: /Users/sample/app/libs/commons-codec-1.3.jar

Origin 2: /Users/sample/app/libs/commons-httpclient-3.1.jar
</code></pre><p>##问题原因<br>libs文件夹下的多个jar包中有相同的<code>LICENSE.txt</code> 、<code>NOTICE.txt</code>文件，所以编译器会报重复文件的错误。</p>
<p>##解决方案<br>只需要在<code>build.gradle</code>文件中添加如下内容即可</p>
<pre><code>android {
packagingOptions {
    exclude &apos;META-INF/LICENSE.txt&apos;
    exclude &apos;META-INF/NOTICE.txt&apos;
}
}
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[多个Listview瀑布流效果]]></title>
      <url>http://felixzhang00.github.io/2015/04/19/2015-04-19-%E5%A4%9A%E4%B8%AAListview%E7%80%91%E5%B8%83%E6%B5%81%E6%95%88%E6%9E%9C/</url>
      <content type="html"><![CDATA[<h2 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h2><p><img src="http://7viip0.com1.z0.glb.clouddn.com/2015-04-19-bloglistview瀑布流.gif"></p>
<h2 id="原理解释"><a href="#原理解释" class="headerlink" title="原理解释"></a>原理解释</h2><pre><code>自定义MyLinearLayout，继承至LinearLayout，在布局文件中，将3个listview放置在MyLinearLayout中。
重写MyLinearLayout中的onInterceptTouchEvent方法，返回true，打断向listview传递的触摸事件。
重写onTouchEvent方法，根据触摸位置，将触摸事件通过调用子view的dispatchTouchEvent方法，传递给相应位置的listview。
listview接受到触摸事件后就可以自行处理相关的滑动逻辑。
</code></pre><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="界面布局"><a href="#界面布局" class="headerlink" title="界面布局"></a>界面布局</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">jamffy.example.waterfalllistview.MyLinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://	schemas.android.com/apk/res/android"</span></span></div><div class="line">   <span class="attr">xmlns:tools</span>=<span class="string">"http://schemas.android.com/tools"</span></div><div class="line">   <span class="attr">android:id</span>=<span class="string">"@+id/layout"</span></div><div class="line">   <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></div><div class="line">   <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></div><div class="line">   <span class="attr">tools:context</span>=<span class="string">"jamffy.example.waterfalllistview.MainActivity"</span> &gt;</div><div class="line"></div><div class="line">   <span class="tag">&lt;<span class="name">ListView</span></span></div><div class="line">       <span class="attr">android:id</span>=<span class="string">"@+id/lv1"</span></div><div class="line">       <span class="attr">android:layout_width</span>=<span class="string">"0dp"</span></div><div class="line">       <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></div><div class="line">       <span class="attr">android:layout_margin</span>=<span class="string">"5dp"</span></div><div class="line">       <span class="attr">android:layout_weight</span>=<span class="string">"1"</span></div><div class="line">       <span class="attr">android:divider</span>=<span class="string">"@null"</span></div><div class="line">       <span class="attr">android:dividerHeight</span>=<span class="string">"5dp"</span></div><div class="line">       <span class="attr">android:scrollbars</span>=<span class="string">"none"</span> &gt;</div><div class="line">   <span class="tag">&lt;/<span class="name">ListView</span>&gt;</span></div><div class="line"></div><div class="line">   <span class="tag">&lt;<span class="name">ListView</span></span></div><div class="line">       <span class="attr">android:id</span>=<span class="string">"@+id/lv2"</span></div><div class="line">       <span class="attr">android:layout_width</span>=<span class="string">"0dp"</span></div><div class="line">       <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></div><div class="line">       <span class="attr">android:layout_margin</span>=<span class="string">"5dp"</span></div><div class="line">       <span class="attr">android:layout_weight</span>=<span class="string">"1"</span></div><div class="line">       <span class="attr">android:divider</span>=<span class="string">"@null"</span></div><div class="line">       <span class="attr">android:dividerHeight</span>=<span class="string">"5dp"</span></div><div class="line">       <span class="attr">android:scrollbars</span>=<span class="string">"none"</span> &gt;</div><div class="line">   <span class="tag">&lt;/<span class="name">ListView</span>&gt;</span></div><div class="line"></div><div class="line">   <span class="tag">&lt;<span class="name">ListView</span></span></div><div class="line">       <span class="attr">android:id</span>=<span class="string">"@+id/lv3"</span></div><div class="line">       <span class="attr">android:layout_width</span>=<span class="string">"0dp"</span></div><div class="line">       <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></div><div class="line">       <span class="attr">android:layout_margin</span>=<span class="string">"5dp"</span></div><div class="line">       <span class="attr">android:layout_weight</span>=<span class="string">"1"</span></div><div class="line">       <span class="attr">android:divider</span>=<span class="string">"@null"</span></div><div class="line">       <span class="attr">android:dividerHeight</span>=<span class="string">"5dp"</span></div><div class="line">       <span class="attr">android:scrollbars</span>=<span class="string">"none"</span> &gt;</div><div class="line">   <span class="tag">&lt;/<span class="name">ListView</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">jamffy.example.waterfalllistview.MyLinearLayout</span>&gt;</span></div></pre></td></tr></table></figure>
<h3 id="自定义控件"><a href="#自定义控件" class="headerlink" title="自定义控件"></a>自定义控件</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * <span class="doctag">@author</span> tmac 如果不做处理MyLinearLayout中的子view能自行处理touch事件。</div><div class="line">	 *         现在我希望当我在屏幕中间上方拖动时，整个屏幕的子view一起向上拖动，</div><div class="line">	 *         这是就需要在满足条件时，中断该touch事件，交给MyLinearLayout这个父view来处理。</div><div class="line">	 *         先中断所有子view的touch事件，然后根据触摸的位置，有父view把点击事件分发给相应的子view。</div><div class="line">	 *         在分发之前需要给touch事件的对象event重新设置位置，因为子view的坐标系与父view是不同的。</div><div class="line">	 */</div><div class="line"></div><div class="line">	<span class="comment">// 这个类专门为三个子listview服务。</span></div><div class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyLinearLayout</span> <span class="keyword">extends</span> <span class="title">LinearLayout</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyLinearLayout</span><span class="params">(Context context)</span> </span>&#123;</div><div class="line">		<span class="keyword">super</span>(context);</div><div class="line">		<span class="comment">// TODO Auto-generated constructor stub</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyLinearLayout</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</div><div class="line">		<span class="keyword">super</span>(context, attrs);</div><div class="line">		<span class="comment">// TODO Auto-generated constructor stub</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="comment">// 返回true中断点击事件</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onInterceptTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="comment">// 用分发的方式决定哪个子view可以收到点击事件</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		<span class="keyword">return</span> <span class="keyword">super</span>.dispatchTouchEvent(ev);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</div><div class="line">		<span class="keyword">int</span> count = getChildCount();</div><div class="line">		<span class="comment">// 每个子view的宽度</span></div><div class="line">		<span class="keyword">int</span> width = getWidth() / count;</div><div class="line">		<span class="keyword">int</span> height = getHeight();</div><div class="line"></div><div class="line">		<span class="comment">// 当前触摸的位置</span></div><div class="line">		<span class="keyword">int</span> currX = (<span class="keyword">int</span>) event.getX();</div><div class="line">		<span class="keyword">int</span> currY = (<span class="keyword">int</span>) event.getY();</div><div class="line">		<span class="comment">// 判断位置</span></div><div class="line">		<span class="keyword">if</span> (currX &lt; width) &#123; <span class="comment">// 处理最左边的逻辑</span></div><div class="line">			<span class="comment">// 在分发之前需要给touch事件的对象event重新设置位置，因为子view的坐标系与父view是不同的。</span></div><div class="line">			event.setLocation(width / <span class="number">2</span>, currY);</div><div class="line">			getChildAt(<span class="number">0</span>).dispatchTouchEvent(event);</div><div class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (currX &lt; <span class="number">2</span> * width) &#123; <span class="comment">// 处理中间的逻辑</span></div><div class="line">			<span class="keyword">if</span> (currY &gt; height / <span class="number">2</span>) &#123; <span class="comment">// 如果在下方，只移动中间的子view</span></div><div class="line">				event.setLocation(width / <span class="number">2</span>, currY);</div><div class="line">				getChildAt(<span class="number">1</span>).dispatchTouchEvent(event);</div><div class="line">				<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">			&#125; <span class="keyword">else</span> &#123;<span class="comment">// 如果在上方，拖动三个view</span></div><div class="line">				event.setLocation(width, currY);</div><div class="line">			<span class="comment">// 同时把touch事件分发给三个子view</span></div><div class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;count;i++)&#123;</div><div class="line">					getChildAt(i).dispatchTouchEvent(event);</div><div class="line">				&#125;</div><div class="line">				<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">			&#125;</div><div class="line"></div><div class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (currX &lt; <span class="number">3</span> * width) &#123; <span class="comment">// 处理最右边的逻辑</span></div><div class="line">			event.setLocation(width / <span class="number">2</span>, currY);</div><div class="line">			getChildAt(<span class="number">2</span>).dispatchTouchEvent(event);</div><div class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line"></div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><p><a href="https://github.com/FelixZhang00/ALD04/tree/master/WaterFallListView" target="_blank" rel="external">github</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode第13题--Roman to Integer（Java实现）]]></title>
      <url>http://felixzhang00.github.io/2015/04/08/2015-04-08-LeetCode%E7%AC%AC13%E9%A2%98--Roman%20to%20Integer/</url>
      <content type="html"><![CDATA[<h2 id="原题"><a href="#原题" class="headerlink" title="原题"></a><a href="https://leetcode.com/problems/roman-to-integer/" target="_blank" rel="external">原题</a></h2><p>Given a roman numeral, convert it to an integer.</p>
<p>Input is guaranteed to be within the range from 1 to 3999.</p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="先弄明白什么是罗马数字："><a href="#先弄明白什么是罗马数字：" class="headerlink" title="先弄明白什么是罗马数字："></a>先弄明白什么是罗马数字：</h4><p>这7个符号与10进制阿拉伯数字的对应关系是：<br><br>I=1；X=10；C=100；M=1000；　<br><br>V=5；L=50；D=500；<br></p>
<p>罗马数字编码规则如下：</p>
<pre><code>1.编码最短，左减右加；
2.加减不能跨“数量级”；
3.减不过1，加不过3；    
</code></pre><h4 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h4><p>找到字符串中最大的字符，找到其对应的数字，递归地做左减右加。</p>
<h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</div><div class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Character, Integer&gt;();</div><div class="line">   <span class="keyword">static</span> &#123;</div><div class="line">       map.put(<span class="string">'I'</span>, <span class="number">1</span>);</div><div class="line">       map.put(<span class="string">'V'</span>, <span class="number">5</span>);</div><div class="line">       map.put(<span class="string">'X'</span>, <span class="number">10</span>);</div><div class="line">       map.put(<span class="string">'L'</span>, <span class="number">50</span>);</div><div class="line">       map.put(<span class="string">'C'</span>, <span class="number">100</span>);</div><div class="line">       map.put(<span class="string">'D'</span>, <span class="number">500</span>);</div><div class="line">       map.put(<span class="string">'M'</span>, <span class="number">1000</span>);</div><div class="line">   &#125;</div><div class="line"></div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">       <span class="keyword">return</span> romanToIntSelf(s, <span class="number">0</span>, s.length());</div><div class="line"></div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">romanToIntSelf</span><span class="params">(String s, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</div><div class="line">       <span class="keyword">if</span> (start &gt;= end) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        <span class="comment">//特别注意：result就在递归，第一个递归函数的result用来回收左右递归所返回的值，并累加中间的值。</span></div><div class="line">       <span class="keyword">int</span> result = <span class="number">0</span>;</div><div class="line">       <span class="keyword">int</span> maxIndex = findMaxIndex(s, start, end);</div><div class="line">       <span class="keyword">char</span> max = s.charAt(maxIndex);</div><div class="line">       result += map.get(max);</div><div class="line">       result += romanToIntSelf(s, maxIndex + <span class="number">1</span>, end);</div><div class="line">       result -= romanToIntSelf(s, start, maxIndex);</div><div class="line">       <span class="keyword">return</span> result;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="comment">/**</span></div><div class="line"> * 找到字符串中表示最大的罗马数字支付串所在的位置</div><div class="line">    *</div><div class="line">    * <span class="doctag">@param</span> s</div><div class="line">    * <span class="doctag">@param</span> start inclusive</div><div class="line">    * <span class="doctag">@param</span> end   exclusive</div><div class="line">    */</div><div class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findMaxIndex</span><span class="params">(String s, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</div><div class="line">       <span class="keyword">char</span> temp = s.charAt(start);</div><div class="line">       <span class="keyword">int</span> result = start;</div><div class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = start + <span class="number">1</span>; i &lt; end; i++) &#123;</div><div class="line">           <span class="keyword">if</span> (bigger(s.charAt(i), temp)) &#123;</div><div class="line">               result = i;</div><div class="line">               temp = s.charAt(i);</div><div class="line">           &#125;</div><div class="line"></div><div class="line">       &#125;</div><div class="line">       <span class="keyword">return</span> result;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="comment">/**</span></div><div class="line">    * is c1 in romandigit bigger than c2</div><div class="line">    *</div><div class="line">    * <span class="doctag">@return</span></div><div class="line">    */</div><div class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">bigger</span><span class="params">(<span class="keyword">char</span> c1, <span class="keyword">char</span> c2)</span> </span>&#123;</div><div class="line">       <span class="keyword">return</span> map.get(c1) &gt; map.get(c2);</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="class"><span class="keyword">class</span> <span class="title">RomanDigit</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">RomanDigit</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">       <span class="function"><span class="keyword">public</span> <span class="title">RomanDigit</span><span class="params">()</span> </span>&#123;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="meta">@Override</span></div><div class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(RomanDigit r)</span> </span>&#123;</div><div class="line">           <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">       Solution solution = <span class="keyword">new</span> Solution();</div><div class="line">       String s = <span class="string">"XCIX"</span>; <span class="comment">//99</span></div><div class="line">       System.out.println(solution.findMaxIndex(s, <span class="number">0</span>, s.length()));</div><div class="line">       System.out.println(solution.romanToInt(s));</div><div class="line"></div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Programming Assignment 2 Seam Carving 暴力实现]]></title>
      <url>http://felixzhang00.github.io/2015/04/04/2015-04-04-Programming%20Assignment%202-%20Seam%20Carving%20%E6%9A%B4%E5%8A%9B%E5%AE%9E%E7%8E%B0/</url>
      <content type="html"><![CDATA[<p>Robert Sedgewick教授在Coursera上开了一门<a href="https://class.coursera.org/algs4partII-005" target="_blank" rel="external">算法课</a>，这是图论中的一道<a href="https://class.coursera.org/algs4partII-005/assignment/view?assignment_id=9" target="_blank" rel="external">编程作业题</a>。</p>
<h2 id="问题概述"><a href="#问题概述" class="headerlink" title="问题概述"></a>问题概述</h2><p>图像由像素构成，可以看成是一张二维数组，其中的存储着Color，这样每个位置都有相应的颜色，就可以表示一张图片了。<br>这道题目的目的是resize图像，每次删除一行或一列颜色值最不明想的像素。</p>
<p>图像在二维数组中的表示 ：</p>
<pre><code>(255,101,51)        (255,101,153)        (255,101,255)  
(255,153,51)        (255,153,153)        (255,153,255)  
(255,203,51)        (255,204,153)        (255,205,255)  
(255,255,51)        (255,255,153)        (255,255,255)  
</code></pre><p>##解题思路</p>
<h3 id="能量函数"><a href="#能量函数" class="headerlink" title="能量函数"></a>能量函数</h3><p>如何界定某个像素是否明显，可以被删除呢？</p>
<pre><code>是否明显是由周围的像素决定的，基于此有公式
pixel（x,y）的能量函数表示为：
Δx2(x, y) + Δy2(x, y)
其中，Δx2(x, y) = Rx(x, y)2 + Gx(x, y)2 + Bx(x, y)2
Rx、Gx、Bx分别为为pixel(x+1,y)与pixel(x-1,y)对应RGB的差值。
Δy2(x, y)同理。
</code></pre><h3 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h3><p>我想到的暴力求解的笨办法是，将图像的位置映射成唯一的整型索引，并算出其能量函数的值，加上起始终点两个虚拟位置（它门的能量值都为0）以此构造一张加权有向图。找出起始点到终点的最短路径。</p>
<p><img src="http://7viip0.com1.z0.glb.clouddn.com/Seam-Carving-picture_seam.png" width="250" height="250" style="margin-left: 0px"></p>
<h3 id="顶点的权重"><a href="#顶点的权重" class="headerlink" title="顶点的权重"></a>顶点的权重</h3><p>加权有向图的权重是指边的权重，而上面构造的图形的权重值是在顶点中表示的，这需要转化为边的权重。这很简单，只需要将将一条边的两个顶点的权重相加表示成边的权重即可。</p>
<p>##算法实现</p>
<h3 id="能量函数-1"><a href="#能量函数-1" class="headerlink" title="能量函数"></a>能量函数</h3><pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> Picture mPicture; </div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> BORDER_ENERGY = <span class="number">255.0</span> * <span class="number">255</span> * <span class="number">3</span>;</div><div class="line"><span class="comment">/**</span></div><div class="line"> * energy of pixel at column x and row y</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">energy</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt;= width() || y &lt; <span class="number">0</span> || y &gt;= height()) <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException();</div><div class="line">    <span class="keyword">if</span> (isBorder(x, y)) <span class="keyword">return</span> BORDER_ENERGY;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> energyFun(mPicture.get(x - <span class="number">1</span>, y), mPicture.get(x + <span class="number">1</span>, y))</div><div class="line">            + energyFun(mPicture.get(x, y - <span class="number">1</span>), mPicture.get(x, y + <span class="number">1</span>));</div><div class="line"></div><div class="line">&#125;</div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">double</span> <span class="title">energyFun</span><span class="params">(Color color1, Color color2)</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> r1 = color1.getRed();</div><div class="line">    <span class="keyword">int</span> g1 = color1.getGreen();</div><div class="line">    <span class="keyword">int</span> b1 = color1.getBlue();</div><div class="line"></div><div class="line">    <span class="keyword">int</span> r2 = color2.getRed();</div><div class="line">    <span class="keyword">int</span> g2 = color2.getGreen();</div><div class="line">    <span class="keyword">int</span> b2 = color2.getBlue();</div><div class="line"></div><div class="line">    <span class="keyword">int</span> delta = square(r1 - r2) + square(g1 - g2) + square(b1 - b2);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> delta;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">square</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> i * i;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isBorder</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (x == <span class="number">0</span> || x == mPicture.width() - <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (y == <span class="number">0</span> || y == mPicture.height() - <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line"></div><div class="line">&#125;</div><div class="line">`</div></pre></td></tr></table></figure>
</code></pre><p>###找到垂直方向的最短路径<br>    <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">/**</span></div><div class="line">  * sequence of indices for vertical seam</div><div class="line">  *</div><div class="line">  * <span class="doctag">@return</span></div><div class="line">  */</div><div class="line"> <span class="keyword">public</span> <span class="keyword">int</span>[] findVerticalSeam() &#123;</div><div class="line">     <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[height()];</div><div class="line"></div><div class="line">     <span class="comment">//解法一：构造图</span></div><div class="line">     EdgeWeightedDigraph verticalG = buildVerticalGraph(width(), height());</div><div class="line">     AcyclicSP sp = <span class="keyword">new</span> AcyclicSP(verticalG, <span class="number">0</span>);</div><div class="line">     Iterable&lt;DirectedEdge&gt; edges = sp.pathTo(verticalG.V() - <span class="number">1</span>);</div><div class="line">     <span class="keyword">int</span> len = <span class="number">0</span>;</div><div class="line">     <span class="keyword">for</span> (DirectedEdge e : edges) &#123;</div><div class="line"><span class="comment">//StdOut.println(e); //调试 打印路径</span></div><div class="line"></div><div class="line">         <span class="keyword">int</span> v = e.from();</div><div class="line">         <span class="keyword">if</span> (v != <span class="number">0</span> &amp;&amp; v != (verticalG.V() - <span class="number">1</span>)) &#123;</div><div class="line">             result[len++] = convertToX(v);</div><div class="line">         &#125;</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     <span class="keyword">return</span> result;</div><div class="line"> &#125;</div><div class="line"> </div><div class="line">  <span class="comment">/**</span></div><div class="line">  * 将图中标示的点映射到相应的x值</div><div class="line">  *</div><div class="line">  * <span class="doctag">@param</span> v</div><div class="line">  * <span class="doctag">@return</span></div><div class="line">  */</div><div class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">convertToX</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</div><div class="line">     <span class="keyword">return</span> (v - <span class="number">1</span>) % width();</div><div class="line"> &#125;</div><div class="line"> </div><div class="line"> </div><div class="line">     <span class="comment">/**</span></div><div class="line">  * //构造图，将二维矩阵转化为唯一标示的整数作为图的顶点</div><div class="line">  * //顶点的权重转化为边的权重：一条边两个顶点的权重之和</div><div class="line">  * //上下两个虚拟点的energy为0，这样把最终算出来的总权重之和除以2就是原来最短路径的顶点的权重之和了</div><div class="line">  *</div><div class="line">  * <span class="doctag">@param</span> width</div><div class="line">  * <span class="doctag">@param</span> height</div><div class="line">  */</div><div class="line"> <span class="function"><span class="keyword">private</span> EdgeWeightedDigraph <span class="title">buildVerticalGraph</span><span class="params">(<span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</div><div class="line"></div><div class="line">     EdgeWeightedDigraph G = <span class="keyword">new</span> EdgeWeightedDigraph(width * height + <span class="number">2</span>);</div><div class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G.V() - <span class="number">1</span>; i++) &#123;  <span class="comment">//上方的起始虚拟点</span></div><div class="line">         <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</div><div class="line">             <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= width; j++) &#123;</div><div class="line">                 G.addEdge(<span class="keyword">new</span> DirectedEdge(<span class="number">0</span>, j, <span class="number">0</span> + energy(j - <span class="number">1</span>, <span class="number">0</span>)));</div><div class="line">             &#125;</div><div class="line">         &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &gt;= G.V() - <span class="number">1</span> - width) &#123;  <span class="comment">//最下方的所有点连接 下方的终点虚拟点</span></div><div class="line">             G.addEdge(<span class="keyword">new</span> DirectedEdge(i, G.V() - <span class="number">1</span>, energy((i - <span class="number">1</span>) % width, height - <span class="number">1</span>) + <span class="number">0</span>));</div><div class="line">         &#125; <span class="keyword">else</span> &#123;</div><div class="line">             <span class="keyword">int</span> fromX = (i - <span class="number">1</span>) % width;</div><div class="line">             <span class="keyword">int</span> fromY = (i - <span class="number">1</span>) / width;</div><div class="line">             <span class="keyword">int</span> toX = fromX; <span class="comment">//正下方</span></div><div class="line">             <span class="keyword">int</span> toY = fromY + <span class="number">1</span>;</div><div class="line">             <span class="keyword">if</span> ((i - <span class="number">1</span>) % width == <span class="number">0</span>) &#123; <span class="comment">//最左边的点(以排除最下方的最左侧的点)</span></div><div class="line">                 toX = fromX; <span class="comment">//正下方</span></div><div class="line">                 toY = fromY + <span class="number">1</span>;</div><div class="line">                 <span class="keyword">double</span> fromWeight = energy(fromX, fromY);</div><div class="line">                 <span class="keyword">double</span> toWeight = energy(toX, toY);</div><div class="line">                 G.addEdge(<span class="keyword">new</span> DirectedEdge(i, i + width, fromWeight + toWeight));</div><div class="line"></div><div class="line">                 toX = fromX + <span class="number">1</span>; <span class="comment">//右下方</span></div><div class="line">                 toY = fromY + <span class="number">1</span>;</div><div class="line">                 toWeight = energy(toX, toY);</div><div class="line">                 G.addEdge(<span class="keyword">new</span> DirectedEdge(i, i + width + <span class="number">1</span>, fromWeight + toWeight));</div><div class="line">             &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((i - <span class="number">1</span>) % width == (width - <span class="number">1</span>)) &#123;<span class="comment">//最右边的点（(以排除最下方的点）</span></div><div class="line">                 toX = fromX; <span class="comment">//正下方</span></div><div class="line">                 toY = fromY + <span class="number">1</span>;</div><div class="line">                 <span class="keyword">double</span> fromWeight = energy(fromX, fromY);</div><div class="line">                 <span class="keyword">double</span> toWeight = energy(toX, toY);</div><div class="line">                 G.addEdge(<span class="keyword">new</span> DirectedEdge(i, i + width, fromWeight + toWeight));</div><div class="line"></div><div class="line">                 toX = fromX - <span class="number">1</span>; <span class="comment">//左下方</span></div><div class="line">                 toY = fromY + <span class="number">1</span>;</div><div class="line">                 toWeight = energy(toX, toY);</div><div class="line">                 G.addEdge(<span class="keyword">new</span> DirectedEdge(i, i + width - <span class="number">1</span>, fromWeight + toWeight));</div><div class="line">             &#125; <span class="keyword">else</span> &#123; <span class="comment">//一般的点都有3个有向边发出（(以排除最下方的）</span></div><div class="line">                 toX = fromX; <span class="comment">//正下方</span></div><div class="line">                 toY = fromY + <span class="number">1</span>;</div><div class="line">                 <span class="keyword">double</span> fromWeight = energy(fromX, fromY);</div><div class="line">                 <span class="keyword">double</span> toWeight = energy(toX, toY);</div><div class="line">                 G.addEdge(<span class="keyword">new</span> DirectedEdge(i, i + width, fromWeight + toWeight));</div><div class="line"></div><div class="line">                 toX = fromX - <span class="number">1</span>; <span class="comment">//左下方</span></div><div class="line">                 toY = fromY + <span class="number">1</span>;</div><div class="line">                 toWeight = energy(toX, toY);</div><div class="line">                 G.addEdge(<span class="keyword">new</span> DirectedEdge(i, i + width - <span class="number">1</span>, fromWeight + toWeight));</div><div class="line"></div><div class="line">                 toX = fromX + <span class="number">1</span>; <span class="comment">//右下方</span></div><div class="line">                 toY = fromY + <span class="number">1</span>;</div><div class="line">                 toWeight = energy(toX, toY);</div><div class="line">                 G.addEdge(<span class="keyword">new</span> DirectedEdge(i, i + width + <span class="number">1</span>, fromWeight + toWeight));</div><div class="line">             &#125;</div><div class="line">         &#125;</div><div class="line"></div><div class="line"></div><div class="line">     &#125;</div><div class="line">     <span class="keyword">return</span> G;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<h3 id="从图像中删除垂直最短路径（即最不明显的像素）"><a href="#从图像中删除垂直最短路径（即最不明显的像素）" class="headerlink" title="从图像中删除垂直最短路径（即最不明显的像素）"></a>从图像中删除垂直最短路径（即最不明显的像素）</h3><pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">   * remove vertical seam from current picture</div><div class="line">   *</div><div class="line">   * <span class="doctag">@param</span> seam</div><div class="line">   */</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeVerticalSeam</span><span class="params">(<span class="keyword">int</span>[] seam)</span> </span>&#123;</div><div class="line">      <span class="keyword">if</span> (height() &lt;= <span class="number">1</span>)</div><div class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> java.lang.IllegalArgumentException();</div><div class="line">      Picture pic = <span class="keyword">new</span> Picture(width() - <span class="number">1</span>, height());</div><div class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> h = <span class="number">0</span>; h &lt; pic.height(); h++) &#123;</div><div class="line"></div><div class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> w = <span class="number">0</span>; w &lt; seam[h]; w++) &#123;</div><div class="line">              pic.set(w, h, mPicture.get(w, h));</div><div class="line">          &#125;</div><div class="line"></div><div class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> w = seam[h] + <span class="number">1</span>; w &lt; width(); w++) &#123;</div><div class="line">              pic.set(w - <span class="number">1</span>, h, mPicture.get(w, h));</div><div class="line"></div><div class="line">          &#125;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">this</span>.mPicture = pic;</div><div class="line">  &#125;</div><div class="line">`</div></pre></td></tr></table></figure>
</code></pre><p>##后记<br>提交了n次，虽然通过了正确性测试，但是timing的5个测试全部没有通过，看样子此算法还是太过复杂了。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[blog迁移]]></title>
      <url>http://felixzhang00.github.io/2015/04/03/2015-04-03-blog%E8%BF%81%E7%A7%BB/</url>
      <content type="html"><![CDATA[<p>曾经花了一天时间才吭哧吭哧在github上搭建并写出第一篇blog，后来就再也没写过。<br>虽然用github写blog很酷，但我觉得自己应该拿最易上手的工具来写blog，以此养成写东西分享的习惯，达到此目的后再来追求跟酷炫的效果和更个性化的功能。通过对比各家博客平台，最终我选择了CSDN，这是我的<a href="http://blog.csdn.net/u012455213" target="_blank" rel="external">blog地址</a>.</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Poj第1083题--Moving Tables]]></title>
      <url>http://felixzhang00.github.io/2015/04/03/2015-04-03-Poj%E7%AC%AC1083%E9%A2%98--%E7%A7%BB%E5%8A%A8%E6%A1%8C%E5%AD%90/</url>
      <content type="html"><![CDATA[<h2 id="原题"><a href="#原题" class="headerlink" title="原题"></a><a href="http://poj.org/problem?id=1083" target="_blank" rel="external">原题</a></h2><p>Moving Tables</p>
<p>Description</p>
<p>The famous ACM (Advanced Computer Maker) Company has rented a floor of a building whose shape is in the following figure. </p>
<p>The floor has 200 rooms each on the north side and south side along the corridor. Recently the Company made a plan to reform its system. The reform includes moving a lot of tables between rooms. Because the corridor is narrow and all the tables are big, only one table can pass through the corridor. Some plan is needed to make the moving efficient. The manager figured out the following plan: Moving a table from a room to another room can be done within 10 minutes. When moving a table from room i to room j, the part of the corridor between the front of room i and the front of room j is used. So, during each 10 minutes, several moving between two rooms not sharing the same part of the corridor will be done simultaneously. To make it clear the manager illustrated the possible cases and impossible cases of simultaneous moving. </p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><pre><code>将一组测试数据存放到一张二维数组m[1...n][2]中，其中m[1...n][0]存放搬桌子的起始点，m[1...n][1]存放搬桌子的终点。
然后将房间号转化为过道号。
最后遍历过道号数组，找到搬桌子经过次数最多的过道号，找到此最大的次数，这就是并行处理需要的最多的单位时间了。
</code></pre><h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line">	</div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"><span class="keyword">import</span> java.util.Arrays;</div><div class="line"><span class="keyword">import</span> java.util.Scanner;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NumberFormatException,</span></div><div class="line">            IOException &#123;</div><div class="line">        Scanner read = <span class="keyword">new</span> Scanner(System.in);</div><div class="line">        <span class="keyword">int</span> t = read.nextInt(); <span class="comment">//一共有t组测试数据</span></div><div class="line">        <span class="keyword">int</span> s;  <span class="comment">//s张桌子将搬动</span></div><div class="line">        <span class="keyword">int</span>[][] m; <span class="comment">//存放几组搬桌子起点终点的房间号</span></div><div class="line"></div><div class="line">        <span class="keyword">int</span>[] corridors = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">200</span>]; <span class="comment">//过道下标为k(对应的房间号为2k-1和2k+2),其值表示桌子经过过道的次数</span></div><div class="line">        <span class="keyword">int</span> start; <span class="comment">//开始的过道编号</span></div><div class="line">        <span class="keyword">int</span> len;   <span class="comment">//搬桌子的距离</span></div><div class="line">        <span class="keyword">int</span> max;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t; i++) &#123;</div><div class="line">            Arrays.fill(corridors, <span class="number">0</span>);  <span class="comment">//对每组数据都重新初始化</span></div><div class="line">            s = read.nextInt();</div><div class="line">            m = <span class="keyword">new</span> <span class="keyword">int</span>[s][<span class="number">2</span>];</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; s; j++) &#123;</div><div class="line">                m[j][<span class="number">0</span>] = read.nextInt();</div><div class="line">                m[j][<span class="number">1</span>] = read.nextInt();</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">//遍历所有桌子，更新corridors数组中的值</span></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; s; j++) &#123;</div><div class="line">                <span class="comment">//将房间号转化为对应的过道号</span></div><div class="line">                <span class="keyword">if</span> (m[j][<span class="number">0</span>] % <span class="number">2</span> == <span class="number">0</span>) &#123;</div><div class="line">                    m[j][<span class="number">0</span>] = m[j][<span class="number">0</span>] / <span class="number">2</span> - <span class="number">1</span>;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    m[j][<span class="number">0</span>] = m[j][<span class="number">0</span>] / <span class="number">2</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (m[j][<span class="number">1</span>] % <span class="number">2</span> == <span class="number">0</span>) &#123;</div><div class="line">                    m[j][<span class="number">1</span>] = m[j][<span class="number">1</span>] / <span class="number">2</span> - <span class="number">1</span>;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    m[j][<span class="number">1</span>] = m[j][<span class="number">1</span>] / <span class="number">2</span>;</div><div class="line"></div><div class="line">                &#125;</div><div class="line"></div><div class="line">                len = Math.abs(m[j][<span class="number">0</span>] - m[j][<span class="number">1</span>]) + <span class="number">1</span>;</div><div class="line">                start = Math.min(m[j][<span class="number">0</span>], m[j][<span class="number">1</span>]);</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; len; k++) &#123;</div><div class="line">                    corridors[start + k]++;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">//找到某个搬桌子过程中经过次数最多的过道号，找到此最大的次数</span></div><div class="line">            max = corridors[<span class="number">0</span>];</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; <span class="number">200</span>; j++) &#123;</div><div class="line">                <span class="keyword">if</span> (corridors[j] &gt; max) &#123;</div><div class="line">                    max = corridors[j];</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            System.out.println(max * <span class="number">10</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">`</div></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[绘制可自由伸缩的输入框背景]]></title>
      <url>http://felixzhang00.github.io/2015/02/05/2015-02-05-draw-input/</url>
      <content type="html"><![CDATA[<p>用Photoshop为Android绘制输入框背景图效果：</p>
<p><img src="http://7viip0.com1.z0.glb.clouddn.com/resultshow.jpg" width="250" height="250" style="margin-left: 0px"></p>
<h2 id="简单的输入框制作过程"><a href="#简单的输入框制作过程" class="headerlink" title="简单的输入框制作过程"></a>简单的输入框制作过程</h2><p>###新建图层<br>快捷键cmd+shift+alt+N</p>
<p>###选用圆角矩形工具画出输入框，填充白色<br><img src="http://7viip0.com1.z0.glb.clouddn.com/2015-02-05yuanjugongju.png" width="200" style="margin-left: 0px"></p>
<p><img src="http://7viip0.com1.z0.glb.clouddn.com/2015-02-05yuanjuxing.png" width="200" style="margin-left: 0px"></p>
<p>###设置图层样式<br><img src="http://7viip0.com1.z0.glb.clouddn.com/2015-02-05tucengyangshi.png" width="300" style="margin-left: 0px"></p>
<p>###切图<br>使用Photoshop插件LayerCraft切图</p>
<p><img src="http://7viip0.com1.z0.glb.clouddn.com/2015-02-05qietu.png" width="150" style="margin-left: 0px"></p>
<p>###制成.9.png格式<br>用系统提供的draw9patch工具。</p>
<p><img src="http://7viip0.com1.z0.glb.clouddn.com/2015-02-05ninepatch.png" width="300" style="margin-left: 0px"></p>
<p>左、上黑线决定图形的伸缩区域，下、右的黑线决定文字填充的区域。</p>
<p>###完成</p>
]]></content>
    </entry>
    
  
  
</search>
